{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CSS Kustomize Documentation","text":"<p>Welcome to the CSS Kustomize project documentation! This project provides Kubernetes manifests for the Community Solid Server with comprehensive Dagger automation for CI/CD pipelines.</p>"},{"location":"#overview","title":"Overview","text":"<p>CSS Kustomize is a modern DevOps solution that combines:</p> <ul> <li>Kubernetes Manifests: Production-ready configurations for Community Solid Server</li> <li>Kustomize Overlays: Environment-specific customizations with proper release name strategies</li> <li>Dagger Automation: Containerized CI/CD pipelines with comprehensive linting and validation</li> <li>Python CLI: Rich command-line interface for development and deployment workflows</li> </ul> <p>Author's Note: But why not helm? After all, there is a chart. I simply like kustomize more. Use the helm chart, it's great, and most of the components are built directly to match the features of the chart. I've tried to create some good mix-match overlays to represent what I experiment with. I'll happily take PRs with more!</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automated-cicd-pipeline","title":"\ud83d\ude80 Automated CI/CD Pipeline","text":"<ul> <li>Comprehensive linting (YAML, Python, Markdown)</li> <li>Kustomize validation and manifest generation</li> <li>Security scanning for Kubernetes resources</li> <li>Parallel execution for maximum performance</li> </ul>"},{"location":"#release-name-strategy","title":"\ud83c\udff7\ufe0f Release Name Strategy","text":"<ul> <li>Consistent <code>app.kubernetes.io/instance</code> labeling</li> <li>Environment-specific release names</li> <li>Proper resource isolation and identification</li> <li>Easy querying and management</li> </ul>"},{"location":"#developer-experience","title":"\ud83d\udd27 Developer Experience","text":"<ul> <li>Rich CLI with colored output and progress indicators</li> <li>Verbose mode for debugging and troubleshooting</li> <li>Fast feedback loops with caching strategies</li> <li>Cross-platform compatibility</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with CSS Kustomize in just a few commands:</p> <pre><code># Clone the repository\ngit clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n\n# Install dependencies\npoetry install\n\n# Run comprehensive CI pipeline\npoetry run dagger-pipeline ci\n\n# Generate manifests for all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Build specific overlay\nkubectl kustomize overlays/without-pvc\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>css-kustomize/\n\u251c\u2500\u2500 base/                    # Base Kubernetes manifests\n\u251c\u2500\u2500 overlays/               # Environment-specific overlays\n\u2502   \u251c\u2500\u2500 with-pvc/          # Production with persistent storage\n\u2502   \u2514\u2500\u2500 without-pvc/       # Stateless deployment\n\u251c\u2500\u2500 dagger_pipeline/       # Dagger automation code\n\u2502   \u251c\u2500\u2500 main.py           # CLI interface\n\u2502   \u2514\u2500\u2500 pipeline.py       # Core pipeline logic\n\u251c\u2500\u2500 docs/                  # Documentation source\n\u251c\u2500\u2500 manifests/            # Generated manifests\n\u2514\u2500\u2500 scripts/              # Utility scripts\n</code></pre>"},{"location":"#cli-commands","title":"CLI Commands","text":"<p>The project provides a comprehensive CLI for all operations:</p> <pre><code># Linting and validation\npoetry run dagger-pipeline lint --yaml --python --markdown\npoetry run dagger-pipeline validate\n\n# Manifest generation\npoetry run dagger-pipeline generate manifests/\npoetry run dagger-pipeline generate-overlay with-pvc manifests/\n\n# Security scanning\npoetry run dagger-pipeline security-scan\npoetry run dagger-pipeline security-scan-generated manifests/\n\n# Version management\n# NB, the version is the app.kubernetes.io/version not the CSS image tag.\npoetry run dagger-pipeline version update 0.3.0\npoetry run dagger-pipeline version report\n\n# Complete CI pipeline\npoetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#getting-started","title":"\ud83d\udcda Getting Started","text":"<ul> <li>Installation - Set up your development environment</li> <li>Quick Start - Get running in minutes</li> <li>Configuration - Customize for your needs</li> </ul>"},{"location":"#user-guide","title":"\ud83d\udc65 User Guide","text":"<ul> <li>CLI Commands - Complete command reference</li> <li>Kustomize Overlays - Working with overlays</li> <li>Release Names - Release name strategy</li> <li>Version Management - Managing versions</li> </ul>"},{"location":"#developer-guide","title":"\ud83d\udd27 Developer Guide","text":"<ul> <li>Architecture - System design and components</li> <li>Dagger Pipeline - Pipeline internals</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<ul> <li>Pipeline Module - Core pipeline classes and functions</li> <li>CLI Module - Command-line interface reference</li> </ul>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":"<ul> <li>Basic Usage - Common workflows</li> <li>Advanced Workflows - Complex scenarios</li> <li>CI/CD Integration - Integration patterns</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: Report bugs and request features on GitHub Issues</li> <li>Discussions: Join the conversation in GitHub Discussions</li> <li>Contributing: See our Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache 2.0 License. See the LICENSE file for details.</p>"},{"location":"README-versioning/","title":"Documentation Versioning Setup","text":"<p>This document explains how version information is included in the GitHub Pages documentation built from MkDocs.</p>"},{"location":"README-versioning/#implementation","title":"Implementation","text":"<p>The CSS Kustomize project uses the following approach for documentation versioning:</p>"},{"location":"README-versioning/#1-mike-for-version-management","title":"1. Mike for Version Management","text":"<ul> <li>Tool: mike - A utility for managing multiple versions of MkDocs documentation</li> <li>Configuration: Added to <code>mkdocs.yml</code> with <code>version.provider: mike</code></li> <li>Dependency: Added <code>mike = \"^2.1.0\"</code> to <code>pyproject.toml</code> docs dependencies</li> </ul>"},{"location":"README-versioning/#2-automatic-version-detection","title":"2. Automatic Version Detection","text":"<ul> <li>Source: Project version from <code>pyproject.toml</code></li> <li>Method: Uses <code>poetry version --short</code> to get current version</li> <li>Integration: GitHub Actions workflow automatically deploys with current version</li> </ul>"},{"location":"README-versioning/#3-github-actions-integration","title":"3. GitHub Actions Integration","text":"<p>The CI workflow (<code>.github/workflows/ci.yml</code>) includes:</p> <pre><code>- name: Get version from pyproject.toml\n  id: get_version\n  run: |\n    VERSION=$(poetry version --short)\n    echo \"version=$VERSION\" &gt;&gt; $GITHUB_OUTPUT\n\n- name: Deploy documentation with mike\n  run: |\n    poetry run mike deploy --push --update-aliases ${{ steps.get_version.outputs.version }} latest\n    poetry run mike set-default --push latest\n</code></pre>"},{"location":"README-versioning/#4-dagger-pipeline-integration","title":"4. Dagger Pipeline Integration","text":"<p>The project includes Dagger-based commands for documentation management:</p> <pre><code># Build documentation\npoetry run dagger-pipeline docs build\n\n# Serve locally\npoetry run dagger-pipeline docs serve\n\n# Deploy with versioning\npoetry run dagger-pipeline docs deploy\n\n# List versions\npoetry run dagger-pipeline docs list-versions\n\n# Delete version\npoetry run dagger-pipeline docs delete-version 1.0.0\n</code></pre>"},{"location":"README-versioning/#features","title":"Features","text":""},{"location":"README-versioning/#version-selector","title":"Version Selector","text":"<p>Users can switch between different versions of the documentation using the version selector in the Material theme.</p>"},{"location":"README-versioning/#version-display","title":"Version Display","text":"<ul> <li>Current version is displayed in the documentation</li> <li>Version information is automatically updated based on <code>pyproject.toml</code></li> <li>Each deployment creates a versioned copy of the documentation</li> </ul>"},{"location":"README-versioning/#aliases","title":"Aliases","text":"<ul> <li><code>latest</code> alias always points to the most recent version</li> <li>Custom aliases can be set during deployment</li> <li>Default version can be configured</li> </ul>"},{"location":"README-versioning/#usage-examples","title":"Usage Examples","text":""},{"location":"README-versioning/#manual-deployment","title":"Manual Deployment","text":"<pre><code># Deploy current version\npoetry run dagger-pipeline docs deploy\n\n# Deploy specific version with alias\npoetry run dagger-pipeline docs deploy --version 1.2.3 --alias stable\n\n# Deploy and set as default\npoetry run dagger-pipeline docs deploy --version 1.2.3 --set-default\n</code></pre>"},{"location":"README-versioning/#automatic-deployment","title":"Automatic Deployment","text":"<p>Documentation is automatically deployed when:</p> <ul> <li>Changes are pushed to the <code>main</code> branch</li> <li>The CI pipeline completes successfully</li> <li>Uses the current project version from <code>pyproject.toml</code></li> </ul>"},{"location":"README-versioning/#benefits","title":"Benefits","text":"<ol> <li>Version History: Maintain documentation for multiple releases</li> <li>User Experience: Users can access version-specific documentation</li> <li>Automation: Seamless integration with CI/CD pipeline</li> <li>Consistency: Version information stays in sync with project releases</li> <li>Flexibility: Support for custom versions and aliases</li> </ol>"},{"location":"README-versioning/#file-structure","title":"File Structure","text":"<pre><code>\u251c\u2500\u2500 mkdocs.yml                 # MkDocs configuration with mike provider\n\u251c\u2500\u2500 pyproject.toml            # Project version source\n\u251c\u2500\u2500 .github/workflows/ci.yml  # Automated deployment\n\u251c\u2500\u2500 dagger_pipeline/\n\u2502   \u251c\u2500\u2500 main.py              # CLI commands for docs\n\u2502   \u2514\u2500\u2500 pipeline.py          # Dagger implementation\n\u2514\u2500\u2500 docs/\n    \u2514\u2500\u2500 user-guide/\n        \u2514\u2500\u2500 documentation-versioning.md  # User guide\n</code></pre> <p>This setup provides a robust, automated solution for including version information in GitHub Pages documentation while maintaining multiple versions for different releases.</p>"},{"location":"developer-guide/architecture/","title":"Architecture","text":"<p>Understanding the CSS Kustomize project architecture and design decisions.</p>"},{"location":"developer-guide/architecture/#overview","title":"Overview","text":"<p>CSS Kustomize is designed as a modern DevOps solution that combines Kubernetes manifests, Kustomize overlays, and Dagger automation for a complete CI/CD experience.</p>"},{"location":"developer-guide/architecture/#system-components","title":"System Components","text":""},{"location":"developer-guide/architecture/#1-base-kubernetes-manifests","title":"1. Base Kubernetes Manifests","text":"<p>Located in <code>base/</code>, these provide the foundation:</p> <ul> <li><code>deployment.yaml</code>: Core Community Solid Server deployment</li> <li><code>service.yaml</code>: Kubernetes service configuration</li> <li><code>kustomization.yaml</code>: Base Kustomize configuration</li> </ul>"},{"location":"developer-guide/architecture/#2-overlay-system","title":"2. Overlay System","text":"<p>Environment-specific configurations in <code>overlays/</code>:</p> <ul> <li>with-pvc: Production with storage</li> <li>without-pvc: Stateless production</li> </ul>"},{"location":"developer-guide/architecture/#3-dagger-pipeline","title":"3. Dagger Pipeline","text":"<p>Python-based automation in <code>dagger_pipeline/</code>:</p> <ul> <li>main.py: CLI interface using Click</li> <li>pipeline.py: Core pipeline logic and Dagger functions</li> </ul>"},{"location":"developer-guide/architecture/#4-documentation-system","title":"4. Documentation System","text":"<p>MkDocs-based documentation:</p> <ul> <li>docs/: Source documentation</li> <li>mkdocs.yml: Configuration</li> <li>Auto-generated API docs: From Python docstrings</li> </ul>"},{"location":"developer-guide/architecture/#design-principles","title":"Design Principles","text":""},{"location":"developer-guide/architecture/#1-containerized-everything","title":"1. Containerized Everything","text":"<p>All operations run in containers via Dagger:</p> <ul> <li>Consistent execution environment</li> <li>Reproducible builds</li> <li>No local tool dependencies</li> </ul>"},{"location":"developer-guide/architecture/#2-release-name-strategy","title":"2. Release Name Strategy","text":"<p>Consistent labeling across all resources:</p> <ul> <li><code>app.kubernetes.io/instance</code> labels</li> <li>Environment-specific release names</li> <li>Proper resource isolation</li> </ul>"},{"location":"developer-guide/architecture/#3-version-management","title":"3. Version Management","text":"<p>Centralized version control:</p> <ul> <li>Semantic versioning</li> <li>Consistent across all overlays</li> <li>Automated updates and validation</li> </ul>"},{"location":"developer-guide/architecture/#4-developer-experience","title":"4. Developer Experience","text":"<p>Rich CLI with modern features:</p> <ul> <li>Colored output and progress indicators</li> <li>Verbose mode for debugging</li> <li>Parallel execution options</li> </ul>"},{"location":"developer-guide/architecture/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Base YAML     \u2502    \u2502   Kustomize      \u2502    \u2502   Generated     \u2502\n\u2502   Manifests     \u2502\u2500\u2500\u2500\u25b6\u2502   Overlays       \u2502\u2500\u2500\u2500\u25b6\u2502   Manifests     \u2502\n\u2502                 \u2502    \u2502                  \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u25bc                       \u25bc                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Linting &amp;     \u2502    \u2502   Validation     \u2502    \u2502   Security      \u2502\n\u2502   Formatting    \u2502    \u2502   Checks         \u2502    \u2502   Scanning      \u2502\n\u2502                 \u2502    \u2502                  \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"developer-guide/architecture/#technology-stack","title":"Technology Stack","text":""},{"location":"developer-guide/architecture/#core-technologies","title":"Core Technologies","text":"<ul> <li>Kubernetes: Container orchestration platform</li> <li>Kustomize: Kubernetes configuration management</li> <li>Dagger: Containerized CI/CD pipelines</li> <li>Python: Automation and CLI development</li> </ul>"},{"location":"developer-guide/architecture/#development-tools","title":"Development Tools","text":"<ul> <li>Poetry: Dependency management</li> <li>Click: CLI framework</li> <li>Ruff: Python linting and formatting</li> <li>yamllint: YAML validation</li> <li>MkDocs: Documentation generation</li> </ul>"},{"location":"developer-guide/architecture/#container-images","title":"Container Images","text":"<ul> <li>Community Solid Server: Main application</li> <li>Alpine Linux: Base for utility containers</li> <li>Python: For Dagger pipeline execution</li> </ul>"},{"location":"developer-guide/architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"developer-guide/architecture/#container-security","title":"Container Security","text":"<ul> <li>Non-root user execution</li> <li>Read-only root filesystems</li> <li>Security contexts applied</li> <li>Resource limits enforced</li> </ul>"},{"location":"developer-guide/architecture/#pipeline-security","title":"Pipeline Security","text":"<ul> <li>Isolated container execution</li> <li>No persistent credentials</li> <li>Scan generated manifests</li> <li>Validate security contexts</li> </ul>"},{"location":"developer-guide/architecture/#access-control","title":"Access Control","text":"<ul> <li>RBAC-ready manifests</li> <li>Service account configuration</li> <li>Network policy support</li> <li>Secret management patterns</li> </ul>"},{"location":"developer-guide/architecture/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"developer-guide/architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>Stateless deployment options</li> <li>Load balancer ready services</li> <li>Resource request/limit patterns</li> </ul>"},{"location":"developer-guide/architecture/#performance","title":"Performance","text":"<ul> <li>Parallel pipeline execution</li> <li>Dagger caching strategies</li> <li>Efficient container builds</li> <li>Optimized manifest generation</li> </ul>"},{"location":"developer-guide/architecture/#extension-points","title":"Extension Points","text":""},{"location":"developer-guide/architecture/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create overlay directory structure</li> <li>Define kustomization.yaml</li> <li>Add to CLI overlay list</li> <li>Update documentation</li> </ol>"},{"location":"developer-guide/architecture/#custom-pipeline-steps","title":"Custom Pipeline Steps","text":"<ol> <li>Extend pipeline.py with new functions</li> <li>Add CLI commands in main.py</li> <li>Update documentation</li> <li>Add tests</li> </ol>"},{"location":"developer-guide/architecture/#integration-hooks","title":"Integration Hooks","text":"<ul> <li>Pre-commit hooks for development</li> <li>CI/CD pipeline integration</li> <li>Custom validation rules</li> <li>External tool integration</li> </ul>"},{"location":"developer-guide/architecture/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"developer-guide/architecture/#pipeline-metrics","title":"Pipeline Metrics","text":"<ul> <li>Execution time tracking</li> <li>Success/failure rates</li> <li>Resource usage monitoring</li> <li>Cache hit rates</li> </ul>"},{"location":"developer-guide/architecture/#application-metrics","title":"Application Metrics","text":"<ul> <li>Kubernetes resource monitoring</li> <li>Application health checks</li> <li>Performance metrics</li> <li>Error tracking</li> </ul>"},{"location":"developer-guide/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dagger Pipeline internals</li> <li>Read Contributing Guide</li> <li>Explore Examples</li> </ul>"},{"location":"developer-guide/contributing/","title":"Contributing","text":"<p>Guidelines for contributing to the CSS Kustomize project.</p>"},{"location":"developer-guide/contributing/#getting-started","title":"Getting Started","text":""},{"location":"developer-guide/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/your-username/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install development dependencies:</li> </ol> <pre><code>poetry install --with=lint,docs\n</code></pre> <ol> <li>Set up pre-commit hooks:</li> </ol> <pre><code>poetry run pre-commit install\n</code></pre> <ol> <li>Verify setup:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"developer-guide/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a feature branch:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li> <p>Make your changes following the coding standards</p> </li> <li> <p>Run tests and linting:</p> </li> </ol> <pre><code>poetry run dagger-pipeline lint\npoetry run dagger-pipeline validate\n</code></pre> <ol> <li>Commit your changes:</li> </ol> <pre><code>git add .\ngit commit -m \"feat: add new feature\"\n</code></pre>"},{"location":"developer-guide/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"developer-guide/contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all functions</li> <li>Write comprehensive docstrings</li> <li>Use ruff for linting and formatting</li> </ul>"},{"location":"developer-guide/contributing/#yaml-files","title":"YAML Files","text":"<ul> <li>Use 2-space indentation</li> <li>Follow yamllint configuration</li> <li>Use meaningful names and comments</li> </ul>"},{"location":"developer-guide/contributing/#documentation","title":"Documentation","text":"<ul> <li>Write clear, concise documentation</li> <li>Include code examples</li> <li>Update relevant sections</li> </ul>"},{"location":"developer-guide/contributing/#testing","title":"Testing","text":""},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run complete CI pipeline\npoetry run dagger-pipeline ci\n\n# Run specific tests\npoetry run dagger-pipeline lint --python-only\npoetry run dagger-pipeline validate\npoetry run dagger-pipeline security-scan\n</code></pre>"},{"location":"developer-guide/contributing/#adding-tests","title":"Adding Tests","text":"<ul> <li>Add tests for new functionality</li> <li>Ensure good test coverage</li> <li>Test both success and failure cases</li> </ul>"},{"location":"developer-guide/contributing/#documentation_1","title":"Documentation","text":""},{"location":"developer-guide/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Install docs dependencies\npoetry install --only=docs\n\n# Build documentation\npoetry run mkdocs build\n\n# Serve locally\npoetry run mkdocs serve\n</code></pre>"},{"location":"developer-guide/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include practical examples</li> <li>Update navigation in mkdocs.yml</li> <li>Follow existing structure</li> </ul>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"developer-guide/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Ensure all tests pass:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre> <ol> <li> <p>Update documentation if needed</p> </li> <li> <p>Add changelog entry if applicable</p> </li> </ol>"},{"location":"developer-guide/contributing/#submitting","title":"Submitting","text":"<ol> <li>Push your branch:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li> <p>Create pull request with:</p> </li> <li> <p>Clear description of changes</p> </li> <li>Reference to related issues</li> <li> <p>Screenshots if applicable</p> </li> <li> <p>Address review feedback promptly</p> </li> </ol>"},{"location":"developer-guide/contributing/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"developer-guide/contributing/#for-authors","title":"For Authors","text":"<ul> <li>Keep changes focused and small</li> <li>Write clear commit messages</li> <li>Respond to feedback constructively</li> <li>Update based on suggestions</li> </ul>"},{"location":"developer-guide/contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be constructive and helpful</li> <li>Focus on code quality and maintainability</li> <li>Test the changes locally</li> <li>Approve when ready</li> </ul>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":""},{"location":"developer-guide/contributing/#version-updates","title":"Version Updates","text":"<pre><code># Update version across overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Validate changes\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"developer-guide/contributing/#creating-releases","title":"Creating Releases","text":"<ol> <li>Update version numbers</li> <li>Update changelog</li> <li>Create git tag</li> <li>Generate release notes</li> </ol>"},{"location":"developer-guide/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"developer-guide/contributing/#communication","title":"Communication","text":"<ul> <li>Be respectful and inclusive</li> <li>Use clear, professional language</li> <li>Help others learn and grow</li> <li>Share knowledge and experience</li> </ul>"},{"location":"developer-guide/contributing/#issue-reporting","title":"Issue Reporting","text":"<ul> <li>Use issue templates</li> <li>Provide clear reproduction steps</li> <li>Include relevant system information</li> <li>Search existing issues first</li> </ul>"},{"location":"developer-guide/contributing/#getting-help","title":"Getting Help","text":""},{"location":"developer-guide/contributing/#resources","title":"Resources","text":"<ul> <li>Documentation: Read the full documentation</li> <li>Issues: Search existing issues</li> <li>Discussions: Join GitHub discussions</li> <li>Code: Review existing code patterns</li> </ul>"},{"location":"developer-guide/contributing/#contact","title":"Contact","text":"<ul> <li>GitHub Issues: For bugs and feature requests</li> <li>GitHub Discussions: For questions and ideas</li> <li>Pull Requests: For code contributions</li> </ul>"},{"location":"developer-guide/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized through:</p> <ul> <li>GitHub contributor graphs</li> <li>Release notes mentions</li> <li>Documentation credits</li> <li>Community acknowledgments</li> </ul> <p>Thank you for contributing to CSS Kustomize!</p>"},{"location":"developer-guide/dagger-pipeline/","title":"Dagger Pipeline","text":"<p>Deep dive into the Dagger pipeline implementation and internals.</p>"},{"location":"developer-guide/dagger-pipeline/#overview","title":"Overview","text":"<p>The CSS Kustomize project uses Dagger for containerized CI/CD pipelines, providing consistent execution environments and reproducible builds.</p>"},{"location":"developer-guide/dagger-pipeline/#pipeline-architecture","title":"Pipeline Architecture","text":""},{"location":"developer-guide/dagger-pipeline/#core-components","title":"Core Components","text":"<pre><code>@dagger.function\nasync def lint_yaml(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Run YAML linting with yamllint.\"\"\"\n    return await (\n        self.base_container()\n        .with_directory(\"/src\", source)\n        .with_workdir(\"/src\")\n        .with_exec([\"yamllint\", \".\"])\n        .stdout()\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-strategy","title":"Container Strategy","text":"<p>All operations run in isolated containers:</p> <ul> <li>Base Container: Alpine Linux with required tools</li> <li>Tool-Specific Containers: Specialized for each operation</li> <li>Caching: Aggressive caching for performance</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#pipeline-functions","title":"Pipeline Functions","text":""},{"location":"developer-guide/dagger-pipeline/#linting-operations","title":"Linting Operations","text":""},{"location":"developer-guide/dagger-pipeline/#yaml-linting","title":"YAML Linting","text":"<pre><code>async def lint_yaml(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Lint YAML files using yamllint.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#python-linting","title":"Python Linting","text":"<pre><code>async def lint_python(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Lint Python files using ruff.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#markdown-linting","title":"Markdown Linting","text":"<pre><code>async def lint_markdown(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Check Markdown formatting.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#validation-operations","title":"Validation Operations","text":""},{"location":"developer-guide/dagger-pipeline/#kustomize-validation","title":"Kustomize Validation","text":"<pre><code>async def validate_kustomize(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Validate all Kustomize overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#version-validation","title":"Version Validation","text":"<pre><code>async def validate_versions(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Validate version consistency across overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#generation-operations","title":"Generation Operations","text":""},{"location":"developer-guide/dagger-pipeline/#manifest-generation","title":"Manifest Generation","text":"<pre><code>async def generate_manifests(\n    self, \n    source: dagger.Directory,\n    output_dir: str\n) -&gt; dagger.Directory:\n    \"\"\"Generate Kubernetes manifests for all overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#single-overlay-generation","title":"Single Overlay Generation","text":"<pre><code>async def generate_overlay(\n    self,\n    source: dagger.Directory,\n    overlay_name: str\n) -&gt; str:\n    \"\"\"Generate manifest for specific overlay.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#security-operations","title":"Security Operations","text":""},{"location":"developer-guide/dagger-pipeline/#security-scanning","title":"Security Scanning","text":"<pre><code>async def security_scan(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Run security checks on Kustomize configurations.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#generated-manifest-scanning","title":"Generated Manifest Scanning","text":"<pre><code>async def security_scan_generated(\n    self,\n    manifests_dir: dagger.Directory\n) -&gt; str:\n    \"\"\"Scan generated manifests for security issues.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-images","title":"Container Images","text":""},{"location":"developer-guide/dagger-pipeline/#base-container","title":"Base Container","text":"<pre><code>def base_container(self) -&gt; dagger.Container:\n    \"\"\"Create base container with common tools.\"\"\"\n    return (\n        dag.container()\n        .from_(\"alpine:3.19\")\n        .with_exec([\"apk\", \"add\", \"--no-cache\", \n                   \"python3\", \"py3-pip\", \"kubectl\", \"git\"])\n        .with_exec([\"pip\", \"install\", \"yamllint\", \"ruff\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#specialized-containers","title":"Specialized Containers","text":""},{"location":"developer-guide/dagger-pipeline/#kustomize-container","title":"Kustomize Container","text":"<pre><code>def kustomize_container(self) -&gt; dagger.Container:\n    \"\"\"Container with kubectl and kustomize.\"\"\"\n    return (\n        self.base_container()\n        .with_exec([\"kubectl\", \"version\", \"--client\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#security-scanner-container","title":"Security Scanner Container","text":"<pre><code>def security_container(self) -&gt; dagger.Container:\n    \"\"\"Container with security scanning tools.\"\"\"\n    return (\n        self.base_container()\n        .with_exec([\"pip\", \"install\", \"checkov\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#caching-strategy","title":"Caching Strategy","text":""},{"location":"developer-guide/dagger-pipeline/#layer-caching","title":"Layer Caching","text":"<p>Dagger automatically caches container layers:</p> <ul> <li>Base image layers</li> <li>Package installation layers</li> <li>Tool installation layers</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#volume-caching","title":"Volume Caching","text":"<p>Persistent caches for:</p> <ul> <li>Package manager caches</li> <li>Tool caches</li> <li>Build artifacts</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#cache-keys","title":"Cache Keys","text":"<p>Cache invalidation based on:</p> <ul> <li>Source code changes</li> <li>Dependency changes</li> <li>Tool version changes</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#parallel-execution","title":"Parallel Execution","text":""},{"location":"developer-guide/dagger-pipeline/#concurrent-operations","title":"Concurrent Operations","text":"<pre><code>async def run_parallel_linting(self, source: dagger.Directory):\n    \"\"\"Run linting operations in parallel.\"\"\"\n    tasks = [\n        self.lint_yaml(source),\n        self.lint_python(source),\n        self.lint_markdown(source)\n    ]\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#resource-management","title":"Resource Management","text":"<ul> <li>CPU and memory limits</li> <li>Concurrent operation limits</li> <li>Resource sharing strategies</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#error-handling","title":"Error Handling","text":""},{"location":"developer-guide/dagger-pipeline/#exception-management","title":"Exception Management","text":"<pre><code>try:\n    result = await self.lint_yaml(source)\nexcept dagger.ExecError as e:\n    logger.error(f\"YAML linting failed: {e}\")\n    raise PipelineError(\"Linting failed\") from e\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>Continue on non-critical failures</li> <li>Aggregate error reporting</li> <li>Detailed error context</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#integration-points","title":"Integration Points","text":""},{"location":"developer-guide/dagger-pipeline/#cli-integration","title":"CLI Integration","text":"<pre><code>@click.command()\n@click.option(\"--verbose\", is_flag=True)\nasync def lint(verbose: bool):\n    \"\"\"Run linting pipeline.\"\"\"\n    async with dagger.Connection() as client:\n        pipeline = CSSKustomizePipeline(client)\n        result = await pipeline.lint_all(source_dir)\n        click.echo(result)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#cicd-integration","title":"CI/CD Integration","text":"<pre><code>async def ci_pipeline(self, source: dagger.Directory) -&gt; bool:\n    \"\"\"Complete CI pipeline.\"\"\"\n    # Run all operations\n    lint_result = await self.lint_all(source)\n    validate_result = await self.validate_all(source)\n    security_result = await self.security_scan_all(source)\n\n    return all([lint_result, validate_result, security_result])\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#performance-optimization","title":"Performance Optimization","text":""},{"location":"developer-guide/dagger-pipeline/#build-optimization","title":"Build Optimization","text":"<ul> <li>Multi-stage container builds</li> <li>Minimal base images</li> <li>Efficient layer ordering</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#execution-optimization","title":"Execution Optimization","text":"<ul> <li>Parallel operation execution</li> <li>Smart dependency management</li> <li>Resource pooling</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#cache-optimization","title":"Cache Optimization","text":"<ul> <li>Aggressive caching strategies</li> <li>Cache warming techniques</li> <li>Cache invalidation optimization</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"developer-guide/dagger-pipeline/#verbose-mode","title":"Verbose Mode","text":"<pre><code>if verbose:\n    container = container.with_env_variable(\"DAGGER_LOG_LEVEL\", \"debug\")\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-inspection","title":"Container Inspection","text":"<pre><code># Debug container state\ndebug_container = (\n    container\n    .with_exec([\"ls\", \"-la\"])\n    .with_exec([\"env\"])\n)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#log-collection","title":"Log Collection","text":"<pre><code># Collect logs from failed operations\nlogs = await container.stderr()\nlogger.error(f\"Operation failed: {logs}\")\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#extension-patterns","title":"Extension Patterns","text":""},{"location":"developer-guide/dagger-pipeline/#adding-new-operations","title":"Adding New Operations","text":"<ol> <li>Define Function:</li> </ol> <pre><code>@dagger.function\nasync def new_operation(self, source: dagger.Directory) -&gt; str:\n    \"\"\"New pipeline operation.\"\"\"\n</code></pre> <ol> <li>Add CLI Command:</li> </ol> <pre><code>@click.command()\nasync def new_command():\n    \"\"\"CLI command for new operation.\"\"\"\n</code></pre> <ol> <li>Integrate with CI:</li> </ol> <pre><code># Add to ci_pipeline function\nnew_result = await self.new_operation(source)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#custom-containers","title":"Custom Containers","text":"<pre><code>def custom_container(self) -&gt; dagger.Container:\n    \"\"\"Custom container for specific needs.\"\"\"\n    return (\n        dag.container()\n        .from_(\"custom/base:latest\")\n        .with_exec([\"custom-tool\", \"--version\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#best-practices","title":"Best Practices","text":""},{"location":"developer-guide/dagger-pipeline/#container-design","title":"Container Design","text":"<ul> <li>Use minimal base images</li> <li>Install only required tools</li> <li>Leverage multi-stage builds</li> <li>Implement proper caching</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#function-design","title":"Function Design","text":"<ul> <li>Keep functions focused and small</li> <li>Use proper error handling</li> <li>Implement comprehensive logging</li> <li>Design for testability</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#performance","title":"Performance","text":"<ul> <li>Use parallel execution where possible</li> <li>Implement proper caching</li> <li>Optimize container layers</li> <li>Monitor resource usage</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Contributing</li> <li>Explore Architecture</li> <li>Check Examples</li> </ul>"},{"location":"examples/advanced-workflows/","title":"Advanced Workflows","text":"<p>Complex scenarios and advanced usage patterns for CSS Kustomize.</p>"},{"location":"examples/advanced-workflows/#multi-environment-deployments","title":"Multi-Environment Deployments","text":""},{"location":"examples/advanced-workflows/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<pre><code># Development environment\npoetry run dagger-pipeline generate-overlay without-pvc manifests/dev.yaml\n\n# Staging environment  \npoetry run dagger-pipeline generate-overlay with-pvc manifests/staging.yaml\n\n# Production environment\npoetry run dagger-pipeline generate-overlay with-pvc manifests/prod.yaml\n</code></pre>"},{"location":"examples/advanced-workflows/#automated-environment-promotion","title":"Automated Environment Promotion","text":"<pre><code>#!/bin/bash\n# promote-environment.sh\n\nENVIRONMENT=$1\nVERSION=$2\n\ncase $ENVIRONMENT in\n  \"staging\")\n    OVERLAY=\"without-pvc\"\n    ;;\n  \"production\")\n    OVERLAY=\"with-pvc\"\n    ;;\n  *)\n    echo \"Unknown environment: $ENVIRONMENT\"\n    exit 1\n    ;;\nesac\n\n# Update version\npoetry run dagger-pipeline update-overlay-version $OVERLAY $VERSION\n\n# Validate and generate\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline generate-overlay $OVERLAY manifests/$ENVIRONMENT.yaml\n\n# Deploy\nkubectl apply -f manifests/$ENVIRONMENT.yaml\n</code></pre>"},{"location":"examples/advanced-workflows/#custom-overlay-development","title":"Custom Overlay Development","text":""},{"location":"examples/advanced-workflows/#creating-new-overlays","title":"Creating New Overlays","text":"<pre><code># Create new overlay directory\nmkdir -p overlays/custom-env\n\n# Create kustomization.yaml\ncat &gt; overlays/custom-env/kustomization.yaml &lt;&lt; EOF\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: custom-namespace\n\nresources:\n  - ../../base\n\nlabels:\n  - includeSelectors: false\n    pairs:\n      app.kubernetes.io/instance: css-custom\n      app.kubernetes.io/version: \"6.0.3\"\n      environment: custom\n\nimages:\n  - name: solidproject/community-server\n    newTag: \"6.0.3\"\n\npatches:\n  - target:\n      kind: Deployment\n      name: community-solid-server\n    patch: |-\n      - op: replace\n        path: /spec/replicas\n        value: 3\nEOF\n</code></pre>"},{"location":"examples/advanced-workflows/#advanced-patching","title":"Advanced Patching","text":"<pre><code># overlays/custom-env/resource-patches.yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\npatches:\n  # Add resource limits\n  - target:\n      kind: Deployment\n      name: community-solid-server\n    patch: |-\n      - op: add\n        path: /spec/template/spec/containers/0/resources\n        value:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n\n  # Add environment variables\n  - target:\n      kind: Deployment\n      name: community-solid-server\n    patch: |-\n      - op: add\n        path: /spec/template/spec/containers/0/env\n        value:\n          - name: CSS_CONFIG\n            value: \"/config/custom-config.json\"\n          - name: CSS_LOG_LEVEL\n            value: \"debug\"\n</code></pre>"},{"location":"examples/advanced-workflows/#pipeline-customization","title":"Pipeline Customization","text":""},{"location":"examples/advanced-workflows/#custom-validation-rules","title":"Custom Validation Rules","text":"<pre><code># custom_validators.py\nimport yaml\nfrom pathlib import Path\n\ndef validate_custom_rules(overlay_path: str) -&gt; bool:\n    \"\"\"Custom validation rules for overlays.\"\"\"\n    kustomization_path = Path(overlay_path) / \"kustomization.yaml\"\n\n    with open(kustomization_path) as f:\n        config = yaml.safe_load(f)\n\n    # Ensure namespace is set\n    if \"namespace\" not in config:\n        print(f\"ERROR: {overlay_path} missing namespace\")\n        return False\n\n    # Ensure resource limits are set for production\n    if \"prod\" in overlay_path:\n        patches = config.get(\"patches\", [])\n        has_resource_limits = any(\n            \"resources\" in str(patch) for patch in patches\n        )\n        if not has_resource_limits:\n            print(f\"ERROR: {overlay_path} missing resource limits\")\n            return False\n\n    return True\n</code></pre>"},{"location":"examples/advanced-workflows/#extended-security-scanning","title":"Extended Security Scanning","text":"<pre><code>#!/bin/bash\n# advanced-security-scan.sh\n\necho \"\ud83d\udd0d Running advanced security scans...\"\n\n# Generate all manifests\npoetry run dagger-pipeline generate manifests/\n\n# Custom security checks\necho \"Checking for privileged containers...\"\nif grep -r \"privileged: true\" manifests/; then\n    echo \"\u274c Found privileged containers\"\n    exit 1\nfi\n\necho \"Checking for root users...\"\nif grep -r \"runAsUser: 0\" manifests/; then\n    echo \"\u274c Found containers running as root\"\n    exit 1\nfi\n\necho \"Checking for host network access...\"\nif grep -r \"hostNetwork: true\" manifests/; then\n    echo \"\u274c Found containers with host network access\"\n    exit 1\nfi\n\necho \"Checking for missing security contexts...\"\nfor manifest in manifests/*.yaml; do\n    if ! grep -q \"securityContext\" \"$manifest\"; then\n        echo \"\u26a0\ufe0f  Missing security context in $manifest\"\n    fi\ndone\n\necho \"\u2705 Advanced security scan completed\"\n</code></pre>"},{"location":"examples/advanced-workflows/#parallel-processing-workflows","title":"Parallel Processing Workflows","text":""},{"location":"examples/advanced-workflows/#concurrent-overlay-processing","title":"Concurrent Overlay Processing","text":"<pre><code># parallel_processing.py\nimport asyncio\nimport dagger\nfrom pathlib import Path\n\nasync def process_overlays_parallel():\n    \"\"\"Process multiple overlays in parallel.\"\"\"\n    overlays = [\"with-pvc\", \"without-pvc\"]\n\n    async with dagger.Connection() as client:\n        tasks = []\n        for overlay in overlays:\n            task = generate_and_validate_overlay(client, overlay)\n            tasks.append(task)\n\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        for overlay, result in zip(overlays, results):\n            if isinstance(result, Exception):\n                print(f\"\u274c {overlay}: {result}\")\n            else:\n                print(f\"\u2705 {overlay}: Success\")\n\nasync def generate_and_validate_overlay(client, overlay_name):\n    \"\"\"Generate and validate a single overlay.\"\"\"\n    # Generate manifest\n    manifest = await generate_overlay(client, overlay_name)\n\n    # Validate manifest\n    await validate_manifest(client, manifest)\n\n    # Security scan\n    await security_scan_manifest(client, manifest)\n\n    return f\"Processed {overlay_name}\"\n</code></pre>"},{"location":"examples/advanced-workflows/#batch-operations","title":"Batch Operations","text":"<pre><code>#!/bin/bash\n# batch-operations.sh\n\nOPERATIONS=(\"lint\" \"validate\" \"security-scan\")\nOVERLAYS=(\"with-pvc\" \"without-pvc\")\n\n# Run operations in parallel\nfor op in \"${OPERATIONS[@]}\"; do\n    echo \"\ud83d\ude80 Running $op...\"\n    poetry run dagger-pipeline $op --parallel &amp;\ndone\n\n# Wait for all operations to complete\nwait\n\necho \"\u2705 All batch operations completed\"\n\n# Generate all overlays in parallel\necho \"\ud83d\udce6 Generating manifests...\"\npoetry run dagger-pipeline generate --parallel manifests/\n\necho \"\ud83c\udf89 Batch processing complete!\"\n</code></pre>"},{"location":"examples/advanced-workflows/#integration-with-external-systems","title":"Integration with External Systems","text":""},{"location":"examples/advanced-workflows/#gitops-integration","title":"GitOps Integration","text":"<pre><code># .github/workflows/gitops.yml\nname: GitOps Deployment\n\non:\n  push:\n    branches: [main]\n    paths: ['overlays/**', 'base/**']\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install Poetry\n        uses: snok/install-poetry@v1\n\n      - name: Install dependencies\n        run: poetry install\n\n      - name: Run CI pipeline\n        run: poetry run dagger-pipeline ci --parallel --verbose\n\n      - name: Generate manifests\n        run: poetry run dagger-pipeline generate manifests/\n\n      - name: Deploy to staging\n        if: github.ref == 'refs/heads/main'\n        run: |\n          kubectl apply -f manifests/with-pvc.yaml\n          kubectl rollout status deployment/css-with-pvc\n</code></pre>"},{"location":"examples/advanced-workflows/#monitoring-integration","title":"Monitoring Integration","text":"<pre><code># monitoring_integration.py\nimport requests\nimport json\nfrom datetime import datetime\n\ndef send_metrics_to_prometheus(metrics):\n    \"\"\"Send custom metrics to Prometheus.\"\"\"\n    prometheus_gateway = \"http://prometheus-pushgateway:9091\"\n\n    for metric_name, value in metrics.items():\n        payload = f\"{metric_name} {value}\\n\"\n\n        response = requests.post(\n            f\"{prometheus_gateway}/metrics/job/css-kustomize\",\n            data=payload,\n            headers={'Content-Type': 'text/plain'}\n        )\n\n        if response.status_code != 200:\n            print(f\"Failed to send metric {metric_name}: {response.text}\")\n\ndef collect_pipeline_metrics():\n    \"\"\"Collect metrics from pipeline execution.\"\"\"\n    return {\n        \"css_kustomize_build_duration_seconds\": 45.2,\n        \"css_kustomize_overlays_generated\": 4,\n        \"css_kustomize_security_issues\": 0,\n        \"css_kustomize_lint_errors\": 0\n    }\n\n# Usage in pipeline\nmetrics = collect_pipeline_metrics()\nsend_metrics_to_prometheus(metrics)\n</code></pre>"},{"location":"examples/advanced-workflows/#advanced-testing-strategies","title":"Advanced Testing Strategies","text":""},{"location":"examples/advanced-workflows/#integration-testing","title":"Integration Testing","text":"<pre><code>#!/bin/bash\n# integration-test.sh\n\necho \"\ud83e\uddea Running integration tests...\"\n\n# Start test cluster\nkind create cluster --name css-test\n\n# Generate and apply manifests\npoetry run dagger-pipeline generate manifests/\nkubectl apply -f manifests/without-pvc.yaml\n\n# Wait for deployment\nkubectl wait --for=condition=available --timeout=300s deployment/css-local\n\n# Test application endpoints\nkubectl port-forward service/css-local 3000:3000 &amp;\nPF_PID=$!\n\nsleep 5\n\n# Test health endpoint\nif curl -f http://localhost:3000/.well-known/solid; then\n    echo \"\u2705 Health check passed\"\nelse\n    echo \"\u274c Health check failed\"\n    exit 1\nfi\n\n# Cleanup\nkill $PF_PID\nkind delete cluster --name css-test\n\necho \"\ud83c\udf89 Integration tests completed\"\n</code></pre>"},{"location":"examples/advanced-workflows/#performance-testing","title":"Performance Testing","text":"<pre><code># performance_test.py\nimport time\nimport subprocess\nimport statistics\n\ndef measure_pipeline_performance():\n    \"\"\"Measure pipeline execution times.\"\"\"\n    operations = [\n        \"lint --yaml-only\",\n        \"lint --python-only\", \n        \"validate\",\n        \"security-scan\"\n    ]\n\n    results = {}\n\n    for op in operations:\n        times = []\n        for _ in range(3):  # Run 3 times\n            start = time.time()\n            subprocess.run(\n                f\"poetry run dagger-pipeline {op}\",\n                shell=True,\n                check=True,\n                capture_output=True\n            )\n            end = time.time()\n            times.append(end - start)\n\n        results[op] = {\n            \"mean\": statistics.mean(times),\n            \"median\": statistics.median(times),\n            \"min\": min(times),\n            \"max\": max(times)\n        }\n\n    return results\n\n# Generate performance report\nperf_results = measure_pipeline_performance()\nfor op, stats in perf_results.items():\n    print(f\"{op}: {stats['mean']:.2f}s (\u00b1{stats['max']-stats['min']:.2f}s)\")\n</code></pre>"},{"location":"examples/advanced-workflows/#disaster-recovery","title":"Disaster Recovery","text":""},{"location":"examples/advanced-workflows/#backup-and-restore","title":"Backup and Restore","text":"<pre><code>#!/bin/bash\n# backup-restore.sh\n\nbackup_configs() {\n    echo \"\ud83d\udce6 Backing up configurations...\"\n\n    # Create backup directory\n    BACKUP_DIR=\"backups/$(date +%Y%m%d_%H%M%S)\"\n    mkdir -p \"$BACKUP_DIR\"\n\n    # Backup overlays\n    cp -r overlays/ \"$BACKUP_DIR/\"\n    cp -r base/ \"$BACKUP_DIR/\"\n\n    # Backup generated manifests\n    cp -r manifests/ \"$BACKUP_DIR/\"\n\n    # Create metadata\n    cat &gt; \"$BACKUP_DIR/metadata.json\" &lt;&lt; EOF\n{\n    \"timestamp\": \"$(date -Iseconds)\",\n    \"git_commit\": \"$(git rev-parse HEAD)\",\n    \"git_branch\": \"$(git branch --show-current)\"\n}\nEOF\n\n    echo \"\u2705 Backup created: $BACKUP_DIR\"\n}\n\nrestore_configs() {\n    BACKUP_DIR=$1\n\n    if [[ ! -d \"$BACKUP_DIR\" ]]; then\n        echo \"\u274c Backup directory not found: $BACKUP_DIR\"\n        exit 1\n    fi\n\n    echo \"\ud83d\udd04 Restoring from backup: $BACKUP_DIR\"\n\n    # Restore configurations\n    cp -r \"$BACKUP_DIR/overlays/\" .\n    cp -r \"$BACKUP_DIR/base/\" .\n\n    # Regenerate manifests\n    poetry run dagger-pipeline generate manifests/\n\n    echo \"\u2705 Restore completed\"\n}\n\ncase $1 in\n    \"backup\")\n        backup_configs\n        ;;\n    \"restore\")\n        restore_configs $2\n        ;;\n    *)\n        echo \"Usage: $0 {backup|restore &lt;backup_dir&gt;}\"\n        exit 1\n        ;;\nesac\n</code></pre>"},{"location":"examples/advanced-workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Explore CI/CD Integration patterns</li> <li>Review Basic Usage examples</li> <li>Check Developer Guide</li> <li>Learn about Dagger Pipeline internals</li> </ul>"},{"location":"examples/basic-usage/","title":"Basic Usage Examples","text":"<p>Common workflows and usage patterns for CSS Kustomize.</p>"},{"location":"examples/basic-usage/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"examples/basic-usage/#1-initial-setup","title":"1. Initial Setup","text":"<pre><code># Clone and setup\ngit clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\npoetry install\n\n# Verify installation\npoetry run dagger-pipeline --help\n</code></pre>"},{"location":"examples/basic-usage/#2-run-complete-ci-pipeline","title":"2. Run Complete CI Pipeline","text":"<pre><code># Run all checks and validations\npoetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"examples/basic-usage/#3-generate-all-manifests","title":"3. Generate All Manifests","text":"<pre><code># Generate manifests for all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Check generated files\nls -la manifests/\n</code></pre>"},{"location":"examples/basic-usage/#development-workflows","title":"Development Workflows","text":""},{"location":"examples/basic-usage/#daily-development","title":"Daily Development","text":"<pre><code># Quick linting during development\npoetry run dagger-pipeline lint --yaml --python\n\n# Validate Kustomize configurations\npoetry run dagger-pipeline validate\n\n# Generate specific overlay for testing\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/test.yaml\n</code></pre>"},{"location":"examples/basic-usage/#pre-commit-workflow","title":"Pre-commit Workflow","text":"<pre><code># Setup pre-commit hooks\npoetry run pre-commit install\n\n# Run hooks manually\npoetry run pre-commit run --all-files\n\n# Or use the CLI wrapper\npoetry run dagger-pipeline pre-commit\n</code></pre>"},{"location":"examples/basic-usage/#overlay-management","title":"Overlay Management","text":""},{"location":"examples/basic-usage/#working-with-specific-overlays","title":"Working with Specific Overlays","text":"<pre><code># Generate local development overlay\npoetry run dagger-pipeline generate-overlay without-pvc manifests/local.yaml\n\n# Generate production overlay with PVC\npoetry run dagger-pipeline generate-overlay with-pvc manifests/production.yaml\n\n# Validate specific overlay\nkubectl kustomize overlays/with-pvc --dry-run=client\n</code></pre>"},{"location":"examples/basic-usage/#comparing-overlays","title":"Comparing Overlays","text":"<pre><code># Generate all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Compare differences\ndiff manifests/with-pvc.yaml manifests/without-pvc.yaml\n</code></pre>"},{"location":"examples/basic-usage/#version-management","title":"Version Management","text":""},{"location":"examples/basic-usage/#updating-versions","title":"Updating Versions","text":"<pre><code># Check current versions\npoetry run dagger-pipeline version-report\n\n# Update to new version (dry run first)\npoetry run dagger-pipeline version update --dry-run 6.0.3\n\n# Apply version update\npoetry run dagger-pipeline version update 6.0.3\n\n# Validate consistency\npoetry run dagger-pipeline validate-versions\n</code></pre>"},{"location":"examples/basic-usage/#single-overlay-version-update","title":"Single Overlay Version Update","text":"<pre><code># Update only development overlay\npoetry run dagger-pipeline update-overlay-version without-pvc 6.1.0-beta.1\n\n# Update production overlay\npoetry run dagger-pipeline update-overlay-version with-pvc 6.0.3\n</code></pre>"},{"location":"examples/basic-usage/#security-scanning","title":"Security Scanning","text":""},{"location":"examples/basic-usage/#scanning-configurations","title":"Scanning Configurations","text":"<pre><code># Scan Kustomize configurations\npoetry run dagger-pipeline security-scan\n\n# Scan generated manifests\npoetry run dagger-pipeline generate manifests/\npoetry run dagger-pipeline security-scan-generated manifests/\n</code></pre>"},{"location":"examples/basic-usage/#security-best-practices","title":"Security Best Practices","text":"<pre><code># Always scan before deployment\npoetry run dagger-pipeline security-scan --verbose\n\n# Check for common security issues\ngrep -r \"privileged: true\" overlays/ || echo \"No privileged containers found\"\ngrep -r \"runAsRoot: true\" overlays/ || echo \"No root containers found\"\n</code></pre>"},{"location":"examples/basic-usage/#deployment-examples","title":"Deployment Examples","text":""},{"location":"examples/basic-usage/#local-development","title":"Local Development","text":"<pre><code># Generate local overlay\npoetry run dagger-pipeline generate-overlay without-pvc manifests/local.yaml\n\n# Deploy to local cluster\nkubectl apply -f manifests/local.yaml\n\n# Check deployment\nkubectl get pods -l app.kubernetes.io/instance=css-local\n</code></pre>"},{"location":"examples/basic-usage/#production-deployment","title":"Production Deployment","text":"<pre><code># Generate production manifest\npoetry run dagger-pipeline generate-overlay with-pvc manifests/production.yaml\n\n# Review before deployment\nkubectl apply -f manifests/production.yaml --dry-run=client\n\n# Deploy to production\nkubectl apply -f manifests/production.yaml\n\n# Monitor deployment\nkubectl rollout status deployment/css-with-pvc\n</code></pre>"},{"location":"examples/basic-usage/#troubleshooting-examples","title":"Troubleshooting Examples","text":""},{"location":"examples/basic-usage/#debugging-failed-builds","title":"Debugging Failed Builds","text":"<pre><code># Run with maximum verbosity\npoetry run dagger-pipeline ci --verbose\n\n# Check specific component\npoetry run dagger-pipeline lint --python-only --verbose\n\n# Validate individual overlay\nkubectl kustomize overlays/with-pvc\n</code></pre>"},{"location":"examples/basic-usage/#fixing-common-issues","title":"Fixing Common Issues","text":"<pre><code># Fix YAML formatting issues\npoetry run dagger-pipeline lint --yaml-only\n\n# Check for version mismatches\npoetry run dagger-pipeline validate-versions --verbose\n\n# Regenerate all manifests\nrm -rf manifests/\npoetry run dagger-pipeline generate manifests/\n</code></pre>"},{"location":"examples/basic-usage/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/basic-usage/#git-hooks","title":"Git Hooks","text":"<pre><code># Pre-commit hook\npoetry run dagger-pipeline lint --yaml --python\n\n# Pre-push hook\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"examples/basic-usage/#ide-integration","title":"IDE Integration","text":"<pre><code>// VS Code tasks.json\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"CSS Kustomize: Lint\",\n      \"type\": \"shell\",\n      \"command\": \"poetry\",\n      \"args\": [\"run\", \"dagger-pipeline\", \"lint\"],\n      \"group\": \"build\"\n    },\n    {\n      \"label\": \"CSS Kustomize: Generate\",\n      \"type\": \"shell\",\n      \"command\": \"poetry\",\n      \"args\": [\"run\", \"dagger-pipeline\", \"generate\", \"manifests/\"],\n      \"group\": \"build\"\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/basic-usage/#performance-tips","title":"Performance Tips","text":""},{"location":"examples/basic-usage/#faster-development","title":"Faster Development","text":"<pre><code># Run only what you need\npoetry run dagger-pipeline lint --yaml-only\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/quick-test.yaml\n\n# Use parallel execution\npoetry run dagger-pipeline lint --parallel\npoetry run dagger-pipeline generate --parallel manifests/\n</code></pre>"},{"location":"examples/basic-usage/#caching-optimization","title":"Caching Optimization","text":"<pre><code># Warm up caches\npoetry run dagger-pipeline lint\n\n# Subsequent runs will be faster\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"examples/basic-usage/#monitoring-and-validation","title":"Monitoring and Validation","text":""},{"location":"examples/basic-usage/#health-checks","title":"Health Checks","text":"<pre><code># Validate all configurations\npoetry run dagger-pipeline validate\n\n# Check generated manifests\npoetry run dagger-pipeline generate manifests/\nkubectl apply -f manifests/ --dry-run=client --validate=true\n</code></pre>"},{"location":"examples/basic-usage/#resource-monitoring","title":"Resource Monitoring","text":"<pre><code># Check resource usage after deployment\nkubectl top pods -l app.kubernetes.io/name=community-solid-server\n\n# Monitor logs\nkubectl logs -l app.kubernetes.io/instance=css-with-pvc -f\n</code></pre>"},{"location":"examples/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Advanced Workflows</li> <li>Learn about CI/CD Integration</li> <li>Read CLI Commands reference</li> <li>Check Kustomize Overlays guide</li> </ul>"},{"location":"examples/cicd-integration/","title":"CI/CD Integration","text":"<p>Integration patterns and examples for CSS Kustomize in various CI/CD platforms.</p>"},{"location":"examples/cicd-integration/#github-actions","title":"GitHub Actions","text":""},{"location":"examples/cicd-integration/#basic-ci-pipeline","title":"Basic CI Pipeline","text":"<pre><code># .github/workflows/ci.yml\nname: CI Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  lint-and-validate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install Poetry\n        uses: snok/install-poetry@v1\n        with:\n          version: latest\n          virtualenvs-create: true\n          virtualenvs-in-project: true\n\n      - name: Load cached venv\n        id: cached-poetry-dependencies\n        uses: actions/cache@v3\n        with:\n          path: .venv\n          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}\n\n      - name: Install dependencies\n        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'\n        run: poetry install --no-interaction --no-root\n\n      - name: Install project\n        run: poetry install --no-interaction\n\n      - name: Run CI pipeline\n        run: poetry run dagger-pipeline ci --parallel --verbose\n\n      - name: Upload manifests\n        uses: actions/upload-artifact@v3\n        with:\n          name: kubernetes-manifests\n          path: manifests/\n</code></pre>"},{"location":"examples/cicd-integration/#advanced-cicd-with-deployment","title":"Advanced CI/CD with Deployment","text":"<pre><code># .github/workflows/deploy.yml\nname: Deploy\n\non:\n  push:\n    branches: [main]\n    tags: ['v*']\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    outputs:\n      version: ${{ steps.version.outputs.version }}\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install Poetry\n        uses: snok/install-poetry@v1\n\n      - name: Install dependencies\n        run: poetry install\n\n      - name: Extract version\n        id: version\n        run: |\n          if [[ $GITHUB_REF == refs/tags/* ]]; then\n            VERSION=${GITHUB_REF#refs/tags/v}\n          else\n            VERSION=\"main-$(git rev-parse --short HEAD)\"\n          fi\n          echo \"version=$VERSION\" &gt;&gt; $GITHUB_OUTPUT\n\n      - name: Update version in manifests\n        run: poetry run dagger-pipeline version update ${{ steps.version.outputs.version }}\n\n      - name: Run CI pipeline\n        run: poetry run dagger-pipeline ci --parallel --verbose\n\n      - name: Generate manifests\n        run: poetry run dagger-pipeline generate manifests/\n\n      - name: Upload manifests\n        uses: actions/upload-artifact@v3\n        with:\n          name: manifests-${{ steps.version.outputs.version }}\n          path: manifests/\n\n  deploy-staging:\n    needs: ci\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    environment: staging\n    steps:\n      - name: Download manifests\n        uses: actions/download-artifact@v3\n        with:\n          name: manifests-${{ needs.ci.outputs.version }}\n          path: manifests/\n\n      - name: Setup kubectl\n        uses: azure/setup-kubectl@v3\n        with:\n          version: 'latest'\n\n      - name: Configure kubectl\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" | base64 -d &gt; kubeconfig\n          export KUBECONFIG=kubeconfig\n\n      - name: Deploy to staging\n        run: |\n          kubectl apply -f manifests/with-pvc.yaml\n          kubectl rollout status deployment/css-with-pvc --timeout=300s\n\n  deploy-production:\n    needs: [ci, deploy-staging]\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/v')\n    environment: production\n    steps:\n      - name: Download manifests\n        uses: actions/download-artifact@v3\n        with:\n          name: manifests-${{ needs.ci.outputs.version }}\n          path: manifests/\n\n      - name: Setup kubectl\n        uses: azure/setup-kubectl@v3\n\n      - name: Deploy to production\n        run: |\n          kubectl apply -f manifests/with-pvc.yaml\n          kubectl rollout status deployment/css-with-pvc --timeout=600s\n</code></pre>"},{"location":"examples/cicd-integration/#gitlab-ci","title":"GitLab CI","text":""},{"location":"examples/cicd-integration/#basic-pipeline","title":"Basic Pipeline","text":"<pre><code># .gitlab-ci.yml\nstages:\n  - lint\n  - validate\n  - build\n  - deploy\n\nvariables:\n  PYTHON_VERSION: \"3.11\"\n\nbefore_script:\n  - apt-get update -qq &amp;&amp; apt-get install -y -qq git curl\n  - curl -sSL https://install.python-poetry.org | python3 -\n  - export PATH=\"$HOME/.local/bin:$PATH\"\n  - poetry --version\n\nlint:\n  stage: lint\n  image: python:${PYTHON_VERSION}\n  script:\n    - poetry install\n    - poetry run dagger-pipeline lint --parallel\n  artifacts:\n    reports:\n      junit: reports/lint-results.xml\n    when: always\n\nvalidate:\n  stage: validate\n  image: python:${PYTHON_VERSION}\n  script:\n    - poetry install\n    - poetry run dagger-pipeline validate\n    - poetry run dagger-pipeline security-scan\n  dependencies:\n    - lint\n\nbuild-manifests:\n  stage: build\n  image: python:${PYTHON_VERSION}\n  script:\n    - poetry install\n    - poetry run dagger-pipeline generate manifests/\n  artifacts:\n    paths:\n      - manifests/\n    expire_in: 1 week\n  dependencies:\n    - validate\n\ndeploy-staging:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  script:\n    - kubectl apply -f manifests/with-pvc.yaml\n    - kubectl rollout status deployment/css-with-pvc\n  environment:\n    name: staging\n    url: https://css-staging.example.com\n  only:\n    - main\n  dependencies:\n    - build-manifests\n\ndeploy-production:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  script:\n    - kubectl apply -f manifests/with-pvc.yaml\n    - kubectl rollout status deployment/css-with-pvc\n  environment:\n    name: production\n    url: https://css.example.com\n  when: manual\n  only:\n    - tags\n  dependencies:\n    - build-manifests\n</code></pre>"},{"location":"examples/cicd-integration/#advanced-gitlab-pipeline","title":"Advanced GitLab Pipeline","text":"<pre><code># .gitlab-ci.yml (Advanced)\ninclude:\n  - template: Security/SAST.gitlab-ci.yml\n  - template: Security/Container-Scanning.gitlab-ci.yml\n\nstages:\n  - lint\n  - test\n  - security\n  - build\n  - deploy\n  - monitor\n\nvariables:\n  DOCKER_DRIVER: overlay2\n  DOCKER_TLS_CERTDIR: \"/certs\"\n\n.poetry_template: &amp;poetry_template\n  image: python:3.11\n  before_script:\n    - pip install poetry\n    - poetry install\n  cache:\n    paths:\n      - .venv/\n\nlint-yaml:\n  &lt;&lt;: *poetry_template\n  stage: lint\n  script:\n    - poetry run dagger-pipeline lint --yaml-only\n  artifacts:\n    reports:\n      junit: reports/yaml-lint.xml\n\nlint-python:\n  &lt;&lt;: *poetry_template\n  stage: lint\n  script:\n    - poetry run dagger-pipeline lint --python-only\n  artifacts:\n    reports:\n      junit: reports/python-lint.xml\n\nvalidate-kustomize:\n  &lt;&lt;: *poetry_template\n  stage: test\n  script:\n    - poetry run dagger-pipeline validate\n  dependencies:\n    - lint-yaml\n\nsecurity-scan-configs:\n  &lt;&lt;: *poetry_template\n  stage: security\n  script:\n    - poetry run dagger-pipeline security-scan\n  artifacts:\n    reports:\n      sast: reports/security-scan.json\n  dependencies:\n    - validate-kustomize\n\nbuild-all-manifests:\n  &lt;&lt;: *poetry_template\n  stage: build\n  script:\n    - poetry run dagger-pipeline generate --parallel manifests/\n    - poetry run dagger-pipeline security-scan-generated manifests/\n  artifacts:\n    paths:\n      - manifests/\n    reports:\n      sast: reports/manifest-security.json\n  dependencies:\n    - security-scan-configs\n\n.deploy_template: &amp;deploy_template\n  image: bitnami/kubectl:latest\n  before_script:\n    - echo \"$KUBECONFIG_CONTENT\" | base64 -d &gt; kubeconfig\n    - export KUBECONFIG=kubeconfig\n\ndeploy-review:\n  &lt;&lt;: *deploy_template\n  stage: deploy\n  script:\n    - kubectl create namespace css-review-$CI_MERGE_REQUEST_IID || true\n    - kubectl apply -f manifests/without-pvc.yaml -n css-review-$CI_MERGE_REQUEST_IID\n  environment:\n    name: review/$CI_MERGE_REQUEST_IID\n    url: https://css-review-$CI_MERGE_REQUEST_IID.example.com\n    on_stop: stop-review\n  only:\n    - merge_requests\n  dependencies:\n    - build-all-manifests\n\nstop-review:\n  &lt;&lt;: *deploy_template\n  stage: deploy\n  script:\n    - kubectl delete namespace css-review-$CI_MERGE_REQUEST_IID\n  environment:\n    name: review/$CI_MERGE_REQUEST_IID\n    action: stop\n  when: manual\n  only:\n    - merge_requests\n\ndeploy-staging:\n  &lt;&lt;: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f manifests/with-pvc.yaml\n    - kubectl rollout status deployment/css-with-pvc --timeout=300s\n  environment:\n    name: staging\n    url: https://css-staging.example.com\n  only:\n    - main\n  dependencies:\n    - build-all-manifests\n\ndeploy-production:\n  &lt;&lt;: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f manifests/with-pvc.yaml\n    - kubectl rollout status deployment/css-with-pvc --timeout=600s\n  environment:\n    name: production\n    url: https://css.example.com\n  when: manual\n  only:\n    - tags\n  dependencies:\n    - build-all-manifests\n\nmonitor-deployment:\n  stage: monitor\n  image: curlimages/curl:latest\n  script:\n    - |\n      for i in {1..30}; do\n        if curl -f https://css.example.com/.well-known/solid; then\n          echo \"\u2705 Health check passed\"\n          exit 0\n        fi\n        echo \"\u23f3 Waiting for service to be ready...\"\n        sleep 10\n      done\n      echo \"\u274c Health check failed\"\n      exit 1\n  only:\n    - tags\n  dependencies:\n    - deploy-production\n</code></pre>"},{"location":"examples/cicd-integration/#jenkins","title":"Jenkins","text":""},{"location":"examples/cicd-integration/#declarative-pipeline","title":"Declarative Pipeline","text":"<pre><code>// Jenkinsfile\npipeline {\n    agent any\n\n    environment {\n        PYTHON_VERSION = '3.11'\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh '''\n                    python3 -m pip install poetry\n                    poetry install\n                '''\n            }\n        }\n\n        stage('Lint') {\n            parallel {\n                stage('YAML Lint') {\n                    steps {\n                        sh 'poetry run dagger-pipeline lint --yaml-only'\n                    }\n                }\n                stage('Python Lint') {\n                    steps {\n                        sh 'poetry run dagger-pipeline lint --python-only'\n                    }\n                }\n            }\n        }\n\n        stage('Validate') {\n            steps {\n                sh 'poetry run dagger-pipeline validate'\n            }\n        }\n\n        stage('Security Scan') {\n            steps {\n                sh 'poetry run dagger-pipeline security-scan'\n            }\n        }\n\n        stage('Build Manifests') {\n            steps {\n                sh 'poetry run dagger-pipeline generate --parallel manifests/'\n                archiveArtifacts artifacts: 'manifests/**/*.yaml', fingerprint: true\n            }\n        }\n\n        stage('Deploy') {\n            when {\n                anyOf {\n                    branch 'main'\n                    tag pattern: 'v\\\\d+\\\\.\\\\d+\\\\.\\\\d+', comparator: 'REGEXP'\n                }\n            }\n            steps {\n                script {\n                    if (env.BRANCH_NAME == 'main') {\n                        sh '''\n                            kubectl apply -f manifests/with-pvc.yaml\n                            kubectl rollout status deployment/css-with-pvc\n                        '''\n                    } else if (env.TAG_NAME) {\n                        input message: 'Deploy to production?', ok: 'Deploy'\n                        sh '''\n                            kubectl apply -f manifests/with-pvc.yaml\n                            kubectl rollout status deployment/css-with-pvc --timeout=600s\n                        '''\n                    }\n                }\n            }\n        }\n    }\n\n    post {\n        always {\n            publishHTML([\n                allowMissing: false,\n                alwaysLinkToLastBuild: true,\n                keepAll: true,\n                reportDir: 'reports',\n                reportFiles: '*.html',\n                reportName: 'Pipeline Report'\n            ])\n        }\n        failure {\n            emailext (\n                subject: \"Pipeline Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\",\n                body: \"Pipeline failed. Check console output at ${env.BUILD_URL}\",\n                to: \"${env.CHANGE_AUTHOR_EMAIL}\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"examples/cicd-integration/#azure-devops","title":"Azure DevOps","text":""},{"location":"examples/cicd-integration/#azure-pipelines","title":"Azure Pipelines","text":"<pre><code># azure-pipelines.yml\ntrigger:\n  branches:\n    include:\n      - main\n      - develop\n  tags:\n    include:\n      - v*\n\npool:\n  vmImage: 'ubuntu-latest'\n\nvariables:\n  pythonVersion: '3.11'\n  poetryVersion: '1.6.1'\n\nstages:\n- stage: CI\n  displayName: 'CI Stage'\n  jobs:\n  - job: LintAndValidate\n    displayName: 'Lint and Validate'\n    steps:\n    - task: UsePythonVersion@0\n      inputs:\n        versionSpec: '$(pythonVersion)'\n      displayName: 'Use Python $(pythonVersion)'\n\n    - script: |\n        python -m pip install --upgrade pip\n        pip install poetry==$(poetryVersion)\n        poetry install\n      displayName: 'Install dependencies'\n\n    - script: |\n        poetry run dagger-pipeline lint --parallel\n      displayName: 'Run linting'\n\n    - script: |\n        poetry run dagger-pipeline validate\n      displayName: 'Validate Kustomize'\n\n    - script: |\n        poetry run dagger-pipeline security-scan\n      displayName: 'Security scan'\n\n    - script: |\n        poetry run dagger-pipeline generate --parallel manifests/\n      displayName: 'Generate manifests'\n\n    - task: PublishBuildArtifacts@1\n      inputs:\n        pathToPublish: 'manifests'\n        artifactName: 'kubernetes-manifests'\n      displayName: 'Publish manifests'\n\n- stage: Deploy\n  displayName: 'Deploy Stage'\n  dependsOn: CI\n  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/tags/v')))\n  jobs:\n  - deployment: DeployToStaging\n    displayName: 'Deploy to Staging'\n    condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')\n    environment: 'staging'\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n          - task: DownloadBuildArtifacts@0\n            inputs:\n              artifactName: 'kubernetes-manifests'\n              downloadPath: '$(System.ArtifactsDirectory)'\n\n          - task: Kubernetes@1\n            inputs:\n              connectionType: 'Kubernetes Service Connection'\n              kubernetesServiceEndpoint: 'staging-k8s'\n              command: 'apply'\n              arguments: '-f $(System.ArtifactsDirectory)/kubernetes-manifests/with-pvc.yaml'\n\n  - deployment: DeployToProduction\n    displayName: 'Deploy to Production'\n    condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/v')\n    environment: 'production'\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n          - task: DownloadBuildArtifacts@0\n            inputs:\n              artifactName: 'kubernetes-manifests'\n              downloadPath: '$(System.ArtifactsDirectory)'\n\n          - task: Kubernetes@1\n            inputs:\n              connectionType: 'Kubernetes Service Connection'\n              kubernetesServiceEndpoint: 'production-k8s'\n              command: 'apply'\n              arguments: '-f $(System.ArtifactsDirectory)/kubernetes-manifests/with-pvc.yaml'\n</code></pre>"},{"location":"examples/cicd-integration/#circleci","title":"CircleCI","text":""},{"location":"examples/cicd-integration/#configuration","title":"Configuration","text":"<pre><code># .circleci/config.yml\nversion: 2.1\n\norbs:\n  python: circleci/python@2.1.1\n  kubernetes: circleci/kubernetes@1.3.1\n\nexecutors:\n  python-executor:\n    docker:\n      - image: cimg/python:3.11\n    working_directory: ~/project\n\njobs:\n  lint-and-validate:\n    executor: python-executor\n    steps:\n      - checkout\n      - python/install-packages:\n          pkg-manager: poetry\n      - run:\n          name: Run linting\n          command: poetry run dagger-pipeline lint --parallel\n      - run:\n          name: Validate Kustomize\n          command: poetry run dagger-pipeline validate\n      - run:\n          name: Security scan\n          command: poetry run dagger-pipeline security-scan\n\n  build-manifests:\n    executor: python-executor\n    steps:\n      - checkout\n      - python/install-packages:\n          pkg-manager: poetry\n      - run:\n          name: Generate manifests\n          command: poetry run dagger-pipeline generate --parallel manifests/\n      - persist_to_workspace:\n          root: .\n          paths:\n            - manifests\n\n  deploy-staging:\n    executor: kubernetes/default\n    steps:\n      - attach_workspace:\n          at: .\n      - kubernetes/install-kubectl\n      - run:\n          name: Deploy to staging\n          command: |\n            kubectl apply -f manifests/with-pvc.yaml\n            kubectl rollout status deployment/css-with-pvc\n\n  deploy-production:\n    executor: kubernetes/default\n    steps:\n      - attach_workspace:\n          at: .\n      - kubernetes/install-kubectl\n      - run:\n          name: Deploy to production\n          command: |\n            kubectl apply -f manifests/with-pvc.yaml\n            kubectl rollout status deployment/css-with-pvc --timeout=600s\n\nworkflows:\n  version: 2\n  ci-cd:\n    jobs:\n      - lint-and-validate\n      - build-manifests:\n          requires:\n            - lint-and-validate\n      - deploy-staging:\n          requires:\n            - build-manifests\n          filters:\n            branches:\n              only: main\n      - deploy-production:\n          requires:\n            - build-manifests\n          filters:\n            tags:\n              only: /^v.*/\n            branches:\n              ignore: /.*/\n</code></pre>"},{"location":"examples/cicd-integration/#best-practices","title":"Best Practices","text":""},{"location":"examples/cicd-integration/#security-considerations","title":"Security Considerations","text":"<pre><code># Security best practices for CI/CD\nsecurity_practices:\n  secrets_management:\n    - Use CI/CD platform secret management\n    - Rotate secrets regularly\n    - Limit secret access scope\n\n  container_security:\n    - Scan container images\n    - Use minimal base images\n    - Run as non-root user\n\n  kubernetes_security:\n    - Use RBAC for deployments\n    - Scan manifests for security issues\n    - Implement network policies\n</code></pre>"},{"location":"examples/cicd-integration/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Caching strategies\ncache_strategies:\n  dependencies:\n    - Cache Poetry virtual environments\n    - Cache Docker layers\n    - Cache Dagger build cache\n\n  parallel_execution:\n    - Run linting in parallel\n    - Generate manifests concurrently\n    - Use matrix builds for multiple environments\n</code></pre>"},{"location":"examples/cicd-integration/#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<pre><code># Monitoring integration\nmonitoring:\n  health_checks:\n    - Application readiness probes\n    - Deployment status monitoring\n    - Service availability checks\n\n  alerting:\n    - Pipeline failure notifications\n    - Deployment status alerts\n    - Security scan alerts\n</code></pre>"},{"location":"examples/cicd-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Review Basic Usage examples</li> <li>Explore Advanced Workflows</li> <li>Check Developer Guide</li> <li>Learn about Dagger Pipeline</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Learn how to configure CSS Kustomize for your environment and needs.</p>"},{"location":"getting-started/configuration/#overview","title":"Overview","text":"<p>CSS Kustomize uses several configuration files and environment variables to customize behavior.</p>"},{"location":"getting-started/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"getting-started/configuration/#poetry-configuration-pyprojecttoml","title":"Poetry Configuration (<code>pyproject.toml</code>)","text":"<p>The main project configuration is in <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry]\nname = \"css-kustomize\"\nversion = \"0.1.0\"\ndescription = \"Kubernetes manifests for Community Solid Server\"\n\n[tool.poetry.scripts]\ndagger-pipeline = \"dagger_pipeline.main:cli\"\n</code></pre>"},{"location":"getting-started/configuration/#yaml-linting-yamllintyml","title":"YAML Linting (<code>.yamllint.yml</code>)","text":"<p>Configure YAML linting rules:</p> <pre><code>extends: default\nrules:\n  line-length:\n    max: 120\n  truthy:\n    allowed-values: ['true', 'false', 'on', 'off']\n</code></pre>"},{"location":"getting-started/configuration/#dagger-configuration-daggerjson","title":"Dagger Configuration (<code>dagger.json</code>)","text":"<p>Dagger engine configuration:</p> <pre><code>{\n  \"name\": \"css-kustomize\",\n  \"sdk\": \"python\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"getting-started/configuration/#dagger-settings","title":"Dagger Settings","text":"<ul> <li><code>DAGGER_LOG_LEVEL</code>: Set logging level (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>)</li> <li><code>DAGGER_CACHE_VOLUME</code>: Custom cache volume name</li> </ul>"},{"location":"getting-started/configuration/#cli-behavior","title":"CLI Behavior","text":"<ul> <li><code>NO_COLOR</code>: Disable colored output</li> <li><code>FORCE_COLOR</code>: Force colored output in non-TTY environments</li> </ul>"},{"location":"getting-started/configuration/#customization","title":"Customization","text":""},{"location":"getting-started/configuration/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create overlay directory in <code>overlays/</code></li> <li>Add <code>kustomization.yaml</code></li> <li>Update CLI to include new overlay</li> </ol>"},{"location":"getting-started/configuration/#modifying-base-resources","title":"Modifying Base Resources","text":"<p>Edit files in the <code>base/</code> directory to change default configurations.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Explore CLI Commands</li> <li>Learn about Kustomize Overlays</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you set up CSS Kustomize on your local development environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing CSS Kustomize, ensure you have the following tools installed:</p>"},{"location":"getting-started/installation/#required-tools","title":"Required Tools","text":"<ul> <li>Python 3.11+: The project requires Python 3.11 or later</li> <li>Poetry: For dependency management and virtual environments</li> <li>Docker: Required for Dagger containerized execution</li> <li>kubectl: For Kubernetes manifest validation and deployment</li> <li>Git: For version control</li> </ul>"},{"location":"getting-started/installation/#optional-tools","title":"Optional Tools","text":"<ul> <li>Kustomize: While not strictly required (Dagger containers include it), having it locally can be helpful</li> <li>yq: For YAML processing and debugging</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-poetry-recommended","title":"Method 1: Poetry (Recommended)","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install Poetry (if not already installed):</li> </ol> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code># Install all dependencies\npoetry install\n\n# Or install only specific groups\npoetry install --only=main,lint\npoetry install --only=docs  # For documentation development\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>poetry run dagger-pipeline --help\n</code></pre>"},{"location":"getting-started/installation/#method-2-development-installation","title":"Method 2: Development Installation","text":"<p>For active development on the CSS Kustomize project:</p> <ol> <li>Clone and enter the repository:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install in development mode:</li> </ol> <pre><code>poetry install --with=lint,docs\n</code></pre> <ol> <li>Set up pre-commit hooks:</li> </ol> <pre><code>poetry run pre-commit install\n</code></pre> <ol> <li>Run the test suite:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"getting-started/installation/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code># Update package list\nsudo apt update\n\n# Install Python 3.11\nsudo apt install python3.11 python3.11-venv python3-pip\n\n# Install Docker\nsudo apt install docker.io\nsudo usermod -aG docker $USER\nnewgrp docker\n\n# Install kubectl\ncurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install Homebrew (if not already installed)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install required tools\nbrew install python@3.11 docker kubectl poetry\n\n# Start Docker Desktop\nopen /Applications/Docker.app\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Install Python 3.11 from python.org</li> <li>Install Docker Desktop from docker.com</li> <li>Install kubectl using official instructions</li> <li>Install Poetry:    <pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -\n</code></pre></li> </ol>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>After installation, verify everything is working correctly:</p>"},{"location":"getting-started/installation/#1-check-python-version","title":"1. Check Python Version","text":"<pre><code>python --version\n# Should output: Python 3.11.x or later\n</code></pre>"},{"location":"getting-started/installation/#2-check-poetry","title":"2. Check Poetry","text":"<pre><code>poetry --version\n# Should output: Poetry (version 1.x.x)\n</code></pre>"},{"location":"getting-started/installation/#3-check-docker","title":"3. Check Docker","text":"<pre><code>docker --version\n# Should output: Docker version x.x.x\n</code></pre>"},{"location":"getting-started/installation/#4-check-kubectl","title":"4. Check kubectl","text":"<pre><code>kubectl version --client\n# Should output client version information\n</code></pre>"},{"location":"getting-started/installation/#5-test-css-kustomize","title":"5. Test CSS Kustomize","text":"<pre><code>cd css-kustomize\npoetry run dagger-pipeline --help\n# Should display the CLI help\n</code></pre>"},{"location":"getting-started/installation/#6-run-quick-test","title":"6. Run Quick Test","text":"<pre><code># Run a quick linting test\npoetry run dagger-pipeline lint --yaml-only\n\n# Generate a test manifest\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/test-manifest.yaml\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#poetry-not-found","title":"Poetry Not Found","text":"<p>If <code>poetry</code> command is not found after installation:</p> <pre><code># Add Poetry to PATH (Linux/macOS)\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# Or for zsh\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n</code></pre>"},{"location":"getting-started/installation/#docker-permission-denied","title":"Docker Permission Denied","text":"<p>If you get permission denied errors with Docker:</p> <pre><code># Linux: Add user to docker group\nsudo usermod -aG docker $USER\nnewgrp docker\n\n# Test Docker access\ndocker run hello-world\n</code></pre>"},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you have multiple Python versions:</p> <pre><code># Use Poetry with specific Python version\npoetry env use python3.11\n\n# Verify the environment\npoetry env info\n</code></pre>"},{"location":"getting-started/installation/#dagger-connection-issues","title":"Dagger Connection Issues","text":"<p>If Dagger fails to connect:</p> <pre><code># Ensure Docker is running\ndocker ps\n\n# Check Docker daemon\nsudo systemctl status docker  # Linux\nbrew services list | grep docker  # macOS\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check the logs: Run commands with <code>--verbose</code> flag for detailed output</li> <li>Search existing issues: Check GitHub Issues</li> <li>Create a new issue: Include your OS, Python version, and error messages</li> <li>Join discussions: Use GitHub Discussions</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete:</p> <ol> <li>Read the Quick Start Guide to get familiar with basic operations</li> <li>Review Configuration to customize the setup for your needs</li> <li>Explore CLI Commands to understand available operations</li> <li>Check out Examples for common workflows</li> </ol>"},{"location":"getting-started/installation/#development-environment","title":"Development Environment","text":"<p>For contributors and advanced users, see the Contributing Guide for additional setup steps including:</p> <ul> <li>Development dependencies</li> <li>Testing frameworks</li> <li>Documentation building</li> <li>Code quality tools</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with CSS Kustomize in just a few minutes.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Poetry</li> <li>Docker</li> <li>kubectl</li> </ul> <p>See the Installation Guide for detailed setup instructions.</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<ol> <li>Clone and setup:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\npoetry install\n</code></pre> <ol> <li>Run the CI pipeline:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre> <ol> <li>Generate manifests:</li> </ol> <pre><code>poetry run dagger-pipeline generate manifests/\n</code></pre> <ol> <li>Deploy to Kubernetes:</li> </ol> <pre><code>kubectl apply -f manifests/with-pvc.yaml\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the CLI Commands guide</li> <li>Explore Kustomize Overlays</li> <li>Check out Examples</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>dagger_pipeline<ul> <li>main</li> <li>pipeline</li> </ul> </li> </ul>"},{"location":"reference/dagger_pipeline/","title":"dagger_pipeline","text":""},{"location":"reference/dagger_pipeline/#dagger_pipeline","title":"<code>dagger_pipeline</code>","text":"<p>Dagger pipeline for CSS Kustomize project automation.</p> <p>This package provides comprehensive automation tools for Kubernetes manifest management using Kustomize, with containerized execution via Dagger for consistent and reproducible builds across different environments.</p>"},{"location":"reference/dagger_pipeline/#dagger_pipeline--key-features","title":"Key Features","text":"<ul> <li>YAML Linting: Comprehensive YAML syntax and style validation</li> <li>Python Code Quality: Automated linting and formatting with ruff</li> <li>Markdown Validation: Format checking and consistency enforcement</li> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Security Scanning: Kubernetes manifest security analysis</li> <li>Version Management: Automated version updates across overlays</li> <li>Parallel Execution: High-performance concurrent operations</li> </ul>"},{"location":"reference/dagger_pipeline/#dagger_pipeline--usage","title":"Usage","text":"<p>The package provides both a CLI interface and programmatic API:</p> <pre><code>from dagger_pipeline import Pipeline\n\n# Create pipeline instance\npipeline = Pipeline(verbose=True)\n\n# Run comprehensive linting\nawait pipeline.run_all_linting()\n\n# Generate manifests\nawait pipeline.generate_all_overlays(\"manifests\")\n</code></pre> <p>For CLI usage, see the <code>main</code> module documentation.</p>"},{"location":"reference/dagger_pipeline/main/","title":"main","text":""},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main","title":"<code>dagger_pipeline.main</code>","text":"<p>Main CLI entry point for Dagger pipeline automation.</p> <p>This module provides the command-line interface for the CSS Kustomize Dagger pipeline, offering comprehensive automation for linting, validation, manifest generation, and deployment workflows. The CLI is built using Click and provides rich console output for better user experience.</p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--pipeline-capabilities","title":"Pipeline Capabilities","text":"<ul> <li>YAML Linting: Comprehensive syntax and style validation with yamllint</li> <li>Python Code Quality: Automated checks and formatting with ruff</li> <li>Markdown Validation: Format checking and consistency enforcement</li> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Security Scanning: Kubernetes manifest security analysis</li> <li>Version Management: Automated version updates across overlays</li> <li>Parallel Execution: High-performance concurrent operations</li> </ul>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--usage-examples","title":"Usage Examples","text":"<p>Run the complete CI pipeline: <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre></p> <p>Run only YAML linting: <pre><code>poetry run dagger-pipeline lint --yaml-only\n</code></pre></p> <p>Generate manifests for all overlays: <pre><code>poetry run dagger-pipeline generate\n</code></pre></p> <p>Update version across all overlays: <pre><code>poetry run dagger-pipeline version update 1.2.3\n</code></pre></p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--cli-structure","title":"CLI Structure","text":"<p>The CLI is organized into command groups: - <code>lint</code>: Code quality and validation commands - <code>generate</code>: Manifest generation commands - <code>ci</code>: Complete CI pipeline execution - <code>version</code>: Version management commands - <code>setup</code>: Development environment setup</p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.build","title":"<code>build(verbose)</code>","text":"<p>Build documentation locally for testing.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef build(verbose: bool):\n    \"\"\"Build documentation locally for testing.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udfd7\ufe0f CSS Kustomize Documentation Build\", style=\"bold blue\"))\n\n    async def run_docs_build():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.build_docs()\n            console.print(\"\ud83c\udf89 Documentation built successfully!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation build failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_build())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.ci","title":"<code>ci(output_dir, verbose)</code>","text":"<p>Run complete CI pipeline (lint, validate, generate, security scan).</p> <p>This is the main CI command that executes the full pipeline workflow. It performs all quality checks, generates manifests, and runs security scans to ensure the project is ready for deployment.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory where generated manifests will be saved.        Defaults to 'manifests'.</p> required <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during execution.</p> required <p>The CI pipeline includes: 1. Comprehensive linting (YAML, Python, Markdown) 2. Kustomize configuration validation 3. Security scanning of configurations 4. Manifest generation for all overlays 5. Security scanning of generated manifests</p> <p>This command is designed to be run in CI/CD environments to ensure code quality and deployment readiness.</p> <p>Examples:</p> <p>Run complete CI pipeline:     $ poetry run dagger-pipeline ci</p> <p>Run with verbose output:     $ poetry run dagger-pipeline ci --verbose</p> <p>Generate to custom directory:     $ poetry run dagger-pipeline ci --output-dir ./build</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--output-dir\", default=\"manifests\", help=\"Output directory for generated manifests\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef ci(output_dir: str, verbose: bool):\n    \"\"\"Run complete CI pipeline (lint, validate, generate, security scan).\n\n    This is the main CI command that executes the full pipeline workflow.\n    It performs all quality checks, generates manifests, and runs security\n    scans to ensure the project is ready for deployment.\n\n    Args:\n        output_dir: Directory where generated manifests will be saved.\n                   Defaults to 'manifests'.\n        verbose: If True, enable detailed output during execution.\n\n    The CI pipeline includes:\n    1. Comprehensive linting (YAML, Python, Markdown)\n    2. Kustomize configuration validation\n    3. Security scanning of configurations\n    4. Manifest generation for all overlays\n    5. Security scanning of generated manifests\n\n    This command is designed to be run in CI/CD environments to ensure\n    code quality and deployment readiness.\n\n    Examples:\n        Run complete CI pipeline:\n            $ poetry run dagger-pipeline ci\n\n        Run with verbose output:\n            $ poetry run dagger-pipeline ci --verbose\n\n        Generate to custom directory:\n            $ poetry run dagger-pipeline ci --output-dir ./build\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83d\ude80 CSS Kustomize CI Pipeline\", style=\"bold blue\"))\n\n    async def run_ci():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            # Run all linting checks\n            await pipeline.run_all_linting()\n            console.print(\"\u2705 Linting completed\", style=\"green\")\n\n            # Generate all overlays\n            await pipeline.generate_all_overlays(output_dir)\n            console.print(\"\u2705 Manifest generation completed\", style=\"green\")\n\n            # Run security scan on generated manifests\n            await pipeline.security_scan_generated(output_dir)\n            console.print(\"\u2705 Security scan completed\", style=\"green\")\n\n            console.print(\"\ud83c\udf89 Complete CI pipeline passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c CI pipeline failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_ci())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.cli","title":"<code>cli()</code>","text":"<p>CSS Kustomize Dagger Pipeline - Comprehensive automation for linting, validation, and deployment.</p> <p>This CLI provides a comprehensive suite of tools for managing Kubernetes manifests using Kustomize, with automated linting, validation, and deployment capabilities powered by Dagger for containerized execution.</p> <p>The pipeline ensures code quality, security compliance, and consistent deployment practices across different environments and overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@click.group()\n@click.version_option()\ndef cli():\n    \"\"\"CSS Kustomize Dagger Pipeline - Comprehensive automation for linting, validation, and deployment.\n\n    This CLI provides a comprehensive suite of tools for managing Kubernetes manifests\n    using Kustomize, with automated linting, validation, and deployment capabilities\n    powered by Dagger for containerized execution.\n\n    The pipeline ensures code quality, security compliance, and consistent deployment\n    practices across different environments and overlays.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.delete_version","title":"<code>delete_version(version, verbose)</code>","text":"<p>Delete a specific documentation version.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.argument(\"version\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef delete_version(version: str, verbose: bool):\n    \"\"\"Delete a specific documentation version.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\uddd1\ufe0f CSS Kustomize Documentation Version Deletion\", style=\"bold blue\"))\n\n    async def run_delete_version():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.delete_doc_version(version)\n\n        except Exception as e:\n            console.print(f\"\u274c Failed to delete version: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_delete_version())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.deploy","title":"<code>deploy(version, alias, set_default, title, verbose)</code>","text":"<p>Deploy documentation with version management using mike.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--version\", help=\"Version to deploy (defaults to project version)\")\n@click.option(\"--alias\", default=\"latest\", help=\"Version alias (default: latest)\")\n@click.option(\"--set-default\", is_flag=True, help=\"Set this version as default\")\n@click.option(\"--title\", help=\"Version title for display (defaults to version)\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef deploy(version: str | None, alias: str, set_default: bool, title: str | None, verbose: bool):\n    \"\"\"Deploy documentation with version management using mike.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udcda CSS Kustomize Documentation Deployment\", style=\"bold blue\"))\n\n    async def run_docs_deploy():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.deploy_docs(version, alias, set_default, title)\n            console.print(\"\ud83c\udf89 Documentation deployed successfully!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation deployment failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_deploy())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.docs","title":"<code>docs()</code>","text":"<p>Documentation building and deployment commands.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.group()\ndef docs():\n    \"\"\"Documentation building and deployment commands.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.generate","title":"<code>generate(overlay, output_dir, verbose)</code>","text":"<p>Generate Kustomize manifests for overlays.</p> <p>This command uses Kustomize to build and generate Kubernetes manifests from the configured overlays. It can generate manifests for a specific overlay or all available overlays.</p> <p>Parameters:</p> Name Type Description Default <code>overlay</code> <code>str | None</code> <p>Name of specific overlay to generate (e.g., 'with-pvc', 'with-pvc').     If None, generates manifests for all overlays.</p> required <code>output_dir</code> <code>str</code> <p>Directory where generated manifests will be saved.        Defaults to 'manifests'.</p> required <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during generation.</p> required <p>The generated manifests include all Kubernetes resources defined in the base configuration and modified by the overlay-specific patches and configurations.</p> <p>Examples:</p> <p>Generate all overlays:     $ poetry run dagger-pipeline generate</p> <p>Generate specific overlay:     $ poetry run dagger-pipeline generate --overlay with-pvc</p> <p>Generate to custom directory:     $ poetry run dagger-pipeline generate --output-dir ./output</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--overlay\", help=\"Specific overlay to generate (e.g., with-pvc)\")\n@click.option(\"--output-dir\", default=\"manifests\", help=\"Output directory for generated manifests\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef generate(overlay: str | None, output_dir: str, verbose: bool):\n    \"\"\"Generate Kustomize manifests for overlays.\n\n    This command uses Kustomize to build and generate Kubernetes manifests\n    from the configured overlays. It can generate manifests for a specific\n    overlay or all available overlays.\n\n    Args:\n        overlay: Name of specific overlay to generate (e.g., 'with-pvc', 'with-pvc').\n                If None, generates manifests for all overlays.\n        output_dir: Directory where generated manifests will be saved.\n                   Defaults to 'manifests'.\n        verbose: If True, enable detailed output during generation.\n\n    The generated manifests include all Kubernetes resources defined in the\n    base configuration and modified by the overlay-specific patches and\n    configurations.\n\n    Examples:\n        Generate all overlays:\n            $ poetry run dagger-pipeline generate\n\n        Generate specific overlay:\n            $ poetry run dagger-pipeline generate --overlay with-pvc\n\n        Generate to custom directory:\n            $ poetry run dagger-pipeline generate --output-dir ./output\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udfd7\ufe0f CSS Kustomize Generation Pipeline\", style=\"bold blue\"))\n\n    async def run_generate():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if overlay:\n                await pipeline.generate_overlay(overlay, output_dir)\n            else:\n                await pipeline.generate_all_overlays(output_dir)\n\n            console.print(\"\ud83c\udf89 Manifest generation completed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Generation failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_generate())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.generate_parallel","title":"<code>generate_parallel(output_dir, verbose)</code>","text":"<p>Generate all Kustomize manifests in parallel for maximum speed.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--output-dir\", default=\"manifests\", help=\"Output directory for generated manifests\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef generate_parallel(output_dir: str, verbose: bool):\n    \"\"\"Generate all Kustomize manifests in parallel for maximum speed.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\ude80 CSS Kustomize Parallel Generation Pipeline\", style=\"bold blue\"))\n\n    async def run_generate_parallel():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.generate_all_overlays_parallel(output_dir)\n            console.print(\"\ud83c\udf89 Parallel manifest generation completed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Parallel generation failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_generate_parallel())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.lint","title":"<code>lint(yaml_only, python_only, kustomize_only, security_only, verbose)</code>","text":"<p>Run comprehensive linting and validation checks.</p> <p>This command performs various code quality and configuration validation checks on the project. By default, it runs all available linting checks, but can be configured to run specific checks only.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_only</code> <code>bool</code> <p>If True, run only YAML linting with yamllint</p> required <code>python_only</code> <code>bool</code> <p>If True, run only Python linting and formatting checks with ruff</p> required <code>kustomize_only</code> <code>bool</code> <p>If True, run only Kustomize configuration validation</p> required <code>security_only</code> <code>bool</code> <p>If True, run only security checks on Kubernetes manifests</p> required <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during execution</p> required <p>The linting includes: - YAML syntax and style validation - Python code quality checks (syntax, style, imports) - Python code formatting validation - Markdown formatting validation - Kustomize configuration validation - Security scanning of Kubernetes manifests</p> <p>Examples:</p> <p>Run all linting checks:     $ poetry run dagger-pipeline lint</p> <p>Run only YAML linting:     $ poetry run dagger-pipeline lint --yaml-only</p> <p>Run with verbose output:     $ poetry run dagger-pipeline lint --verbose</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--yaml-only\", is_flag=True, help=\"Run only YAML linting\")\n@click.option(\"--python-only\", is_flag=True, help=\"Run only Python linting and formatting\")\n@click.option(\"--kustomize-only\", is_flag=True, help=\"Run only Kustomize validation\")\n@click.option(\"--security-only\", is_flag=True, help=\"Run only security checks\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef lint(\n    yaml_only: bool,\n    python_only: bool,\n    kustomize_only: bool,\n    security_only: bool,\n    verbose: bool,\n):\n    \"\"\"Run comprehensive linting and validation checks.\n\n    This command performs various code quality and configuration validation checks\n    on the project. By default, it runs all available linting checks, but can be\n    configured to run specific checks only.\n\n    Args:\n        yaml_only: If True, run only YAML linting with yamllint\n        python_only: If True, run only Python linting and formatting checks with ruff\n        kustomize_only: If True, run only Kustomize configuration validation\n        security_only: If True, run only security checks on Kubernetes manifests\n        verbose: If True, enable detailed output during execution\n\n    The linting includes:\n    - YAML syntax and style validation\n    - Python code quality checks (syntax, style, imports)\n    - Python code formatting validation\n    - Markdown formatting validation\n    - Kustomize configuration validation\n    - Security scanning of Kubernetes manifests\n\n    Examples:\n        Run all linting checks:\n            $ poetry run dagger-pipeline lint\n\n        Run only YAML linting:\n            $ poetry run dagger-pipeline lint --yaml-only\n\n        Run with verbose output:\n            $ poetry run dagger-pipeline lint --verbose\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udd0d CSS Kustomize Linting Pipeline\", style=\"bold blue\"))\n\n    async def run_lint():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if yaml_only:\n                await pipeline.lint_yaml()\n            elif python_only:\n                await pipeline.lint_python()\n            elif kustomize_only:\n                await pipeline.validate_kustomize()\n            elif security_only:\n                await pipeline.security_scan()\n            else:\n                await pipeline.run_all_linting()\n\n            console.print(\"\ud83c\udf89 All linting checks passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Linting failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_lint())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.lint_parallel","title":"<code>lint_parallel(yaml_only, python_only, kustomize_only, security_only, verbose)</code>","text":"<p>Run linting checks in parallel for maximum speed (cached).</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--yaml-only\", is_flag=True, help=\"Run only YAML linting\")\n@click.option(\"--python-only\", is_flag=True, help=\"Run only Python linting\")\n@click.option(\"--kustomize-only\", is_flag=True, help=\"Run only Kustomize validation\")\n@click.option(\"--security-only\", is_flag=True, help=\"Run only security checks\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef lint_parallel(\n    yaml_only: bool,\n    python_only: bool,\n    kustomize_only: bool,\n    security_only: bool,\n    verbose: bool,\n):\n    \"\"\"Run linting checks in parallel for maximum speed (cached).\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\ude80 CSS Kustomize Parallel Linting Pipeline\", style=\"bold blue\"))\n\n    async def run_lint_parallel():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if yaml_only:\n                await pipeline.lint_yaml()\n            elif python_only:\n                await pipeline.lint_python()\n            elif kustomize_only:\n                await pipeline.validate_kustomize()\n            elif security_only:\n                await pipeline.security_scan()\n            else:\n                await pipeline.run_all_linting_parallel()\n\n            console.print(\"\ud83c\udf89 All parallel linting checks passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Parallel linting failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_lint_parallel())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.list_versions","title":"<code>list_versions(verbose)</code>","text":"<p>List all deployed documentation versions.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef list_versions(verbose: bool):\n    \"\"\"List all deployed documentation versions.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udccb CSS Kustomize Documentation Versions\", style=\"bold blue\"))\n\n    async def run_list_versions():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.list_doc_versions()\n\n        except Exception as e:\n            console.print(f\"\u274c Failed to list versions: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_list_versions())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.report","title":"<code>report(verbose)</code>","text":"<p>Generate version report showing current versions across overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef report(verbose: bool):\n    \"\"\"Generate version report showing current versions across overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udcca CSS Kustomize Version Report\", style=\"bold blue\"))\n\n    async def run_version_report():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.generate_version_report()\n\n        except Exception as e:\n            console.print(f\"\u274c Version report failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_report())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.serve","title":"<code>serve(port, verbose)</code>","text":"<p>Serve documentation locally for development.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--port\", default=8000, help=\"Port to serve documentation on\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef serve(port: int, verbose: bool):\n    \"\"\"Serve documentation locally for development.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udf10 CSS Kustomize Documentation Server\", style=\"bold blue\"))\n\n    async def run_docs_serve():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.serve_docs(port)\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation server failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_serve())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.setup","title":"<code>setup(verbose)</code>","text":"<p>Set up development environment and install dependencies.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef setup(verbose: bool):\n    \"\"\"Set up development environment and install dependencies.\"\"\"\n\n    console.print(Panel.fit(\"\u2699\ufe0f CSS Kustomize Setup\", style=\"bold blue\"))\n\n    async def run_setup():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.setup_environment()\n            console.print(\"\ud83c\udf89 Environment setup completed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Setup failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_setup())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.update","title":"<code>update(new_version, overlay, dry_run, verbose)</code>","text":"<p>Update image tags and version labels across overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.argument(\"new_version\")\n@click.option(\"--overlay\", help=\"Update specific overlay only (e.g., with-base, with-pvc)\")\n@click.option(\"--dry-run\", is_flag=True, help=\"Show what would be changed without making changes\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef update(new_version: str, overlay: str | None, dry_run: bool, verbose: bool):\n    \"\"\"Update image tags and version labels across overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udff7\ufe0f CSS Kustomize Version Update\", style=\"bold blue\"))\n\n    async def run_version_update():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if overlay:\n                await pipeline.update_overlay_version(overlay, new_version, dry_run)\n            else:\n                await pipeline.update_all_versions(new_version, dry_run)\n\n            if dry_run:\n                console.print(\"\ud83d\udd0d Dry run completed. No changes were made.\", style=\"bold yellow\")\n            else:\n                console.print(f\"\ud83c\udf89 Version updated to {new_version}!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Version update failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_update())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.validate","title":"<code>validate(verbose)</code>","text":"<p>Validate version consistency across all overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef validate(verbose: bool):\n    \"\"\"Validate version consistency across all overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udd0d CSS Kustomize Version Validation\", style=\"bold blue\"))\n\n    async def run_version_validate():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.validate_version_consistency()\n            console.print(\"\ud83c\udf89 Version validation passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Version validation failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_validate())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.version","title":"<code>version()</code>","text":"<p>Version management commands for image tags and labels.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.group()\ndef version():\n    \"\"\"Version management commands for image tags and labels.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/","title":"pipeline","text":""},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline","title":"<code>dagger_pipeline.pipeline</code>","text":"<p>Core Dagger pipeline implementation for CSS Kustomize automation.</p> <p>This module contains the Pipeline class which implements all the core functionality for the CSS Kustomize Dagger automation pipeline. It provides methods for linting, validation, manifest generation, security scanning, and version management.</p> <p>The pipeline uses Dagger for containerized execution, ensuring consistent and reproducible builds across different environments. All operations are performed in isolated containers with the necessary tools and dependencies.</p>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--key-features","title":"Key Features","text":"<ul> <li>YAML Linting: Comprehensive syntax and style validation with yamllint</li> <li>Python Code Quality: Automated checks and formatting with ruff</li> <li>Markdown Validation: Format checking and consistency enforcement</li> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Security Scanning: Kubernetes manifest security analysis</li> <li>Version Management: Automated version updates across overlays</li> <li>Parallel Execution: High-performance concurrent operations</li> <li>Rich Console Output: Progress indicators and detailed feedback</li> </ul>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--usage-example","title":"Usage Example","text":"<p>Basic usage of the Pipeline class:</p> <pre><code>pipeline = Pipeline(verbose=True)\nawait pipeline.run_all_linting()\nawait pipeline.generate_all_overlays(\"manifests\")\nawait pipeline.security_scan_generated(\"manifests\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--container-architecture","title":"Container Architecture","text":"<p>The pipeline uses specialized containers for different operations: - Python Container: Poetry-based environment for Python and Markdown linting - Kustomize Container: Alpine-based environment with Kustomize CLI - YAML Container: Alpine-based environment with yq for YAML processing</p>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>Main pipeline class for CSS Kustomize automation.</p> <p>This class orchestrates all pipeline operations including linting, validation, manifest generation, and security scanning. It uses Dagger for containerized execution to ensure consistent and reproducible builds.</p> <p>Attributes:</p> Name Type Description <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output during operations.</p> <code>project_root</code> <code>Path</code> <p>Path to the project root directory.</p> <p>The pipeline supports both sequential and parallel execution modes for different operations, with automatic caching through Dagger to improve performance on subsequent runs.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>class Pipeline:\n    \"\"\"Main pipeline class for CSS Kustomize automation.\n\n    This class orchestrates all pipeline operations including linting, validation,\n    manifest generation, and security scanning. It uses Dagger for containerized\n    execution to ensure consistent and reproducible builds.\n\n    Attributes:\n        verbose (bool): Whether to enable verbose output during operations.\n        project_root (Path): Path to the project root directory.\n\n    The pipeline supports both sequential and parallel execution modes for\n    different operations, with automatic caching through Dagger to improve\n    performance on subsequent runs.\n    \"\"\"\n\n    def __init__(self, verbose: bool = False):\n        \"\"\"Initialize the Pipeline instance.\n\n        Args:\n            verbose: If True, enables detailed output during pipeline execution.\n                    This includes container build logs, command outputs, and\n                    detailed progress information.\n        \"\"\"\n        self.verbose = verbose\n        self.project_root = Path.cwd()\n\n    def _get_client(self) -&gt; dagger.Connection:\n        \"\"\"Get Dagger client connection.\n\n        Creates and configures a Dagger client connection for containerized execution.\n        If verbose mode is enabled, configures the client to output detailed logs.\n\n        Returns:\n            dagger.Connection: Configured Dagger client connection.\n        \"\"\"\n        config = dagger.Config()\n        if self.verbose:\n            config = dagger.Config(log_output=console.file)\n        return dagger.Connection(config)\n\n    async def _get_python_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get Python container with Poetry and dependencies installed.\n\n        Creates a containerized Python environment with Poetry package manager\n        and installs the project's linting dependencies. This container is used\n        for all Python-related operations including linting, formatting, and\n        markdown validation.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Python container with Poetry and lint dependencies.\n\n        The container includes:\n        - Python 3.11 slim base image\n        - System packages: curl, git\n        - Poetry package manager\n        - Project source code mounted at /src\n        - Lint dependencies installed via Poetry\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"python:3.11-slim\")\n            .with_exec([\"apt-get\", \"update\"])\n            .with_exec([\"apt-get\", \"install\", \"-y\", \"curl\", \"git\"])\n            .with_exec([\"pip\", \"install\", \"poetry\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n            .with_exec([\"poetry\", \"config\", \"virtualenvs.create\", \"false\"])\n            .with_exec([\"poetry\", \"install\", \"--only=lint\"])\n        )\n\n    async def _get_kustomize_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get container with Kustomize installed.\n\n        Creates a containerized environment with Kustomize CLI tool for building\n        and validating Kubernetes manifests. This container is used for all\n        Kustomize-related operations including validation and manifest generation.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Alpine container with Kustomize installed.\n\n        The container includes:\n        - Alpine Linux base image\n        - System packages: curl, bash\n        - Latest Kustomize CLI tool\n        - Project source code mounted at /src\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"alpine:latest\")\n            .with_exec([\"apk\", \"add\", \"--no-cache\", \"curl\", \"bash\"])\n            .with_exec(\n                [\n                    \"sh\",\n                    \"-c\",\n                    \"curl -s https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh | bash\",  # noqa: E501\n                ]\n            )\n            .with_exec([\"mv\", \"kustomize\", \"/usr/local/bin/\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n        )\n\n    async def lint_yaml(self) -&gt; None:\n        \"\"\"Run YAML linting using yamllint.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running YAML linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            result = await container.with_exec([\"poetry\", \"run\", \"yamllint\", \".\"]).stdout()\n\n            if self.verbose:\n                console.print(result)\n\n            console.print(\"\u2705 YAML linting passed\", style=\"green\")\n\n    async def lint_python(self) -&gt; None:\n        \"\"\"Run Python linting and formatting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running Python linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            # Run ruff check\n            await container.with_exec([\"poetry\", \"run\", \"ruff\", \"check\", \".\"]).stdout()\n\n            # Run ruff format check\n            await container.with_exec([\"poetry\", \"run\", \"ruff\", \"format\", \"--check\", \".\"]).stdout()\n\n            console.print(\"\u2705 Python linting passed\", style=\"green\")\n\n    async def lint_markdown(self) -&gt; None:\n        \"\"\"Run Markdown linting and formatting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running Markdown linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            # Check if there are any markdown files to lint\n            try:\n                # Find markdown files\n                md_files_result = await container.with_exec(\n                    [\n                        \"find\",\n                        \".\",\n                        \"-name\",\n                        \"*.md\",\n                        \"-type\",\n                        \"f\",\n                        \"!\",\n                        \"-path\",\n                        \"./.venv/*\",\n                        \"!\",\n                        \"-path\",\n                        \"./node_modules/*\",\n                    ]\n                ).stdout()\n\n                md_files = [f.strip() for f in md_files_result.strip().split(\"\\n\") if f.strip()]\n\n                if not md_files:\n                    console.print(\"\ud83d\udcdd No markdown files found to lint\", style=\"yellow\")\n                    return\n\n                if self.verbose:\n                    console.print(f\"Found {len(md_files)} markdown files to check\")\n\n                # Run mdformat check (dry-run to validate formatting)\n                await container.with_exec([\"poetry\", \"run\", \"mdformat\", \"--check\"] + md_files).stdout()\n\n                console.print(\"\u2705 Markdown linting passed\", style=\"green\")\n\n            except Exception as e:\n                console.print(f\"\u274c Markdown formatting issues found: {str(e)}\", style=\"red\")\n                raise Exception(\"Markdown files need formatting. Run 'poetry run mdformat .' to fix.\") from e\n\n    async def validate_kustomize(self) -&gt; None:\n        \"\"\"Validate Kustomize configurations.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Validating Kustomize configurations...\")\n\n        async with self._get_client() as client:\n            container = await self._get_kustomize_container(client)\n\n            # Validate base configuration\n            await container.with_exec([\"kustomize\", \"build\", \"base/\"]).stdout()\n\n            # Validate overlays\n            overlays_dir = self.project_root / \"overlays\"\n            if overlays_dir.exists():\n                for overlay_path in overlays_dir.iterdir():\n                    if overlay_path.is_dir():\n                        overlay_name = overlay_path.name\n                        if self.verbose:\n                            console.print(f\"Validating overlay: {overlay_name}\")\n\n                        await container.with_exec([\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]).stdout()\n\n            console.print(\"\u2705 Kustomize validation passed\", style=\"green\")\n\n    async def security_scan(self) -&gt; None:\n        \"\"\"Run security checks on Kustomize configurations.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running security scan...\")\n\n        async with self._get_client() as client:\n            container = await self._get_kustomize_container(client)\n\n            # Generate manifests for security scanning\n            overlays_dir = self.project_root / \"overlays\"\n            security_issues = 0\n\n            if overlays_dir.exists():\n                for overlay_path in overlays_dir.iterdir():\n                    if overlay_path.is_dir():\n                        overlay_name = overlay_path.name\n                        if self.verbose:\n                            console.print(f\"Scanning overlay: {overlay_name}\")\n\n                        # Generate manifest\n                        manifest_content = await container.with_exec(\n                            [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n                        ).stdout()\n\n                        # Check for security issues\n                        issues = self._check_security_issues(manifest_content, overlay_name)\n                        security_issues += issues\n\n            if security_issues &gt; 0:\n                raise Exception(f\"Found {security_issues} security issues\")\n\n            console.print(\"\u2705 Security scan passed\", style=\"green\")\n\n    async def security_scan_generated(self, output_dir: str) -&gt; None:\n        \"\"\"Run security checks on generated manifests.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running security scan on generated manifests...\")\n\n        manifests_dir = Path(output_dir)\n        if not manifests_dir.exists():\n            raise Exception(f\"Manifests directory {output_dir} does not exist\")\n\n        security_issues = 0\n        for manifest_file in manifests_dir.glob(\"*.yaml\"):\n            if self.verbose:\n                console.print(f\"Scanning manifest: {manifest_file.name}\")\n\n            content = manifest_file.read_text()\n            issues = self._check_security_issues(content, manifest_file.name)\n            security_issues += issues\n\n        if security_issues &gt; 0:\n            raise Exception(f\"Found {security_issues} security issues in generated manifests\")\n\n        console.print(\"\u2705 Security scan on generated manifests passed\", style=\"green\")\n\n    def _check_security_issues(self, manifest_content: str, name: str) -&gt; int:\n        \"\"\"Check for security issues in manifest content.\"\"\"\n        issues = 0\n\n        # Check for root user\n        if re.search(r\"runAsUser:\\s*0\\b\", manifest_content):\n            console.print(f\"\u274c Found root user in {name}\", style=\"red\")\n            issues += 1\n\n        # Check for runAsNonRoot\n        if not re.search(r\"runAsNonRoot.*true\", manifest_content):\n            console.print(f\"\u26a0\ufe0f runAsNonRoot not found in {name}\", style=\"yellow\")\n\n        # Check for privileged containers\n        if re.search(r\"privileged.*true\", manifest_content):\n            console.print(f\"\u274c Found privileged container in {name}\", style=\"red\")\n            issues += 1\n\n        return issues\n\n    async def generate_overlay(self, overlay_name: str, output_dir: str) -&gt; None:\n        \"\"\"Generate manifest for a specific overlay.\"\"\"\n        if self.verbose:\n            console.print(f\"\ud83c\udfd7\ufe0f Generating overlay: {overlay_name}\")\n\n        overlay_path = self.project_root / \"overlays\" / overlay_name\n        if not overlay_path.exists():\n            raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n        async with self._get_client() as client:\n            container = await self._get_kustomize_container(client)\n\n            # Generate manifest\n            manifest_content = await container.with_exec([\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]).stdout()\n\n            # Write to output directory\n            output_path = Path(output_dir)\n            output_path.mkdir(exist_ok=True)\n\n            manifest_file = output_path / f\"{overlay_name}.yaml\"\n            manifest_file.write_text(manifest_content)\n\n            if self.verbose:\n                console.print(f\"Generated manifest: {manifest_file}\")\n\n    async def generate_all_overlays(self, output_dir: str) -&gt; None:\n        \"\"\"Generate manifests for all overlays.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83c\udfd7\ufe0f Generating all overlays...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                await self.generate_overlay(overlay_path.name, output_dir)\n\n        console.print(\"\u2705 All overlays generated\", style=\"green\")\n\n    async def run_all_linting(self) -&gt; None:\n        \"\"\"Run all linting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running comprehensive linting...\")\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            task1 = progress.add_task(\"YAML linting...\", total=None)\n            await self.lint_yaml()\n            progress.update(task1, completed=True)\n\n            task2 = progress.add_task(\"Python linting...\", total=None)\n            await self.lint_python()\n            progress.update(task2, completed=True)\n\n            task3 = progress.add_task(\"Markdown linting...\", total=None)\n            await self.lint_markdown()\n            progress.update(task3, completed=True)\n\n            task4 = progress.add_task(\"Kustomize validation...\", total=None)\n            await self.validate_kustomize()\n            progress.update(task4, completed=True)\n\n            task5 = progress.add_task(\"Security scan...\", total=None)\n            await self.security_scan()\n            progress.update(task5, completed=True)\n\n        console.print(\"\u2705 All linting checks completed\", style=\"green\")\n\n    async def setup_environment(self) -&gt; None:\n        \"\"\"Set up development environment.\"\"\"\n        if self.verbose:\n            console.print(\"\u2699\ufe0f Setting up development environment...\")\n\n        async with self._get_client() as client:\n            # Install Python dependencies\n            container = await self._get_python_container(client)\n\n            # Install pre-commit hooks\n            await container.with_exec([\"poetry\", \"run\", \"pre-commit\", \"install\"]).stdout()\n\n            console.print(\"\u2705 Development environment setup completed\", style=\"green\")\n\n    async def run_pre_commit(self) -&gt; None:\n        \"\"\"Run pre-commit hooks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running pre-commit hooks...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            await container.with_exec([\"poetry\", \"run\", \"pre-commit\", \"run\", \"--all-files\"]).stdout()\n\n            console.print(\"\u2705 Pre-commit hooks passed\", style=\"green\")\n\n    async def _get_yaml_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get container with yq for YAML processing.\"\"\"\n        return (\n            client.container()\n            .from_(\"alpine:latest\")\n            .with_exec([\"apk\", \"add\", \"--no-cache\", \"curl\", \"bash\"])\n            .with_exec(\n                [\n                    \"sh\",\n                    \"-c\",\n                    \"curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq &amp;&amp; chmod +x /usr/local/bin/yq\",\n                ]\n            )\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n        )\n\n    def _validate_version_format(self, version: str) -&gt; bool:\n        \"\"\"Validate semantic version format.\"\"\"\n        import re\n\n        pattern = r\"^[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9.-]+)?$\"\n        return bool(re.match(pattern, version))\n\n    async def update_overlay_version(self, overlay_name: str, version: str, dry_run: bool = False) -&gt; None:\n        \"\"\"Update version for a specific overlay.\"\"\"\n        if not self._validate_version_format(version):\n            raise Exception(f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\")\n\n        overlay_path = self.project_root / \"overlays\" / overlay_name\n        if not overlay_path.exists():\n            raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n        kustomization_file = overlay_path / \"kustomization.yaml\"\n        if not kustomization_file.exists():\n            raise Exception(f\"Kustomization file not found: {kustomization_file}\")\n\n        if self.verbose:\n            console.print(f\"\ud83c\udff7\ufe0f Processing overlay: {overlay_name}\")\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n\n            # Read current values for dry run\n            if dry_run:\n                current_tag_result = await container.with_exec(\n                    [\n                        \"yq\",\n                        '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                current_tag = current_tag_result.strip() if current_tag_result.strip() != \"null\" else \"not set\"\n\n                current_version_result = await container.with_exec(\n                    [\n                        \"yq\",\n                        '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                current_version = (\n                    current_version_result.strip() if current_version_result.strip() != \"null\" else \"not set\"\n                )\n\n                console.print(f\"  [DRY RUN] Would update image tag from '{current_tag}' to '{version}'\")\n                console.print(f\"  [DRY RUN] Would update version label from '{current_version}' to '{version}'\")\n                return\n\n            # Update image tag\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'.images[] |= select(.name == \"docker.io/solidproject/community-server\").newTag = \"{version}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            # Update version label\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'.labels[0].pairs.\"app.kubernetes.io/version\" = \"{version}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            # Update version patch if it exists\n            patch_check = await container.with_exec(\n                [\n                    \"yq\",\n                    '.patches[] | select(.target.kind == \"Deployment\") | .patch',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            if \"app.kubernetes.io~1version\" in patch_check:\n                await container.with_exec(\n                    [\n                        \"yq\",\n                        \"-i\",\n                        f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) |= sub(\"value: \\\\\"[^\\\\\"]*\\\\\"\"; \"value: \\\\\"{version}\\\\\"\"; \"g\")',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                console.print(f\"  \u2705 Updated deployment version patch to: {version}\")\n            else:\n                # Add version patch if it doesn't exist\n                patch_content = f'      - op: add\\\\n        path: /spec/template/metadata/labels/app.kubernetes.io~1version\\\\n        value: \\\\\"{version}\\\\\"'\n                await container.with_exec(\n                    [\n                        \"yq\",\n                        \"-i\",\n                        f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) += \"\\\\n{patch_content}\"',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                console.print(f\"  \u2705 Added deployment version patch: {version}\")\n\n            # Copy updated file back to host\n            updated_content = await container.file(f\"overlays/{overlay_name}/kustomization.yaml\").contents()\n            kustomization_file.write_text(updated_content)\n\n            console.print(f\"  \u2705 Updated image tag to: {version}\")\n            console.print(f\"  \u2705 Updated version label to: {version}\")\n\n    async def update_all_versions(self, version: str, dry_run: bool = False) -&gt; None:\n        \"\"\"Update version for all overlays.\"\"\"\n        if not self._validate_version_format(version):\n            raise Exception(f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n        if not overlay_names:\n            console.print(\"No overlays found to update\", style=\"yellow\")\n            return\n\n        for overlay_name in overlay_names:\n            await self.update_overlay_version(overlay_name, version, dry_run)\n\n        if not dry_run:\n            console.print(f\"\u2705 Updated {len(overlay_names)} overlays to version: {version}\")\n\n    async def validate_version_consistency(self) -&gt; None:\n        \"\"\"Validate version consistency across all overlays.\n\n        This validates that:\n        - Image tags are present and valid (CSS application version)\n        - Version labels are present and valid (project version from pyproject.toml)\n        - Both are consistently applied across all overlays\n\n        Note: Image tags and version labels are intentionally independent -\n        image tags represent the CSS application version while version labels\n        represent the project/tooling version.\n        \"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Validating version consistency...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        # Get expected project version from pyproject.toml\n        expected_project_version = await self._get_project_version()\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n            issues = []\n\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                    # Get image tag\n                    try:\n                        image_tag_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        image_tag = image_tag_result.strip() if image_tag_result.strip() != \"null\" else None\n                    except:\n                        image_tag = None\n\n                    # Get version label\n                    try:\n                        version_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        version_label = version_label_result.strip() if version_label_result.strip() != \"null\" else None\n                    except:\n                        version_label = None\n\n                    # Validate image tag presence\n                    if not image_tag:\n                        issues.append(f\"{overlay_name}: missing image tag\")\n                    elif not self._validate_version_format(image_tag):\n                        issues.append(f\"{overlay_name}: invalid image tag format '{image_tag}'\")\n\n                    # Validate version label presence and consistency with project version\n                    if not version_label:\n                        issues.append(f\"{overlay_name}: missing version label\")\n                    elif version_label != expected_project_version:\n                        issues.append(\n                            f\"{overlay_name}: version label '{version_label}' != project version '{expected_project_version}'\"\n                        )\n\n            if issues:\n                console.print(\"\u274c Version consistency issues found:\", style=\"red\")\n                for issue in issues:\n                    console.print(f\"  \u2022 {issue}\", style=\"red\")\n                raise Exception(f\"Found {len(issues)} version consistency issues\")\n\n            console.print(\"\u2705 Version consistency validation passed\", style=\"green\")\n\n    async def generate_version_report(self) -&gt; None:\n        \"\"\"Generate a report of current versions across all overlays.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udcca Generating version report...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n\n            console.print(\"\\n\ud83d\udccb Version Report\", style=\"bold blue\")\n            console.print(\"=\" * 50)\n\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                    # Get image tag\n                    try:\n                        image_tag_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        image_tag = image_tag_result.strip() if image_tag_result.strip() != \"null\" else \"not set\"\n                    except:\n                        image_tag = \"not set\"\n\n                    # Get version label\n                    try:\n                        version_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        version_label = (\n                            version_label_result.strip() if version_label_result.strip() != \"null\" else \"not set\"\n                        )\n                    except:\n                        version_label = \"not set\"\n\n                    # Get instance label for context\n                    try:\n                        instance_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/instance\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        instance_label = (\n                            instance_label_result.strip() if instance_label_result.strip() != \"null\" else \"not set\"\n                        )\n                    except:\n                        instance_label = \"not set\"\n\n                    # Display overlay info\n                    console.print(f\"\\n\ud83c\udff7\ufe0f Overlay: {overlay_name}\", style=\"bold\")\n                    console.print(f\"   Instance: {instance_label}\")\n                    console.print(f\"   Image Tag: {image_tag}\")\n                    console.print(f\"   Version Label: {version_label}\")\n\n                    # Check completeness (both should be present but independent)\n                    if image_tag != \"not set\" and version_label != \"not set\":\n                        console.print(\"   Status: \u2705 Complete\", style=\"green\")\n                    else:\n                        missing = []\n                        if image_tag == \"not set\":\n                            missing.append(\"image tag\")\n                        if version_label == \"not set\":\n                            missing.append(\"version label\")\n                        console.print(f\"   Status: \u26a0\ufe0f Missing {', '.join(missing)}\", style=\"yellow\")\n\n            console.print(\"\\n\" + \"=\" * 50)\n            console.print(\"\ud83d\udcca Report completed\", style=\"bold blue\")\n\n    async def run_all_linting_parallel(self) -&gt; None:\n        \"\"\"Run all linting checks in parallel for maximum speed.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running comprehensive linting in parallel...\")\n\n        import asyncio\n\n        # Run all linting tasks in parallel\n        tasks = [\n            self.lint_yaml(),\n            self.lint_python(),\n            self.lint_markdown(),\n            self.validate_kustomize(),\n            self.security_scan(),\n        ]\n\n        try:\n            await asyncio.gather(*tasks)\n            console.print(\"\u2705 All parallel linting checks completed\", style=\"green\")\n        except Exception as e:\n            console.print(f\"\u274c Parallel linting failed: {e}\", style=\"red\")\n            raise\n\n    async def generate_all_overlays_parallel(self, output_dir: str) -&gt; None:\n        \"\"\"Generate manifests for all overlays in parallel for maximum speed.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83c\udfd7\ufe0f Generating all overlays in parallel...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        import asyncio\n\n        # Get all overlay names\n        overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n        if not overlay_names:\n            console.print(\"No overlays found to generate\", style=\"yellow\")\n            return\n\n        # Generate all overlays in parallel\n        tasks = [self.generate_overlay(overlay_name, output_dir) for overlay_name in overlay_names]\n\n        try:\n            await asyncio.gather(*tasks)\n            console.print(\"\u2705 All overlays generated in parallel\", style=\"green\")\n        except Exception as e:\n            console.print(f\"\u274c Parallel generation failed: {e}\", style=\"red\")\n            raise\n\n    async def _get_docs_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get Python container with documentation dependencies installed.\n\n        Creates a containerized Python environment with Poetry package manager\n        and installs the project's documentation dependencies including MkDocs,\n        mike, and related tools.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Python container with docs dependencies.\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"python:3.11-slim\")\n            .with_exec([\"apt-get\", \"update\"])\n            .with_exec([\"apt-get\", \"install\", \"-y\", \"curl\", \"git\"])\n            .with_exec([\"pip\", \"install\", \"poetry\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n            .with_exec([\"poetry\", \"config\", \"virtualenvs.create\", \"false\"])\n            .with_exec([\"poetry\", \"install\", \"--with=docs\"])\n        )\n\n    async def _get_project_version(self) -&gt; str:\n        \"\"\"Get the current project version from pyproject.toml.\"\"\"\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n            version_result = await container.with_exec([\"poetry\", \"version\", \"--short\"]).stdout()\n            return version_result.strip()\n\n    async def build_docs(self) -&gt; None:\n        \"\"\"Build documentation locally using MkDocs.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83c\udfd7\ufe0f Building documentation...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            # Build documentation\n            await container.with_exec([\"poetry\", \"run\", \"mkdocs\", \"build\", \"--strict\"]).stdout()\n\n            # Copy built site back to host\n            site_dir = self.project_root / \"site\"\n            site_dir.mkdir(exist_ok=True)\n\n            # Export the built site\n            built_site = container.directory(\"site\")\n            await built_site.export(str(site_dir))\n\n            console.print(\"\u2705 Documentation built successfully\", style=\"green\")\n            console.print(f\"\ud83d\udcc1 Built site available at: {site_dir}\")\n\n    async def serve_docs(self, port: int = 8000) -&gt; None:\n        \"\"\"Serve documentation locally for development.\"\"\"\n        if self.verbose:\n            console.print(f\"\ud83c\udf10 Starting documentation server on port {port}...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            console.print(f\"\ud83d\udcda Documentation server starting at http://localhost:{port}\")\n            console.print(\"Press Ctrl+C to stop the server\")\n\n            # Serve documentation (this will run until interrupted)\n            await container.with_exec([\"poetry\", \"run\", \"mkdocs\", \"serve\", \"--dev-addr\", f\"0.0.0.0:{port}\"]).stdout()\n\n    async def deploy_docs(\n        self,\n        version: str | None = None,\n        alias: str = \"latest\",\n        set_default: bool = False,\n        title: str | None = None,\n    ) -&gt; None:\n        \"\"\"Deploy documentation with version management using mike.\n\n        Args:\n            version: Version to deploy. If None, uses project version from pyproject.toml\n            alias: Version alias (default: \"latest\")\n            set_default: Whether to set this version as the default\n            title: Version title for display. If None, uses version as title\n        \"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udcda Deploying documentation with mike...\")\n\n        # Get version if not provided\n        if version is None:\n            version = await self._get_project_version()\n            if self.verbose:\n                console.print(f\"Using project version: {version}\")\n\n        # Use version as title if not provided\n        if title is None:\n            title = version\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            # Configure git for mike\n            container = container.with_exec([\"git\", \"config\", \"user.name\", \"dagger-pipeline\"]).with_exec(\n                [\"git\", \"config\", \"user.email\", \"pipeline@css-kustomize.local\"]\n            )\n\n            # Deploy with mike using explicit title\n            deploy_cmd = [\n                \"poetry\",\n                \"run\",\n                \"mike\",\n                \"deploy\",\n                \"--update-aliases\",\n                \"--title\",\n                title,\n                version,\n                alias,\n            ]\n\n            if self.verbose:\n                console.print(f\"Deploying version {version} (title: {title}) with alias {alias}\")\n\n            await container.with_exec(deploy_cmd).stdout()\n\n            # Set as default if requested\n            if set_default:\n                if self.verbose:\n                    console.print(f\"Setting {alias} as default version\")\n\n                await container.with_exec([\"poetry\", \"run\", \"mike\", \"set-default\", alias]).stdout()\n\n            console.print(f\"\u2705 Documentation deployed: {version} ({alias})\", style=\"green\")\n\n    async def list_doc_versions(self) -&gt; None:\n        \"\"\"List all deployed documentation versions.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udccb Listing documentation versions...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            try:\n                versions_result = await container.with_exec([\"poetry\", \"run\", \"mike\", \"list\"]).stdout()\n\n                console.print(\"\\n\ud83d\udcda Deployed Documentation Versions:\", style=\"bold blue\")\n                console.print(\"=\" * 40)\n                console.print(versions_result)\n                console.print(\"=\" * 40)\n\n            except Exception as e:\n                console.print(\n                    \"No versions deployed yet or git repository not initialized\",\n                    style=\"yellow\",\n                )\n                if self.verbose:\n                    console.print(f\"Error: {e}\", style=\"red\")\n\n    async def delete_doc_version(self, version: str) -&gt; None:\n        \"\"\"Delete a specific documentation version.\n\n        Args:\n            version: Version to delete\n        \"\"\"\n        if self.verbose:\n            console.print(f\"\ud83d\uddd1\ufe0f Deleting documentation version: {version}\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            await container.with_exec([\"poetry\", \"run\", \"mike\", \"delete\", version]).stdout()\n\n            console.print(f\"\u2705 Deleted documentation version: {version}\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>Initialize the Pipeline instance.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, enables detailed output during pipeline execution.     This includes container build logs, command outputs, and     detailed progress information.</p> <code>False</code> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>def __init__(self, verbose: bool = False):\n    \"\"\"Initialize the Pipeline instance.\n\n    Args:\n        verbose: If True, enables detailed output during pipeline execution.\n                This includes container build logs, command outputs, and\n                detailed progress information.\n    \"\"\"\n    self.verbose = verbose\n    self.project_root = Path.cwd()\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.build_docs","title":"<code>build_docs()</code>  <code>async</code>","text":"<p>Build documentation locally using MkDocs.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def build_docs(self) -&gt; None:\n    \"\"\"Build documentation locally using MkDocs.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83c\udfd7\ufe0f Building documentation...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        # Build documentation\n        await container.with_exec([\"poetry\", \"run\", \"mkdocs\", \"build\", \"--strict\"]).stdout()\n\n        # Copy built site back to host\n        site_dir = self.project_root / \"site\"\n        site_dir.mkdir(exist_ok=True)\n\n        # Export the built site\n        built_site = container.directory(\"site\")\n        await built_site.export(str(site_dir))\n\n        console.print(\"\u2705 Documentation built successfully\", style=\"green\")\n        console.print(f\"\ud83d\udcc1 Built site available at: {site_dir}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.delete_doc_version","title":"<code>delete_doc_version(version)</code>  <code>async</code>","text":"<p>Delete a specific documentation version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Version to delete</p> required Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def delete_doc_version(self, version: str) -&gt; None:\n    \"\"\"Delete a specific documentation version.\n\n    Args:\n        version: Version to delete\n    \"\"\"\n    if self.verbose:\n        console.print(f\"\ud83d\uddd1\ufe0f Deleting documentation version: {version}\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        await container.with_exec([\"poetry\", \"run\", \"mike\", \"delete\", version]).stdout()\n\n        console.print(f\"\u2705 Deleted documentation version: {version}\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.deploy_docs","title":"<code>deploy_docs(version=None, alias='latest', set_default=False, title=None)</code>  <code>async</code>","text":"<p>Deploy documentation with version management using mike.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>Version to deploy. If None, uses project version from pyproject.toml</p> <code>None</code> <code>alias</code> <code>str</code> <p>Version alias (default: \"latest\")</p> <code>'latest'</code> <code>set_default</code> <code>bool</code> <p>Whether to set this version as the default</p> <code>False</code> <code>title</code> <code>str | None</code> <p>Version title for display. If None, uses version as title</p> <code>None</code> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def deploy_docs(\n    self,\n    version: str | None = None,\n    alias: str = \"latest\",\n    set_default: bool = False,\n    title: str | None = None,\n) -&gt; None:\n    \"\"\"Deploy documentation with version management using mike.\n\n    Args:\n        version: Version to deploy. If None, uses project version from pyproject.toml\n        alias: Version alias (default: \"latest\")\n        set_default: Whether to set this version as the default\n        title: Version title for display. If None, uses version as title\n    \"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udcda Deploying documentation with mike...\")\n\n    # Get version if not provided\n    if version is None:\n        version = await self._get_project_version()\n        if self.verbose:\n            console.print(f\"Using project version: {version}\")\n\n    # Use version as title if not provided\n    if title is None:\n        title = version\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        # Configure git for mike\n        container = container.with_exec([\"git\", \"config\", \"user.name\", \"dagger-pipeline\"]).with_exec(\n            [\"git\", \"config\", \"user.email\", \"pipeline@css-kustomize.local\"]\n        )\n\n        # Deploy with mike using explicit title\n        deploy_cmd = [\n            \"poetry\",\n            \"run\",\n            \"mike\",\n            \"deploy\",\n            \"--update-aliases\",\n            \"--title\",\n            title,\n            version,\n            alias,\n        ]\n\n        if self.verbose:\n            console.print(f\"Deploying version {version} (title: {title}) with alias {alias}\")\n\n        await container.with_exec(deploy_cmd).stdout()\n\n        # Set as default if requested\n        if set_default:\n            if self.verbose:\n                console.print(f\"Setting {alias} as default version\")\n\n            await container.with_exec([\"poetry\", \"run\", \"mike\", \"set-default\", alias]).stdout()\n\n        console.print(f\"\u2705 Documentation deployed: {version} ({alias})\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_all_overlays","title":"<code>generate_all_overlays(output_dir)</code>  <code>async</code>","text":"<p>Generate manifests for all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_all_overlays(self, output_dir: str) -&gt; None:\n    \"\"\"Generate manifests for all overlays.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83c\udfd7\ufe0f Generating all overlays...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    for overlay_path in overlays_dir.iterdir():\n        if overlay_path.is_dir():\n            await self.generate_overlay(overlay_path.name, output_dir)\n\n    console.print(\"\u2705 All overlays generated\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_all_overlays_parallel","title":"<code>generate_all_overlays_parallel(output_dir)</code>  <code>async</code>","text":"<p>Generate manifests for all overlays in parallel for maximum speed.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_all_overlays_parallel(self, output_dir: str) -&gt; None:\n    \"\"\"Generate manifests for all overlays in parallel for maximum speed.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83c\udfd7\ufe0f Generating all overlays in parallel...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    import asyncio\n\n    # Get all overlay names\n    overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n    if not overlay_names:\n        console.print(\"No overlays found to generate\", style=\"yellow\")\n        return\n\n    # Generate all overlays in parallel\n    tasks = [self.generate_overlay(overlay_name, output_dir) for overlay_name in overlay_names]\n\n    try:\n        await asyncio.gather(*tasks)\n        console.print(\"\u2705 All overlays generated in parallel\", style=\"green\")\n    except Exception as e:\n        console.print(f\"\u274c Parallel generation failed: {e}\", style=\"red\")\n        raise\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_overlay","title":"<code>generate_overlay(overlay_name, output_dir)</code>  <code>async</code>","text":"<p>Generate manifest for a specific overlay.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_overlay(self, overlay_name: str, output_dir: str) -&gt; None:\n    \"\"\"Generate manifest for a specific overlay.\"\"\"\n    if self.verbose:\n        console.print(f\"\ud83c\udfd7\ufe0f Generating overlay: {overlay_name}\")\n\n    overlay_path = self.project_root / \"overlays\" / overlay_name\n    if not overlay_path.exists():\n        raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n    async with self._get_client() as client:\n        container = await self._get_kustomize_container(client)\n\n        # Generate manifest\n        manifest_content = await container.with_exec([\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]).stdout()\n\n        # Write to output directory\n        output_path = Path(output_dir)\n        output_path.mkdir(exist_ok=True)\n\n        manifest_file = output_path / f\"{overlay_name}.yaml\"\n        manifest_file.write_text(manifest_content)\n\n        if self.verbose:\n            console.print(f\"Generated manifest: {manifest_file}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_version_report","title":"<code>generate_version_report()</code>  <code>async</code>","text":"<p>Generate a report of current versions across all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_version_report(self) -&gt; None:\n    \"\"\"Generate a report of current versions across all overlays.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udcca Generating version report...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n\n        console.print(\"\\n\ud83d\udccb Version Report\", style=\"bold blue\")\n        console.print(\"=\" * 50)\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                overlay_name = overlay_path.name\n                kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                # Get image tag\n                try:\n                    image_tag_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    image_tag = image_tag_result.strip() if image_tag_result.strip() != \"null\" else \"not set\"\n                except:\n                    image_tag = \"not set\"\n\n                # Get version label\n                try:\n                    version_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    version_label = (\n                        version_label_result.strip() if version_label_result.strip() != \"null\" else \"not set\"\n                    )\n                except:\n                    version_label = \"not set\"\n\n                # Get instance label for context\n                try:\n                    instance_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/instance\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    instance_label = (\n                        instance_label_result.strip() if instance_label_result.strip() != \"null\" else \"not set\"\n                    )\n                except:\n                    instance_label = \"not set\"\n\n                # Display overlay info\n                console.print(f\"\\n\ud83c\udff7\ufe0f Overlay: {overlay_name}\", style=\"bold\")\n                console.print(f\"   Instance: {instance_label}\")\n                console.print(f\"   Image Tag: {image_tag}\")\n                console.print(f\"   Version Label: {version_label}\")\n\n                # Check completeness (both should be present but independent)\n                if image_tag != \"not set\" and version_label != \"not set\":\n                    console.print(\"   Status: \u2705 Complete\", style=\"green\")\n                else:\n                    missing = []\n                    if image_tag == \"not set\":\n                        missing.append(\"image tag\")\n                    if version_label == \"not set\":\n                        missing.append(\"version label\")\n                    console.print(f\"   Status: \u26a0\ufe0f Missing {', '.join(missing)}\", style=\"yellow\")\n\n        console.print(\"\\n\" + \"=\" * 50)\n        console.print(\"\ud83d\udcca Report completed\", style=\"bold blue\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_markdown","title":"<code>lint_markdown()</code>  <code>async</code>","text":"<p>Run Markdown linting and formatting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_markdown(self) -&gt; None:\n    \"\"\"Run Markdown linting and formatting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running Markdown linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        # Check if there are any markdown files to lint\n        try:\n            # Find markdown files\n            md_files_result = await container.with_exec(\n                [\n                    \"find\",\n                    \".\",\n                    \"-name\",\n                    \"*.md\",\n                    \"-type\",\n                    \"f\",\n                    \"!\",\n                    \"-path\",\n                    \"./.venv/*\",\n                    \"!\",\n                    \"-path\",\n                    \"./node_modules/*\",\n                ]\n            ).stdout()\n\n            md_files = [f.strip() for f in md_files_result.strip().split(\"\\n\") if f.strip()]\n\n            if not md_files:\n                console.print(\"\ud83d\udcdd No markdown files found to lint\", style=\"yellow\")\n                return\n\n            if self.verbose:\n                console.print(f\"Found {len(md_files)} markdown files to check\")\n\n            # Run mdformat check (dry-run to validate formatting)\n            await container.with_exec([\"poetry\", \"run\", \"mdformat\", \"--check\"] + md_files).stdout()\n\n            console.print(\"\u2705 Markdown linting passed\", style=\"green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Markdown formatting issues found: {str(e)}\", style=\"red\")\n            raise Exception(\"Markdown files need formatting. Run 'poetry run mdformat .' to fix.\") from e\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_python","title":"<code>lint_python()</code>  <code>async</code>","text":"<p>Run Python linting and formatting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_python(self) -&gt; None:\n    \"\"\"Run Python linting and formatting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running Python linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        # Run ruff check\n        await container.with_exec([\"poetry\", \"run\", \"ruff\", \"check\", \".\"]).stdout()\n\n        # Run ruff format check\n        await container.with_exec([\"poetry\", \"run\", \"ruff\", \"format\", \"--check\", \".\"]).stdout()\n\n        console.print(\"\u2705 Python linting passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_yaml","title":"<code>lint_yaml()</code>  <code>async</code>","text":"<p>Run YAML linting using yamllint.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_yaml(self) -&gt; None:\n    \"\"\"Run YAML linting using yamllint.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running YAML linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        result = await container.with_exec([\"poetry\", \"run\", \"yamllint\", \".\"]).stdout()\n\n        if self.verbose:\n            console.print(result)\n\n        console.print(\"\u2705 YAML linting passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.list_doc_versions","title":"<code>list_doc_versions()</code>  <code>async</code>","text":"<p>List all deployed documentation versions.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def list_doc_versions(self) -&gt; None:\n    \"\"\"List all deployed documentation versions.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udccb Listing documentation versions...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        try:\n            versions_result = await container.with_exec([\"poetry\", \"run\", \"mike\", \"list\"]).stdout()\n\n            console.print(\"\\n\ud83d\udcda Deployed Documentation Versions:\", style=\"bold blue\")\n            console.print(\"=\" * 40)\n            console.print(versions_result)\n            console.print(\"=\" * 40)\n\n        except Exception as e:\n            console.print(\n                \"No versions deployed yet or git repository not initialized\",\n                style=\"yellow\",\n            )\n            if self.verbose:\n                console.print(f\"Error: {e}\", style=\"red\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.run_all_linting","title":"<code>run_all_linting()</code>  <code>async</code>","text":"<p>Run all linting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def run_all_linting(self) -&gt; None:\n    \"\"\"Run all linting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running comprehensive linting...\")\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        console=console,\n    ) as progress:\n        task1 = progress.add_task(\"YAML linting...\", total=None)\n        await self.lint_yaml()\n        progress.update(task1, completed=True)\n\n        task2 = progress.add_task(\"Python linting...\", total=None)\n        await self.lint_python()\n        progress.update(task2, completed=True)\n\n        task3 = progress.add_task(\"Markdown linting...\", total=None)\n        await self.lint_markdown()\n        progress.update(task3, completed=True)\n\n        task4 = progress.add_task(\"Kustomize validation...\", total=None)\n        await self.validate_kustomize()\n        progress.update(task4, completed=True)\n\n        task5 = progress.add_task(\"Security scan...\", total=None)\n        await self.security_scan()\n        progress.update(task5, completed=True)\n\n    console.print(\"\u2705 All linting checks completed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.run_all_linting_parallel","title":"<code>run_all_linting_parallel()</code>  <code>async</code>","text":"<p>Run all linting checks in parallel for maximum speed.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def run_all_linting_parallel(self) -&gt; None:\n    \"\"\"Run all linting checks in parallel for maximum speed.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running comprehensive linting in parallel...\")\n\n    import asyncio\n\n    # Run all linting tasks in parallel\n    tasks = [\n        self.lint_yaml(),\n        self.lint_python(),\n        self.lint_markdown(),\n        self.validate_kustomize(),\n        self.security_scan(),\n    ]\n\n    try:\n        await asyncio.gather(*tasks)\n        console.print(\"\u2705 All parallel linting checks completed\", style=\"green\")\n    except Exception as e:\n        console.print(f\"\u274c Parallel linting failed: {e}\", style=\"red\")\n        raise\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.run_pre_commit","title":"<code>run_pre_commit()</code>  <code>async</code>","text":"<p>Run pre-commit hooks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def run_pre_commit(self) -&gt; None:\n    \"\"\"Run pre-commit hooks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running pre-commit hooks...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        await container.with_exec([\"poetry\", \"run\", \"pre-commit\", \"run\", \"--all-files\"]).stdout()\n\n        console.print(\"\u2705 Pre-commit hooks passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.security_scan","title":"<code>security_scan()</code>  <code>async</code>","text":"<p>Run security checks on Kustomize configurations.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def security_scan(self) -&gt; None:\n    \"\"\"Run security checks on Kustomize configurations.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running security scan...\")\n\n    async with self._get_client() as client:\n        container = await self._get_kustomize_container(client)\n\n        # Generate manifests for security scanning\n        overlays_dir = self.project_root / \"overlays\"\n        security_issues = 0\n\n        if overlays_dir.exists():\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    if self.verbose:\n                        console.print(f\"Scanning overlay: {overlay_name}\")\n\n                    # Generate manifest\n                    manifest_content = await container.with_exec(\n                        [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n                    ).stdout()\n\n                    # Check for security issues\n                    issues = self._check_security_issues(manifest_content, overlay_name)\n                    security_issues += issues\n\n        if security_issues &gt; 0:\n            raise Exception(f\"Found {security_issues} security issues\")\n\n        console.print(\"\u2705 Security scan passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.security_scan_generated","title":"<code>security_scan_generated(output_dir)</code>  <code>async</code>","text":"<p>Run security checks on generated manifests.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def security_scan_generated(self, output_dir: str) -&gt; None:\n    \"\"\"Run security checks on generated manifests.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running security scan on generated manifests...\")\n\n    manifests_dir = Path(output_dir)\n    if not manifests_dir.exists():\n        raise Exception(f\"Manifests directory {output_dir} does not exist\")\n\n    security_issues = 0\n    for manifest_file in manifests_dir.glob(\"*.yaml\"):\n        if self.verbose:\n            console.print(f\"Scanning manifest: {manifest_file.name}\")\n\n        content = manifest_file.read_text()\n        issues = self._check_security_issues(content, manifest_file.name)\n        security_issues += issues\n\n    if security_issues &gt; 0:\n        raise Exception(f\"Found {security_issues} security issues in generated manifests\")\n\n    console.print(\"\u2705 Security scan on generated manifests passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.serve_docs","title":"<code>serve_docs(port=8000)</code>  <code>async</code>","text":"<p>Serve documentation locally for development.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def serve_docs(self, port: int = 8000) -&gt; None:\n    \"\"\"Serve documentation locally for development.\"\"\"\n    if self.verbose:\n        console.print(f\"\ud83c\udf10 Starting documentation server on port {port}...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        console.print(f\"\ud83d\udcda Documentation server starting at http://localhost:{port}\")\n        console.print(\"Press Ctrl+C to stop the server\")\n\n        # Serve documentation (this will run until interrupted)\n        await container.with_exec([\"poetry\", \"run\", \"mkdocs\", \"serve\", \"--dev-addr\", f\"0.0.0.0:{port}\"]).stdout()\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.setup_environment","title":"<code>setup_environment()</code>  <code>async</code>","text":"<p>Set up development environment.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def setup_environment(self) -&gt; None:\n    \"\"\"Set up development environment.\"\"\"\n    if self.verbose:\n        console.print(\"\u2699\ufe0f Setting up development environment...\")\n\n    async with self._get_client() as client:\n        # Install Python dependencies\n        container = await self._get_python_container(client)\n\n        # Install pre-commit hooks\n        await container.with_exec([\"poetry\", \"run\", \"pre-commit\", \"install\"]).stdout()\n\n        console.print(\"\u2705 Development environment setup completed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.update_all_versions","title":"<code>update_all_versions(version, dry_run=False)</code>  <code>async</code>","text":"<p>Update version for all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def update_all_versions(self, version: str, dry_run: bool = False) -&gt; None:\n    \"\"\"Update version for all overlays.\"\"\"\n    if not self._validate_version_format(version):\n        raise Exception(f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n    if not overlay_names:\n        console.print(\"No overlays found to update\", style=\"yellow\")\n        return\n\n    for overlay_name in overlay_names:\n        await self.update_overlay_version(overlay_name, version, dry_run)\n\n    if not dry_run:\n        console.print(f\"\u2705 Updated {len(overlay_names)} overlays to version: {version}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.update_overlay_version","title":"<code>update_overlay_version(overlay_name, version, dry_run=False)</code>  <code>async</code>","text":"<p>Update version for a specific overlay.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def update_overlay_version(self, overlay_name: str, version: str, dry_run: bool = False) -&gt; None:\n    \"\"\"Update version for a specific overlay.\"\"\"\n    if not self._validate_version_format(version):\n        raise Exception(f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\")\n\n    overlay_path = self.project_root / \"overlays\" / overlay_name\n    if not overlay_path.exists():\n        raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n    kustomization_file = overlay_path / \"kustomization.yaml\"\n    if not kustomization_file.exists():\n        raise Exception(f\"Kustomization file not found: {kustomization_file}\")\n\n    if self.verbose:\n        console.print(f\"\ud83c\udff7\ufe0f Processing overlay: {overlay_name}\")\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n\n        # Read current values for dry run\n        if dry_run:\n            current_tag_result = await container.with_exec(\n                [\n                    \"yq\",\n                    '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            current_tag = current_tag_result.strip() if current_tag_result.strip() != \"null\" else \"not set\"\n\n            current_version_result = await container.with_exec(\n                [\n                    \"yq\",\n                    '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            current_version = (\n                current_version_result.strip() if current_version_result.strip() != \"null\" else \"not set\"\n            )\n\n            console.print(f\"  [DRY RUN] Would update image tag from '{current_tag}' to '{version}'\")\n            console.print(f\"  [DRY RUN] Would update version label from '{current_version}' to '{version}'\")\n            return\n\n        # Update image tag\n        await container.with_exec(\n            [\n                \"yq\",\n                \"-i\",\n                f'.images[] |= select(.name == \"docker.io/solidproject/community-server\").newTag = \"{version}\"',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        # Update version label\n        await container.with_exec(\n            [\n                \"yq\",\n                \"-i\",\n                f'.labels[0].pairs.\"app.kubernetes.io/version\" = \"{version}\"',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        # Update version patch if it exists\n        patch_check = await container.with_exec(\n            [\n                \"yq\",\n                '.patches[] | select(.target.kind == \"Deployment\") | .patch',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        if \"app.kubernetes.io~1version\" in patch_check:\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) |= sub(\"value: \\\\\"[^\\\\\"]*\\\\\"\"; \"value: \\\\\"{version}\\\\\"\"; \"g\")',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            console.print(f\"  \u2705 Updated deployment version patch to: {version}\")\n        else:\n            # Add version patch if it doesn't exist\n            patch_content = f'      - op: add\\\\n        path: /spec/template/metadata/labels/app.kubernetes.io~1version\\\\n        value: \\\\\"{version}\\\\\"'\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) += \"\\\\n{patch_content}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            console.print(f\"  \u2705 Added deployment version patch: {version}\")\n\n        # Copy updated file back to host\n        updated_content = await container.file(f\"overlays/{overlay_name}/kustomization.yaml\").contents()\n        kustomization_file.write_text(updated_content)\n\n        console.print(f\"  \u2705 Updated image tag to: {version}\")\n        console.print(f\"  \u2705 Updated version label to: {version}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.validate_kustomize","title":"<code>validate_kustomize()</code>  <code>async</code>","text":"<p>Validate Kustomize configurations.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def validate_kustomize(self) -&gt; None:\n    \"\"\"Validate Kustomize configurations.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Validating Kustomize configurations...\")\n\n    async with self._get_client() as client:\n        container = await self._get_kustomize_container(client)\n\n        # Validate base configuration\n        await container.with_exec([\"kustomize\", \"build\", \"base/\"]).stdout()\n\n        # Validate overlays\n        overlays_dir = self.project_root / \"overlays\"\n        if overlays_dir.exists():\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    if self.verbose:\n                        console.print(f\"Validating overlay: {overlay_name}\")\n\n                    await container.with_exec([\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]).stdout()\n\n        console.print(\"\u2705 Kustomize validation passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.validate_version_consistency","title":"<code>validate_version_consistency()</code>  <code>async</code>","text":"<p>Validate version consistency across all overlays.</p> <p>This validates that: - Image tags are present and valid (CSS application version) - Version labels are present and valid (project version from pyproject.toml) - Both are consistently applied across all overlays</p> <p>Note: Image tags and version labels are intentionally independent - image tags represent the CSS application version while version labels represent the project/tooling version.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def validate_version_consistency(self) -&gt; None:\n    \"\"\"Validate version consistency across all overlays.\n\n    This validates that:\n    - Image tags are present and valid (CSS application version)\n    - Version labels are present and valid (project version from pyproject.toml)\n    - Both are consistently applied across all overlays\n\n    Note: Image tags and version labels are intentionally independent -\n    image tags represent the CSS application version while version labels\n    represent the project/tooling version.\n    \"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Validating version consistency...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    # Get expected project version from pyproject.toml\n    expected_project_version = await self._get_project_version()\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n        issues = []\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                overlay_name = overlay_path.name\n                kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                # Get image tag\n                try:\n                    image_tag_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    image_tag = image_tag_result.strip() if image_tag_result.strip() != \"null\" else None\n                except:\n                    image_tag = None\n\n                # Get version label\n                try:\n                    version_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    version_label = version_label_result.strip() if version_label_result.strip() != \"null\" else None\n                except:\n                    version_label = None\n\n                # Validate image tag presence\n                if not image_tag:\n                    issues.append(f\"{overlay_name}: missing image tag\")\n                elif not self._validate_version_format(image_tag):\n                    issues.append(f\"{overlay_name}: invalid image tag format '{image_tag}'\")\n\n                # Validate version label presence and consistency with project version\n                if not version_label:\n                    issues.append(f\"{overlay_name}: missing version label\")\n                elif version_label != expected_project_version:\n                    issues.append(\n                        f\"{overlay_name}: version label '{version_label}' != project version '{expected_project_version}'\"\n                    )\n\n        if issues:\n            console.print(\"\u274c Version consistency issues found:\", style=\"red\")\n            for issue in issues:\n                console.print(f\"  \u2022 {issue}\", style=\"red\")\n            raise Exception(f\"Found {len(issues)} version consistency issues\")\n\n        console.print(\"\u2705 Version consistency validation passed\", style=\"green\")\n</code></pre>"},{"location":"user-guide/cli-commands/","title":"CLI Commands","text":"<p>The CSS Kustomize project provides a comprehensive command-line interface through the <code>dagger-pipeline</code> command. This page documents all available commands, their options, and usage examples.</p>"},{"location":"user-guide/cli-commands/#overview","title":"Overview","text":"<p>The CLI is built using Click and provides rich output with colors, progress indicators, and detailed error messages. All commands support a <code>--verbose</code> flag for detailed debugging output.</p> <pre><code>poetry run dagger-pipeline --help\n</code></pre>"},{"location":"user-guide/cli-commands/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--verbose</code> / <code>-v</code>: Enable verbose output with detailed logging</li> <li><code>--help</code>: Show help message and exit</li> </ul>"},{"location":"user-guide/cli-commands/#commands-reference","title":"Commands Reference","text":""},{"location":"user-guide/cli-commands/#lint-code-quality-checks","title":"<code>lint</code> - Code Quality Checks","text":"<p>Run various linting and formatting checks on the codebase.</p> <pre><code>poetry run dagger-pipeline lint [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#options","title":"Options","text":"<ul> <li><code>--yaml</code> / <code>--no-yaml</code>: Run YAML linting with yamllint (default: enabled)</li> <li><code>--python</code> / <code>--no-python</code>: Run Python linting with ruff (default: enabled)</li> <li><code>--markdown</code> / <code>--no-markdown</code>: Run Markdown formatting checks (default: enabled)</li> <li><code>--parallel</code> / <code>--no-parallel</code>: Run linting checks in parallel (default: sequential)</li> </ul>"},{"location":"user-guide/cli-commands/#examples","title":"Examples","text":"<pre><code># Run all linting checks\npoetry run dagger-pipeline lint\n\n# Run only YAML linting\npoetry run dagger-pipeline lint --yaml --no-python --no-markdown\n\n# Run with verbose output\npoetry run dagger-pipeline lint --verbose\n\n# Run in parallel for faster execution\npoetry run dagger-pipeline lint --parallel\n</code></pre>"},{"location":"user-guide/cli-commands/#validate-kustomize-validation","title":"<code>validate</code> - Kustomize Validation","text":"<p>Validate Kustomize configurations for all overlays.</p> <pre><code>poetry run dagger-pipeline validate [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_1","title":"Examples","text":"<pre><code># Validate all overlays\npoetry run dagger-pipeline validate\n\n# Validate with verbose output\npoetry run dagger-pipeline validate --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#generate-generate-manifests","title":"<code>generate</code> - Generate Manifests","text":"<p>Generate Kubernetes manifests for all overlays.</p> <pre><code>poetry run dagger-pipeline generate [OPTIONS] OUTPUT_DIR\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments","title":"Arguments","text":"<ul> <li><code>OUTPUT_DIR</code>: Directory where generated manifests will be saved</li> </ul>"},{"location":"user-guide/cli-commands/#options_1","title":"Options","text":"<ul> <li><code>--parallel</code> / <code>--no-parallel</code>: Generate manifests in parallel (default: sequential)</li> </ul>"},{"location":"user-guide/cli-commands/#examples_2","title":"Examples","text":"<pre><code># Generate all manifests\npoetry run dagger-pipeline generate manifests/\n\n# Generate with parallel execution\npoetry run dagger-pipeline generate --parallel manifests/\n\n# Generate to custom directory\npoetry run dagger-pipeline generate /tmp/k8s-manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#generate-overlay-generate-single-overlay","title":"<code>generate-overlay</code> - Generate Single Overlay","text":"<p>Generate manifest for a specific overlay.</p> <pre><code>poetry run dagger-pipeline generate-overlay [OPTIONS] OVERLAY_NAME OUTPUT_PATH\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_1","title":"Arguments","text":"<ul> <li><code>OVERLAY_NAME</code>: Name of the overlay to generate (e.g., <code>with-pvc</code>, <code>without-pvc</code>)</li> <li><code>OUTPUT_PATH</code>: Path where the generated manifest will be saved</li> </ul>"},{"location":"user-guide/cli-commands/#examples_3","title":"Examples","text":"<pre><code># Generate specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc manifests/with-pvc.yaml\n\n# Generate local development overlay\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/local.yaml\n</code></pre>"},{"location":"user-guide/cli-commands/#security-scan-security-scanning","title":"<code>security-scan</code> - Security Scanning","text":"<p>Run security checks on Kustomize configurations.</p> <pre><code>poetry run dagger-pipeline security-scan [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_4","title":"Examples","text":"<pre><code># Scan all overlays for security issues\npoetry run dagger-pipeline security-scan\n\n# Scan with verbose output\npoetry run dagger-pipeline security-scan --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#security-scan-generated-scan-generated-manifests","title":"<code>security-scan-generated</code> - Scan Generated Manifests","text":"<p>Run security checks on previously generated manifest files.</p> <pre><code>poetry run dagger-pipeline security-scan-generated [OPTIONS] MANIFESTS_DIR\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_2","title":"Arguments","text":"<ul> <li><code>MANIFESTS_DIR</code>: Directory containing generated manifest files</li> </ul>"},{"location":"user-guide/cli-commands/#examples_5","title":"Examples","text":"<pre><code># Scan generated manifests\npoetry run dagger-pipeline security-scan-generated manifests/\n\n# Scan with verbose output\npoetry run dagger-pipeline security-scan-generated --verbose manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#version-update-update-version","title":"<code>version update</code> - Update Version","text":"<p>Update the version across all overlays (image tags and labels).</p> <pre><code>poetry run dagger-pipeline version update [OPTIONS] VERSION\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_3","title":"Arguments","text":"<ul> <li><code>VERSION</code>: Semantic version to update to (e.g., <code>6.0.3</code>, <code>6.1.0-beta.1</code>)</li> </ul>"},{"location":"user-guide/cli-commands/#options_2","title":"Options","text":"<ul> <li><code>--dry-run</code>: Show what would be changed without making actual changes</li> </ul>"},{"location":"user-guide/cli-commands/#examples_6","title":"Examples","text":"<pre><code># Update to new version\npoetry run dagger-pipeline version update 6.0.3\n\n# Preview changes without applying\npoetry run dagger-pipeline version update --dry-run 6.1.0\n\n# Update with verbose output\npoetry run dagger-pipeline version update --verbose 6.0.3\n</code></pre>"},{"location":"user-guide/cli-commands/#update-overlay-version-update-single-overlay","title":"<code>update-overlay-version</code> - Update Single Overlay","text":"<p>Update version for a specific overlay only.</p> <pre><code>poetry run dagger-pipeline update-overlay-version [OPTIONS] OVERLAY_NAME VERSION\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_4","title":"Arguments","text":"<ul> <li><code>OVERLAY_NAME</code>: Name of the overlay to update</li> <li><code>VERSION</code>: Semantic version to update to</li> </ul>"},{"location":"user-guide/cli-commands/#options_3","title":"Options","text":"<ul> <li><code>--dry-run</code>: Show what would be changed without making actual changes</li> </ul>"},{"location":"user-guide/cli-commands/#examples_7","title":"Examples","text":"<pre><code># Update specific overlay\npoetry run dagger-pipeline update-overlay-version with-pvc 6.0.3\n\n# Preview changes\npoetry run dagger-pipeline update-overlay-version --dry-run without-pvc 6.1.0\n</code></pre>"},{"location":"user-guide/cli-commands/#version-report-version-report","title":"<code>version-report</code> - Version Report","text":"<p>Generate a report showing current versions across all overlays.</p> <pre><code>poetry run dagger-pipeline version-report [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_8","title":"Examples","text":"<pre><code># Show version report\npoetry run dagger-pipeline version-report\n\n# Show with verbose details\npoetry run dagger-pipeline version-report --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#validate-versions-validate-version-consistency","title":"<code>validate-versions</code> - Validate Version Consistency","text":"<p>Check that image tags match version labels across all overlays.</p> <pre><code>poetry run dagger-pipeline validate-versions [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_9","title":"Examples","text":"<pre><code># Validate version consistency\npoetry run dagger-pipeline validate-versions\n\n# Validate with verbose output\npoetry run dagger-pipeline validate-versions --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#ci-complete-ci-pipeline","title":"<code>ci</code> - Complete CI Pipeline","text":"<p>Run the complete CI/CD pipeline including all linting, validation, generation, and security scanning.</p> <pre><code>poetry run dagger-pipeline ci [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#options_4","title":"Options","text":"<ul> <li><code>--parallel</code> / <code>--no-parallel</code>: Run operations in parallel where possible (default: sequential)</li> </ul>"},{"location":"user-guide/cli-commands/#examples_10","title":"Examples","text":"<pre><code># Run complete CI pipeline\npoetry run dagger-pipeline ci\n\n# Run with verbose output\npoetry run dagger-pipeline ci --verbose\n\n# Run with parallel execution\npoetry run dagger-pipeline ci --parallel --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#setup-env-setup-development-environment","title":"<code>setup-env</code> - Setup Development Environment","text":"<p>Set up the development environment with pre-commit hooks and dependencies.</p> <pre><code>poetry run dagger-pipeline setup-env [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_11","title":"Examples","text":"<pre><code># Setup development environment\npoetry run dagger-pipeline setup-env\n\n# Setup with verbose output\npoetry run dagger-pipeline setup-env --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#pre-commit-run-pre-commit-hooks","title":"<code>pre-commit</code> - Run Pre-commit Hooks","text":"<p>Execute pre-commit hooks on all files.</p> <pre><code>poetry run dagger-pipeline pre-commit [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_12","title":"Examples","text":"<pre><code># Run pre-commit hooks\npoetry run dagger-pipeline pre-commit\n\n# Run with verbose output\npoetry run dagger-pipeline pre-commit --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/cli-commands/#development-workflow","title":"Development Workflow","text":"<pre><code># Quick checks during development\npoetry run dagger-pipeline lint --yaml --python\n\n# Validate changes\npoetry run dagger-pipeline validate\n\n# Generate and test manifests\npoetry run dagger-pipeline generate manifests/\npoetry run dagger-pipeline security-scan-generated manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#release-workflow","title":"Release Workflow","text":"<pre><code># Update version across all overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Validate version consistency\npoetry run dagger-pipeline validate-versions\n\n# Run complete CI pipeline\npoetry run dagger-pipeline ci --verbose\n\n# Generate final manifests\npoetry run dagger-pipeline generate --parallel manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#debugging-workflow","title":"Debugging Workflow","text":"<pre><code># Run with maximum verbosity\npoetry run dagger-pipeline ci --verbose\n\n# Check specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc /tmp/debug.yaml\n\n# Validate single aspect\npoetry run dagger-pipeline lint --python-only --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#exit-codes","title":"Exit Codes","text":"<p>The CLI uses standard exit codes:</p> <ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error (linting failures, validation errors, etc.)</li> <li><code>2</code>: Command line usage error</li> </ul>"},{"location":"user-guide/cli-commands/#environment-variables","title":"Environment Variables","text":"<p>The CLI respects these environment variables:</p> <ul> <li><code>DAGGER_LOG_LEVEL</code>: Set Dagger logging level (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>)</li> <li><code>NO_COLOR</code>: Disable colored output when set to any value</li> <li><code>FORCE_COLOR</code>: Force colored output even in non-TTY environments</li> </ul>"},{"location":"user-guide/cli-commands/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/cli-commands/#use-parallel-execution","title":"Use Parallel Execution","text":"<p>For faster execution, use parallel options where available:</p> <pre><code>poetry run dagger-pipeline lint --parallel\npoetry run dagger-pipeline generate --parallel manifests/\npoetry run dagger-pipeline ci --parallel\n</code></pre>"},{"location":"user-guide/cli-commands/#selective-operations","title":"Selective Operations","text":"<p>Run only what you need during development:</p> <pre><code># Only YAML linting\npoetry run dagger-pipeline lint --yaml-only\n\n# Only specific overlay\npoetry run dagger-pipeline generate-overlay without-pvc manifests/local.yaml\n</code></pre>"},{"location":"user-guide/cli-commands/#verbose-output-for-debugging","title":"Verbose Output for Debugging","text":"<p>Use verbose mode to understand what's happening:</p> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#integration-with-other-tools","title":"Integration with Other Tools","text":""},{"location":"user-guide/cli-commands/#pre-commit-integration","title":"Pre-commit Integration","text":"<pre><code># Install pre-commit hooks\npoetry run dagger-pipeline setup-env\n\n# Run hooks manually\npoetry run dagger-pipeline pre-commit\n</code></pre>"},{"location":"user-guide/cli-commands/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># In CI/CD pipelines\npoetry run dagger-pipeline ci --parallel --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#ide-integration","title":"IDE Integration","text":"<p>Many IDEs can be configured to run these commands as tasks or build steps. See the Examples section for specific integrations.</p>"},{"location":"user-guide/documentation-versioning/","title":"Documentation Versioning","text":"<p>This guide explains how to manage versioned documentation for the CSS Kustomize project using MkDocs and mike.</p>"},{"location":"user-guide/documentation-versioning/#overview","title":"Overview","text":"<p>The CSS Kustomize project uses mike for versioned documentation deployment. This allows you to:</p> <ul> <li>Deploy multiple versions of documentation simultaneously</li> <li>Maintain documentation for different releases</li> <li>Set default versions and aliases</li> <li>Provide users with version-specific documentation</li> </ul>"},{"location":"user-guide/documentation-versioning/#version-management","title":"Version Management","text":""},{"location":"user-guide/documentation-versioning/#automatic-versioning","title":"Automatic Versioning","text":"<p>The documentation version is automatically derived from the project version in <code>pyproject.toml</code>. When you deploy documentation, it will use the current project version unless explicitly specified.</p>"},{"location":"user-guide/documentation-versioning/#manual-version-deployment","title":"Manual Version Deployment","text":"<p>You can deploy documentation for a specific version:</p> <pre><code># Deploy current project version\npoetry run dagger-pipeline docs deploy\n\n# Deploy specific version with alias\npoetry run dagger-pipeline docs deploy --version 1.2.3 --alias stable\n\n# Deploy and set as default\npoetry run dagger-pipeline docs deploy --version 1.2.3 --set-default\n</code></pre>"},{"location":"user-guide/documentation-versioning/#available-commands","title":"Available Commands","text":""},{"location":"user-guide/documentation-versioning/#build-documentation","title":"Build Documentation","text":"<p>Build documentation locally for testing:</p> <pre><code>poetry run dagger-pipeline docs build\n</code></pre> <p>This creates a <code>site/</code> directory with the built documentation.</p>"},{"location":"user-guide/documentation-versioning/#serve-documentation","title":"Serve Documentation","text":"<p>Serve documentation locally for development:</p> <pre><code># Serve on default port 8000\npoetry run dagger-pipeline docs serve\n\n# Serve on custom port\npoetry run dagger-pipeline docs serve --port 3000\n</code></pre>"},{"location":"user-guide/documentation-versioning/#deploy-documentation","title":"Deploy Documentation","text":"<p>Deploy versioned documentation to GitHub Pages:</p> <pre><code># Deploy with project version and 'latest' alias\npoetry run dagger-pipeline docs deploy\n\n# Deploy specific version\npoetry run dagger-pipeline docs deploy --version 2.0.0\n\n# Deploy with custom alias\npoetry run dagger-pipeline docs deploy --version 2.0.0 --alias stable\n\n# Deploy and set as default version\npoetry run dagger-pipeline docs deploy --version 2.0.0 --set-default\n</code></pre>"},{"location":"user-guide/documentation-versioning/#list-versions","title":"List Versions","text":"<p>List all deployed documentation versions:</p> <pre><code>poetry run dagger-pipeline docs list-versions\n</code></pre>"},{"location":"user-guide/documentation-versioning/#delete-version","title":"Delete Version","text":"<p>Delete a specific documentation version:</p> <pre><code>poetry run dagger-pipeline docs delete-version 1.0.0\n</code></pre>"},{"location":"user-guide/documentation-versioning/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>The project's CI/CD pipeline automatically deploys documentation when changes are pushed to the main branch. The workflow:</p> <ol> <li>Gets the current project version from <code>pyproject.toml</code></li> <li>Deploys documentation with that version and the <code>latest</code> alias</li> <li>Sets <code>latest</code> as the default version</li> </ol>"},{"location":"user-guide/documentation-versioning/#version-display","title":"Version Display","text":"<p>The documentation site includes:</p> <ul> <li>Version selector: Users can switch between different versions</li> <li>Version badge: Shows the current version being viewed</li> <li>Latest indicator: Clearly marks the latest/default version</li> </ul>"},{"location":"user-guide/documentation-versioning/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/documentation-versioning/#version-naming","title":"Version Naming","text":"<ul> <li>Use semantic versioning (e.g., <code>1.2.3</code>)</li> <li>Use meaningful aliases like <code>latest</code>, <code>stable</code>, <code>dev</code></li> <li>Avoid overwriting existing versions unless necessary</li> </ul>"},{"location":"user-guide/documentation-versioning/#deployment-strategy","title":"Deployment Strategy","text":"<ul> <li>Deploy documentation for each release</li> <li>Keep the <code>latest</code> alias pointing to the most recent stable release</li> <li>Use descriptive commit messages when deploying documentation</li> </ul>"},{"location":"user-guide/documentation-versioning/#maintenance","title":"Maintenance","text":"<ul> <li>Regularly review and clean up old versions</li> <li>Ensure documentation stays in sync with code changes</li> <li>Test documentation builds before deployment</li> </ul>"},{"location":"user-guide/documentation-versioning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/documentation-versioning/#common-issues","title":"Common Issues","text":"<p>Git configuration errors: Ensure git is properly configured in your environment.</p> <p>Version conflicts: Use <code>list-versions</code> to check existing versions before deployment.</p> <p>Build failures: Run <code>docs build</code> locally to test before deployment.</p>"},{"location":"user-guide/documentation-versioning/#getting-help","title":"Getting Help","text":"<p>For issues with documentation versioning:</p> <ol> <li>Check the build logs with <code>--verbose</code> flag</li> <li>Verify your git configuration</li> <li>Ensure all dependencies are installed with <code>poetry install --with=docs</code></li> </ol>"},{"location":"user-guide/documentation-versioning/#examples","title":"Examples","text":""},{"location":"user-guide/documentation-versioning/#release-workflow","title":"Release Workflow","text":"<p>When releasing version 2.1.0:</p> <pre><code># Update project version\npoetry version 2.1.0\n\n# Deploy documentation\npoetry run dagger-pipeline docs deploy --version 2.1.0 --alias latest --set-default\n\n# Verify deployment\npoetry run dagger-pipeline docs list-versions\n</code></pre>"},{"location":"user-guide/documentation-versioning/#development-workflow","title":"Development Workflow","text":"<p>For development documentation:</p> <pre><code># Serve locally during development\npoetry run dagger-pipeline docs serve\n\n# Build and test\npoetry run dagger-pipeline docs build\n\n# Deploy development version\npoetry run dagger-pipeline docs deploy --version dev --alias development\n</code></pre>"},{"location":"user-guide/kustomize-overlays/","title":"Kustomize Overlays","text":"<p>Learn how to work with Kustomize overlays in the CSS Kustomize project.</p>"},{"location":"user-guide/kustomize-overlays/#overview","title":"Overview","text":"<p>This project uses Kustomize overlays to manage environment-specific configurations for the Community Solid Server.</p>"},{"location":"user-guide/kustomize-overlays/#available-overlays","title":"Available Overlays","text":""},{"location":"user-guide/kustomize-overlays/#with-pvc","title":"<code>with-pvc</code>","text":"<ul> <li>Purpose: Production-like deployment</li> <li>Release Name: <code>css-with-pvc</code></li> <li>Storage: PersistentVolumeClaim</li> <li>Use Case: Production deployments requiring persistence</li> </ul>"},{"location":"user-guide/kustomize-overlays/#without-pvc","title":"<code>without-pvc</code>","text":"<ul> <li>Purpose: Stateless deployment</li> <li>Release Name: <code>css-without-pvc</code></li> <li>Storage: None</li> <li>Use Case: Stateless production deployments</li> </ul>"},{"location":"user-guide/kustomize-overlays/#working-with-overlays","title":"Working with Overlays","text":""},{"location":"user-guide/kustomize-overlays/#building-manifests","title":"Building Manifests","text":"<pre><code># Build specific overlay\nkubectl kustomize overlays/with-pvc\n\n# Generate to file\nkubectl kustomize overlays/with-pvc &gt; manifests/with-pvc.yaml\n</code></pre>"},{"location":"user-guide/kustomize-overlays/#using-the-cli","title":"Using the CLI","text":"<pre><code># Generate all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Generate specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc manifests/with-pvc.yaml\n</code></pre>"},{"location":"user-guide/kustomize-overlays/#customization","title":"Customization","text":""},{"location":"user-guide/kustomize-overlays/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create new directory in <code>overlays/</code></li> <li>Add <code>kustomization.yaml</code></li> <li>Configure patches and resources</li> <li>Update CLI to include new overlay</li> </ol>"},{"location":"user-guide/kustomize-overlays/#modifying-existing-overlays","title":"Modifying Existing Overlays","text":"<p>Edit the <code>kustomization.yaml</code> files to customize:</p> <ul> <li>Resource patches</li> <li>ConfigMap generators</li> <li>Label transformers</li> <li>Name prefixes/suffixes</li> </ul>"},{"location":"user-guide/kustomize-overlays/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Release Names</li> <li>Explore Version Management</li> <li>Check CLI Commands</li> </ul>"},{"location":"user-guide/release-names/","title":"Release Name Usage Guide","text":""},{"location":"user-guide/release-names/#overview","title":"Overview","text":"<p>This project implements a comprehensive release name strategy using <code>app.kubernetes.io/instance</code> labels across all Kubernetes resources. Each overlay defines its own unique release name, ensuring proper resource identification and isolation.</p>"},{"location":"user-guide/release-names/#current-release-names","title":"Current Release Names","text":"Overlay Release Name Purpose <code>without-pvc</code> <code>css-local</code> Local development without PVC <code>with-pvc</code> <code>css-with-pvc</code> Local development with PVC <code>with-pvc</code> <code>css-with-pvc</code> Production-like with persistent storage <code>without-pvc</code> <code>css-without-pvc</code> Stateless deployment"},{"location":"user-guide/release-names/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/release-names/#base-resources","title":"Base Resources","text":"<ul> <li>Base resources (<code>base/deployment.yaml</code>, <code>base/service.yaml</code>) contain no hardcoded instance labels</li> <li>The base <code>kustomization.yaml</code> applies common labels like <code>app.kubernetes.io/name: community-solid-server</code></li> </ul>"},{"location":"user-guide/release-names/#overlay-configuration","title":"Overlay Configuration","text":"<p>Each overlay uses <code>labels</code> to apply the <code>app.kubernetes.io/instance</code> label:</p> <pre><code>labels:\n  app.kubernetes.io/instance: css-with-pvc\n</code></pre>"},{"location":"user-guide/release-names/#automatic-label-propagation","title":"Automatic Label Propagation","text":"<p>Kustomize automatically applies the instance label to:</p> <ul> <li>Metadata labels on all resources</li> <li>Selectors in Services (for pod selection)</li> <li>matchLabels in Deployments (for pod selection)</li> <li>Pod template labels (for proper identification)</li> </ul>"},{"location":"user-guide/release-names/#generated-manifests","title":"Generated Manifests","text":"<p>When you build an overlay, all resources will have consistent labeling:</p> <pre><code># Service\nmetadata:\n  labels:\n    app.kubernetes.io/name: community-solid-server\n    app.kubernetes.io/instance: css-with-pvc\n    app.kubernetes.io/version: \"6.0.2\"\nspec:\n  selector:\n    app.kubernetes.io/name: community-solid-server\n    app.kubernetes.io/instance: css-with-pvc\n    app.kubernetes.io/version: \"6.0.2\"\n\n# Deployment\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: community-solid-server\n      app.kubernetes.io/instance: css-with-pvc\n      app.kubernetes.io/version: \"6.0.2\"\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: community-solid-server\n        app.kubernetes.io/instance: css-with-pvc\n        app.kubernetes.io/version: \"6.0.2\"\n</code></pre>"},{"location":"user-guide/release-names/#usage-examples","title":"Usage Examples","text":""},{"location":"user-guide/release-names/#building-manifests","title":"Building Manifests","text":"<pre><code># Build specific overlay\nkubectl kustomize overlays/with-pvc\n\n# Apply to cluster\nkubectl apply -k overlays/with-pvc\n\n# Generate and save manifests\nkubectl kustomize overlays/without-pvc &gt; manifests/without-pvc.yaml\n</code></pre>"},{"location":"user-guide/release-names/#querying-resources-by-release","title":"Querying Resources by Release","text":"<pre><code># Find all resources for a specific release\nkubectl get all -l app.kubernetes.io/instance=css-with-pvc\n\n# Find pods for a specific release\nkubectl get pods -l app.kubernetes.io/instance=css-local\n\n# Describe deployment for a specific release\nkubectl describe deployment -l app.kubernetes.io/instance=css-without-pvc\n</code></pre>"},{"location":"user-guide/release-names/#adding-new-overlays","title":"Adding New Overlays","text":"<p>To create a new overlay with a custom release name:</p> <ol> <li>Create overlay directory:</li> </ol> <pre><code>mkdir -p overlays/my-environment\n</code></pre> <ol> <li>Create <code>kustomization.yaml</code>:</li> </ol> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: my-namespace\n\nresources:\n  - ../../base\n\nlabels:\n  app.kubernetes.io/instance: css-my-environment\n</code></pre> <ol> <li>Test the configuration:</li> </ol> <pre><code>kubectl kustomize overlays/my-environment\n</code></pre>"},{"location":"user-guide/release-names/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/release-names/#release-naming-convention","title":"Release Naming Convention","text":"<ul> <li>Use descriptive, environment-specific names</li> <li>Include the <code>css-</code> prefix for consistency</li> <li>Use lowercase with hyphens (kebab-case)</li> <li>Examples: <code>css-dev</code>, <code>css-staging</code>, <code>css-prod-us-east</code></li> </ul>"},{"location":"user-guide/release-names/#label-consistency","title":"Label Consistency","text":"<ul> <li>Always use <code>labels</code> in overlays for instance labels</li> <li>Ensure all resources inherit the same instance label</li> <li>Verify selectors include the instance label for proper isolation</li> </ul>"},{"location":"user-guide/release-names/#validation","title":"Validation","text":"<pre><code># Validate label consistency across resources\nkubectl kustomize overlays/with-pvc | grep -A 5 -B 5 \"app.kubernetes.io/instance\"\n\n# Check that selectors include instance labels\nkubectl kustomize overlays/with-pvc | grep -A 10 \"selector:\"\n</code></pre>"},{"location":"user-guide/release-names/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/release-names/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Missing instance labels in selectors</p> </li> <li> <p>Ensure you're using <code>labels</code>, not <code>labels</code></p> </li> <li> <p>Verify the overlay kustomization.yaml syntax</p> </li> <li> <p>Deprecation warnings</p> </li> <li> <p>The <code>labels</code> warnings are informational</p> </li> <li><code>labels</code> provides necessary selector functionality</li> <li> <p>The newer <code>labels</code> field doesn't update selectors</p> </li> <li> <p>Resource conflicts</p> </li> <li> <p>Different overlays with same release name will conflict</p> </li> <li>Ensure unique instance labels per environment</li> <li>Use namespaces for additional isolation</li> </ol>"},{"location":"user-guide/release-names/#validation-commands","title":"Validation Commands","text":"<pre><code># Test all overlays\nfor overlay in overlays/*/; do\n  echo \"Testing $overlay\"\n  kubectl kustomize \"$overlay\" &gt; /dev/null &amp;&amp; echo \"\u2713 Valid\" || echo \"\u2717 Invalid\"\ndone\n\n# Check for label consistency\nkubectl kustomize overlays/with-pvc | yq eval '.metadata.labels.\"app.kubernetes.io/instance\"' -\n</code></pre>"},{"location":"user-guide/release-names/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>The release name strategy integrates with your existing Dagger pipeline:</p> <pre><code># Example: Validate release names in pipeline\ndef validate_release_names(self):\n    overlays = [\"with-pvc\", \"without-pvc\"]\n    for overlay in overlays:\n        result = self.container.with_exec([\n            \"kubectl\", \"kustomize\", f\"overlays/{overlay}\"\n        ]).stdout()\n        # Validate that instance labels are present\n        assert \"app.kubernetes.io/instance\" in result\n</code></pre> <p>This ensures consistent release name application across all environments and deployments.</p>"},{"location":"user-guide/version-management/","title":"Version Management","text":"<p>Learn how to manage versions across CSS Kustomize overlays and deployments.</p>"},{"location":"user-guide/version-management/#overview","title":"Overview","text":"<p>CSS Kustomize provides comprehensive version management capabilities to ensure consistency across all overlays and deployments.</p>"},{"location":"user-guide/version-management/#version-strategy","title":"Version Strategy","text":""},{"location":"user-guide/version-management/#semantic-versioning","title":"Semantic Versioning","text":"<p>The project follows semantic versioning (SemVer) for Community Solid Server versions:</p> <ul> <li><code>MAJOR.MINOR.PATCH</code> (e.g., <code>6.0.3</code>)</li> <li>Pre-release versions: <code>6.1.0-beta.1</code></li> </ul>"},{"location":"user-guide/version-management/#version-consistency","title":"Version Consistency","text":"<p>All overlays maintain consistent versions across:</p> <ul> <li>Container image tags</li> <li>Kubernetes labels (<code>app.kubernetes.io/version</code>)</li> <li>Documentation references</li> </ul>"},{"location":"user-guide/version-management/#cli-commands","title":"CLI Commands","text":""},{"location":"user-guide/version-management/#update-all-overlays","title":"Update All Overlays","text":"<pre><code># Update version across all overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Preview changes without applying\npoetry run dagger-pipeline version update --dry-run 6.1.0\n</code></pre>"},{"location":"user-guide/version-management/#update-single-overlay","title":"Update Single Overlay","text":"<pre><code># Update specific overlay only\npoetry run dagger-pipeline update-overlay-version with-pvc 6.0.3\n\n# Preview changes for single overlay\npoetry run dagger-pipeline update-overlay-version --dry-run without-pvc 6.1.0\n</code></pre>"},{"location":"user-guide/version-management/#version-reporting","title":"Version Reporting","text":"<pre><code># Show current versions across all overlays\npoetry run dagger-pipeline version-report\n\n# Validate version consistency\npoetry run dagger-pipeline validate-versions\n</code></pre>"},{"location":"user-guide/version-management/#version-locations","title":"Version Locations","text":""},{"location":"user-guide/version-management/#image-tags","title":"Image Tags","text":"<p>Container image versions are specified in overlay patches:</p> <pre><code># overlays/with-pvc/kustomization.yaml\nimages:\n  - name: solidproject/community-server\n    newTag: \"6.0.3\"\n</code></pre>"},{"location":"user-guide/version-management/#kubernetes-labels","title":"Kubernetes Labels","text":"<p>Version labels are applied automatically:</p> <pre><code>labels:\n  - includeSelectors: false\n    pairs:\n      app.kubernetes.io/version: \"6.0.3\"\n</code></pre>"},{"location":"user-guide/version-management/#documentation","title":"Documentation","text":"<p>Version references in documentation are updated automatically during version updates.</p>"},{"location":"user-guide/version-management/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/version-management/#before-updating","title":"Before Updating","text":"<ol> <li>Check current versions:</li> </ol> <pre><code>poetry run dagger-pipeline version-report\n</code></pre> <ol> <li>Validate consistency:</li> </ol> <pre><code>poetry run dagger-pipeline validate-versions\n</code></pre>"},{"location":"user-guide/version-management/#during-updates","title":"During Updates","text":"<ol> <li>Use dry-run first:</li> </ol> <pre><code>poetry run dagger-pipeline version update --dry-run 6.0.3\n</code></pre> <ol> <li> <p>Update incrementally for major changes</p> </li> <li> <p>Test after updates:</p> </li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/version-management/#after-updates","title":"After Updates","text":"<ol> <li>Validate changes:</li> </ol> <pre><code>poetry run dagger-pipeline validate-versions\n</code></pre> <ol> <li>Generate manifests:</li> </ol> <pre><code>poetry run dagger-pipeline generate manifests/\n</code></pre> <ol> <li>Test deployments in development environment</li> </ol>"},{"location":"user-guide/version-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/version-management/#version-mismatches","title":"Version Mismatches","text":"<p>If versions are inconsistent:</p> <pre><code># Check what's wrong\npoetry run dagger-pipeline validate-versions --verbose\n\n# Fix automatically\npoetry run dagger-pipeline version update $(current-version)\n</code></pre>"},{"location":"user-guide/version-management/#rollback-changes","title":"Rollback Changes","text":"<p>To rollback version changes:</p> <pre><code># Use git to revert\ngit checkout -- overlays/\n\n# Or update to previous version\npoetry run dagger-pipeline version update 6.0.2\n</code></pre>"},{"location":"user-guide/version-management/#integration","title":"Integration","text":""},{"location":"user-guide/version-management/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>Include version validation in CI:</p> <pre><code># In CI pipeline\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"user-guide/version-management/#release-workflows","title":"Release Workflows","text":"<p>Typical release workflow:</p> <pre><code># 1. Update version\npoetry run dagger-pipeline update-version 6.0.3\n\n# 2. Validate and test\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci --verbose\n\n# 3. Generate final manifests\npoetry run dagger-pipeline generate manifests/\n\n# 4. Commit and tag\ngit add .\ngit commit -m \"Release 6.0.3\"\ngit tag v6.0.3\n</code></pre>"},{"location":"user-guide/version-management/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Release Names</li> <li>Explore CLI Commands</li> <li>Check Examples</li> </ul>"}]}
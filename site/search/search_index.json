{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CSS Kustomize Documentation","text":"<p>Welcome to the CSS Kustomize project documentation! This project provides Kubernetes manifests for the Community Solid Server with comprehensive Dagger automation for CI/CD pipelines.</p>"},{"location":"#overview","title":"Overview","text":"<p>CSS Kustomize is a modern DevOps solution that combines:</p> <ul> <li>Kubernetes Manifests: Production-ready configurations for Community Solid Server</li> <li>Kustomize Overlays: Environment-specific customizations with proper release name strategies</li> <li>Dagger Automation: Containerized CI/CD pipelines with comprehensive linting and validation</li> <li>Python CLI: Rich command-line interface for development and deployment workflows</li> </ul> <p>Author's Note: But why not helm? After all, there is a chart. I simply like kustomize more. Use the helm chart, it's great, and most of the components are built directly to match the features of the chart. I've tried to create some good mix-match overlays to represent what I experiment with. I'll happily take PRs with more!</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automated-cicd-pipeline","title":"\ud83d\ude80 Automated CI/CD Pipeline","text":"<ul> <li>Comprehensive linting (YAML, Python, Markdown)</li> <li>Kustomize validation and manifest generation</li> <li>Security scanning for Kubernetes resources</li> </ul>"},{"location":"#release-name-strategy","title":"\ud83c\udff7\ufe0f Release Name Strategy","text":"<ul> <li>Consistent <code>app.kubernetes.io/instance</code> labeling</li> <li>Environment-specific release names</li> <li>Proper resource isolation and identification</li> <li>Easy querying and management</li> </ul>"},{"location":"#developer-experience","title":"\ud83d\udd27 Developer Experience","text":"<ul> <li>Rich CLI with colored output and progress indicators</li> <li>Verbose mode for debugging and troubleshooting</li> <li>Fast feedback loops with caching strategies</li> <li>Cross-platform compatibility</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with CSS Kustomize in just a few commands:</p> <pre><code># Clone the repository\ngit clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n\n# Install dependencies\npoetry install\n\n# Run comprehensive CI pipeline\npoetry run dagger-pipeline ci\n\n# Generate manifests for all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Build specific overlay\nkubectl kustomize overlays/without-pvc\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>css-kustomize/\n\u251c\u2500\u2500 base/                    # Base Kubernetes manifests\n\u251c\u2500\u2500 overlays/               # Environment-specific overlays\n\u2502   \u251c\u2500\u2500 with-pvc/          # Production with persistent storage\n\u2502   \u2514\u2500\u2500 without-pvc/       # Stateless deployment\n\u251c\u2500\u2500 dagger_pipeline/       # Dagger automation code\n\u2502   \u251c\u2500\u2500 main.py           # CLI interface\n\u2502   \u2514\u2500\u2500 pipeline.py       # Core pipeline logic\n\u251c\u2500\u2500 docs/                  # Documentation source\n\u251c\u2500\u2500 manifests/            # Generated manifests\n\u2514\u2500\u2500 scripts/              # Utility scripts\n</code></pre>"},{"location":"#cli-commands","title":"CLI Commands","text":"<p>The project provides a comprehensive CLI for all operations:</p> <pre><code># Linting and validation\npoetry run dagger-pipeline lint --yaml --python --markdown\npoetry run dagger-pipeline validate\n\n# Manifest generation\npoetry run dagger-pipeline generate manifests/\npoetry run dagger-pipeline generate-overlay with-pvc manifests/\n\n# Security scanning\npoetry run dagger-pipeline security-scan\npoetry run dagger-pipeline security-scan-generated manifests/\n\n# Version management\n# NB, the version is the app.kubernetes.io/version not the CSS image tag.\npoetry run dagger-pipeline version update 0.3.0\npoetry run dagger-pipeline version report\n\n# Complete CI pipeline\npoetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#getting-started","title":"\ud83d\udcda Getting Started","text":"<ul> <li>Installation - Set up your development environment</li> <li>Quick Start - Get running in minutes</li> <li>Configuration - Customize for your needs</li> </ul>"},{"location":"#user-guide","title":"\ud83d\udc65 User Guide","text":"<ul> <li>CLI Commands - Complete command reference</li> <li>Kustomize Overlays - Working with overlays</li> <li>Version Management - Managing versions</li> </ul>"},{"location":"#developer-guide","title":"\ud83d\udd27 Developer Guide","text":"<ul> <li>Architecture - System design and components</li> <li>Dagger Pipeline - Pipeline internals</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<ul> <li>Pipeline Module - Core pipeline classes and functions</li> <li>CLI Module - Command-line interface reference</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: Report bugs and request features on GitHub Issues</li> <li>Discussions: Join the conversation in GitHub Discussions</li> <li>Contributing: See our Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache 2.0 License. See the LICENSE file for details.</p>"},{"location":"developer-guide/architecture/","title":"Architecture","text":"<p>Understanding the CSS Kustomize project architecture and design decisions.</p>"},{"location":"developer-guide/architecture/#overview","title":"Overview","text":"<p>CSS Kustomize is designed as a modern DevOps solution that combines Kubernetes manifests, Kustomize overlays, and Dagger automation for a complete CI/CD experience.</p>"},{"location":"developer-guide/architecture/#system-components","title":"System Components","text":""},{"location":"developer-guide/architecture/#1-base-kubernetes-manifests","title":"1. Base Kubernetes Manifests","text":"<p>Located in <code>base/</code>, these provide the foundation:</p> <ul> <li><code>deployment.yaml</code>: Core Community Solid Server deployment</li> <li><code>service.yaml</code>: Kubernetes service configuration</li> <li><code>kustomization.yaml</code>: Base Kustomize configuration</li> </ul>"},{"location":"developer-guide/architecture/#2-overlay-system","title":"2. Overlay System","text":"<p>Environment-specific configurations in <code>overlays/</code>:</p> <ul> <li>with-pvc: Production with storage</li> <li>without-pvc: Stateless production</li> </ul>"},{"location":"developer-guide/architecture/#3-dagger-pipeline","title":"3. Dagger Pipeline","text":"<p>Python-based automation in <code>dagger_pipeline/</code>:</p> <ul> <li>main.py: CLI interface using Click</li> <li>pipeline.py: Core pipeline logic and Dagger functions</li> </ul>"},{"location":"developer-guide/architecture/#4-documentation-system","title":"4. Documentation System","text":"<p>MkDocs-based documentation:</p> <ul> <li>docs/: Source documentation</li> <li>mkdocs.yml: Configuration</li> <li>Auto-generated API docs: From Python docstrings</li> </ul>"},{"location":"developer-guide/architecture/#design-principles","title":"Design Principles","text":""},{"location":"developer-guide/architecture/#1-containerized-everything","title":"1. Containerized Everything","text":"<p>All operations run in containers via Dagger:</p> <ul> <li>Consistent execution environment</li> <li>Reproducible builds</li> <li>No local tool dependencies</li> </ul>"},{"location":"developer-guide/architecture/#2-release-name-strategy","title":"2. Release Name Strategy","text":"<p>Consistent labeling across all resources:</p> <ul> <li><code>app.kubernetes.io/instance</code> labels</li> <li>Environment-specific release names</li> <li>Proper resource isolation</li> </ul>"},{"location":"developer-guide/architecture/#3-version-management","title":"3. Version Management","text":"<p>Centralized version control:</p> <ul> <li>Semantic versioning</li> <li>Consistent across all overlays</li> <li>Automated updates and validation</li> </ul>"},{"location":"developer-guide/architecture/#4-developer-experience","title":"4. Developer Experience","text":"<p>Rich CLI with modern features:</p> <ul> <li>Colored output and progress indicators</li> <li>Verbose mode for debugging</li> </ul>"},{"location":"developer-guide/architecture/#core-technologies","title":"Core Technologies","text":"<ul> <li>Kubernetes: Container orchestration platform</li> <li>Kustomize: Kubernetes configuration management</li> <li>Dagger: Containerized CI/CD pipelines</li> <li>Python: Automation and CLI development</li> </ul>"},{"location":"developer-guide/architecture/#development-tools","title":"Development Tools","text":"<ul> <li>Poetry: Dependency management</li> <li>Click: CLI framework</li> <li>Ruff: Python linting and formatting</li> <li>yamllint: YAML validation</li> <li>MkDocs: Documentation generation</li> </ul>"},{"location":"developer-guide/architecture/#container-images","title":"Container Images","text":"<ul> <li>Community Solid Server: Main application</li> <li>Alpine Linux: Base for utility containers</li> <li>Python: For Dagger pipeline execution</li> </ul>"},{"location":"developer-guide/architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"developer-guide/architecture/#container-security","title":"Container Security","text":"<ul> <li>Non-root user execution</li> <li>Read-only root filesystems</li> <li>Security contexts applied</li> <li>Resource limits enforced</li> </ul>"},{"location":"developer-guide/architecture/#pipeline-security","title":"Pipeline Security","text":"<ul> <li>Isolated container execution</li> <li>No persistent credentials</li> <li>Scan generated manifests</li> <li>Validate security contexts</li> </ul>"},{"location":"developer-guide/architecture/#access-control","title":"Access Control","text":"<ul> <li>RBAC-ready manifests</li> <li>Service account configuration</li> <li>Network policy support</li> <li>Secret management patterns</li> </ul>"},{"location":"developer-guide/architecture/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"developer-guide/architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>Stateless deployment options</li> <li>Load balancer ready services</li> <li>Resource request/limit patterns</li> </ul>"},{"location":"developer-guide/architecture/#performance","title":"Performance","text":"<ul> <li>Dagger caching strategies</li> <li>Efficient container builds</li> <li>Optimized manifest generation</li> </ul>"},{"location":"developer-guide/architecture/#extension-points","title":"Extension Points","text":""},{"location":"developer-guide/architecture/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create overlay directory structure</li> <li>Define kustomization.yaml</li> <li>Add to CLI overlay list</li> <li>Update documentation</li> </ol>"},{"location":"developer-guide/architecture/#custom-pipeline-steps","title":"Custom Pipeline Steps","text":"<ol> <li>Extend pipeline.py with new functions</li> <li>Add CLI commands in main.py</li> <li>Update documentation</li> <li>Add tests</li> </ol>"},{"location":"developer-guide/architecture/#integration-hooks","title":"Integration Hooks","text":"<ul> <li>Pre-commit hooks for development</li> <li>CI/CD pipeline integration</li> <li>Custom validation rules</li> <li>External tool integration</li> </ul>"},{"location":"developer-guide/architecture/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"developer-guide/architecture/#pipeline-metrics","title":"Pipeline Metrics","text":"<ul> <li>Execution time tracking</li> <li>Success/failure rates</li> <li>Resource usage monitoring</li> <li>Cache hit rates</li> </ul>"},{"location":"developer-guide/architecture/#application-metrics","title":"Application Metrics","text":"<ul> <li>Kubernetes resource monitoring</li> <li>Application health checks</li> <li>Performance metrics</li> <li>Error tracking</li> </ul>"},{"location":"developer-guide/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dagger Pipeline internals</li> <li>Read Contributing Guide</li> </ul>"},{"location":"developer-guide/contributing/","title":"Contributing","text":"<p>Guidelines for contributing to the CSS Kustomize project.</p>"},{"location":"developer-guide/contributing/#getting-started","title":"Getting Started","text":""},{"location":"developer-guide/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/your-username/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install development dependencies:</li> </ol> <pre><code>poetry install --with=lint,docs\n</code></pre> <ol> <li>Set up pre-commit hooks:</li> </ol> <pre><code>poetry run pre-commit install\n</code></pre> <ol> <li>Verify setup:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"developer-guide/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a feature branch:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li> <p>Make your changes following the coding standards</p> </li> <li> <p>Run tests and linting:</p> </li> </ol> <pre><code>poetry run dagger-pipeline lint\npoetry run dagger-pipeline validate\n</code></pre> <ol> <li>Commit your changes:</li> </ol> <pre><code>git add .\ngit commit -m \"feat: add new feature\"\n</code></pre>"},{"location":"developer-guide/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"developer-guide/contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all functions</li> <li>Write comprehensive docstrings</li> <li>Use ruff for linting and formatting</li> </ul>"},{"location":"developer-guide/contributing/#yaml-files","title":"YAML Files","text":"<ul> <li>Use 2-space indentation</li> <li>Follow yamllint configuration</li> <li>Use meaningful names and comments</li> </ul>"},{"location":"developer-guide/contributing/#documentation","title":"Documentation","text":"<ul> <li>Write clear, concise documentation</li> <li>Include code examples</li> <li>Update relevant sections</li> </ul>"},{"location":"developer-guide/contributing/#testing","title":"Testing","text":""},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run complete CI pipeline\npoetry run dagger-pipeline ci\n\n# Run specific tests\npoetry run dagger-pipeline lint --python-only\npoetry run dagger-pipeline validate\npoetry run dagger-pipeline security-scan\n</code></pre>"},{"location":"developer-guide/contributing/#adding-tests","title":"Adding Tests","text":"<ul> <li>Add tests for new functionality</li> <li>Ensure good test coverage</li> <li>Test both success and failure cases</li> </ul>"},{"location":"developer-guide/contributing/#documentation_1","title":"Documentation","text":""},{"location":"developer-guide/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Install docs dependencies\npoetry install --only=docs\n\n# Build documentation\npoetry run mkdocs build\n\n# Serve locally\npoetry run mkdocs serve\n</code></pre>"},{"location":"developer-guide/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include practical examples</li> <li>Update navigation in mkdocs.yml</li> <li>Follow existing structure</li> </ul>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"developer-guide/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Ensure all tests pass:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre> <ol> <li> <p>Update documentation if needed</p> </li> <li> <p>Add changelog entry if applicable</p> </li> </ol>"},{"location":"developer-guide/contributing/#submitting","title":"Submitting","text":"<ol> <li>Push your branch:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li> <p>Create pull request with:</p> </li> <li> <p>Clear description of changes</p> </li> <li>Reference to related issues</li> <li> <p>Screenshots if applicable</p> </li> <li> <p>Address review feedback promptly</p> </li> </ol>"},{"location":"developer-guide/contributing/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"developer-guide/contributing/#for-authors","title":"For Authors","text":"<ul> <li>Keep changes focused and small</li> <li>Write clear commit messages</li> <li>Respond to feedback constructively</li> <li>Update based on suggestions</li> </ul>"},{"location":"developer-guide/contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be constructive and helpful</li> <li>Focus on code quality and maintainability</li> <li>Test the changes locally</li> <li>Approve when ready</li> </ul>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":""},{"location":"developer-guide/contributing/#version-updates","title":"Version Updates","text":"<pre><code># Update version across overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Validate changes\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"developer-guide/contributing/#creating-releases","title":"Creating Releases","text":"<ol> <li>Update version numbers</li> <li>Update changelog</li> <li>Create git tag</li> <li>Generate release notes</li> </ol>"},{"location":"developer-guide/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"developer-guide/contributing/#communication","title":"Communication","text":"<ul> <li>Be respectful and inclusive</li> <li>Use clear, professional language</li> <li>Help others learn and grow</li> <li>Share knowledge and experience</li> </ul>"},{"location":"developer-guide/contributing/#issue-reporting","title":"Issue Reporting","text":"<ul> <li>Use issue templates</li> <li>Provide clear reproduction steps</li> <li>Include relevant system information</li> <li>Search existing issues first</li> </ul>"},{"location":"developer-guide/contributing/#getting-help","title":"Getting Help","text":""},{"location":"developer-guide/contributing/#resources","title":"Resources","text":"<ul> <li>Documentation: Read the full documentation</li> <li>Issues: Search existing issues</li> <li>Discussions: Join GitHub discussions</li> <li>Code: Review existing code patterns</li> </ul>"},{"location":"developer-guide/contributing/#contact","title":"Contact","text":"<ul> <li>GitHub Issues: For bugs and feature requests</li> <li>GitHub Discussions: For questions and ideas</li> <li>Pull Requests: For code contributions</li> </ul>"},{"location":"developer-guide/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized through:</p> <ul> <li>GitHub contributor graphs</li> <li>Release notes mentions</li> <li>Documentation credits</li> <li>Community acknowledgments</li> </ul> <p>Thank you for contributing to CSS Kustomize!</p>"},{"location":"developer-guide/dagger-pipeline/","title":"Dagger Pipeline","text":"<p>Deep dive into the Dagger pipeline implementation and internals.</p>"},{"location":"developer-guide/dagger-pipeline/#overview","title":"Overview","text":"<p>The CSS Kustomize project uses Dagger for containerized CI/CD pipelines, providing consistent execution environments and reproducible builds.</p>"},{"location":"developer-guide/dagger-pipeline/#pipeline-architecture","title":"Pipeline Architecture","text":""},{"location":"developer-guide/dagger-pipeline/#core-components","title":"Core Components","text":"<pre><code>@dagger.function\nasync def lint_yaml(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Run YAML linting with yamllint.\"\"\"\n    return await (\n        self.base_container()\n        .with_directory(\"/src\", source)\n        .with_workdir(\"/src\")\n        .with_exec([\"yamllint\", \".\"])\n        .stdout()\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-strategy","title":"Container Strategy","text":"<p>All operations run in isolated containers:</p> <ul> <li>Base Container: Alpine Linux with required tools</li> <li>Tool-Specific Containers: Specialized for each operation</li> <li>Caching: Aggressive caching for performance</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#pipeline-functions","title":"Pipeline Functions","text":""},{"location":"developer-guide/dagger-pipeline/#linting-operations","title":"Linting Operations","text":""},{"location":"developer-guide/dagger-pipeline/#yaml-linting","title":"YAML Linting","text":"<pre><code>async def lint_yaml(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Lint YAML files using yamllint.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#python-linting","title":"Python Linting","text":"<pre><code>async def lint_python(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Lint Python files using ruff.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#markdown-linting","title":"Markdown Linting","text":"<pre><code>async def lint_markdown(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Check Markdown formatting.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#validation-operations","title":"Validation Operations","text":""},{"location":"developer-guide/dagger-pipeline/#kustomize-validation","title":"Kustomize Validation","text":"<pre><code>async def validate_kustomize(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Validate all Kustomize overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#version-validation","title":"Version Validation","text":"<pre><code>async def validate_versions(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Validate version consistency across overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#generation-operations","title":"Generation Operations","text":""},{"location":"developer-guide/dagger-pipeline/#manifest-generation","title":"Manifest Generation","text":"<pre><code>async def generate_manifests(\n    self, \n    source: dagger.Directory,\n    output_dir: str\n) -&gt; dagger.Directory:\n    \"\"\"Generate Kubernetes manifests for all overlays.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#single-overlay-generation","title":"Single Overlay Generation","text":"<pre><code>async def generate_overlay(\n    self,\n    source: dagger.Directory,\n    overlay_name: str\n) -&gt; str:\n    \"\"\"Generate manifest for specific overlay.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#security-operations","title":"Security Operations","text":""},{"location":"developer-guide/dagger-pipeline/#security-scanning","title":"Security Scanning","text":"<pre><code>async def security_scan(self, source: dagger.Directory) -&gt; str:\n    \"\"\"Run security checks on Kustomize configurations.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#generated-manifest-scanning","title":"Generated Manifest Scanning","text":"<pre><code>async def security_scan_generated(\n    self,\n    manifests_dir: dagger.Directory\n) -&gt; str:\n    \"\"\"Scan generated manifests for security issues.\"\"\"\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-images","title":"Container Images","text":""},{"location":"developer-guide/dagger-pipeline/#base-container","title":"Base Container","text":"<pre><code>def base_container(self) -&gt; dagger.Container:\n    \"\"\"Create base container with common tools.\"\"\"\n    return (\n        dag.container()\n        .from_(\"alpine:3.19\")\n        .with_exec([\"apk\", \"add\", \"--no-cache\", \n                   \"python3\", \"py3-pip\", \"kubectl\", \"git\"])\n        .with_exec([\"pip\", \"install\", \"yamllint\", \"ruff\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#specialized-containers","title":"Specialized Containers","text":""},{"location":"developer-guide/dagger-pipeline/#kustomize-container","title":"Kustomize Container","text":"<pre><code>def kustomize_container(self) -&gt; dagger.Container:\n    \"\"\"Container with kubectl and kustomize.\"\"\"\n    return (\n        self.base_container()\n        .with_exec([\"kubectl\", \"version\", \"--client\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#security-scanner-container","title":"Security Scanner Container","text":"<pre><code>def security_container(self) -&gt; dagger.Container:\n    \"\"\"Container with security scanning tools.\"\"\"\n    return (\n        self.base_container()\n        .with_exec([\"pip\", \"install\", \"checkov\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#caching-strategy","title":"Caching Strategy","text":""},{"location":"developer-guide/dagger-pipeline/#layer-caching","title":"Layer Caching","text":"<p>Dagger automatically caches container layers:</p> <ul> <li>Base image layers</li> <li>Package installation layers</li> <li>Tool installation layers</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#volume-caching","title":"Volume Caching","text":"<p>Persistent caches for:</p> <ul> <li>Package manager caches</li> <li>Tool caches</li> <li>Build artifacts</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#cache-keys","title":"Cache Keys","text":"<p>Cache invalidation based on:</p> <ul> <li>Source code changes</li> <li>Dependency changes</li> <li>Tool version changes</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#error-handling","title":"Error Handling","text":""},{"location":"developer-guide/dagger-pipeline/#exception-management","title":"Exception Management","text":"<pre><code>try:\n    result = await self.lint_yaml(source)\nexcept dagger.ExecError as e:\n    logger.error(f\"YAML linting failed: {e}\")\n    raise PipelineError(\"Linting failed\") from e\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>Continue on non-critical failures</li> <li>Aggregate error reporting</li> <li>Detailed error context</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#integration-points","title":"Integration Points","text":""},{"location":"developer-guide/dagger-pipeline/#cli-integration","title":"CLI Integration","text":"<pre><code>@click.command()\n@click.option(\"--verbose\", is_flag=True)\nasync def lint(verbose: bool):\n    \"\"\"Run linting pipeline.\"\"\"\n    async with dagger.Connection() as client:\n        pipeline = CSSKustomizePipeline(client)\n        result = await pipeline.lint_all(source_dir)\n        click.echo(result)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#cicd-integration","title":"CI/CD Integration","text":"<pre><code>async def ci_pipeline(self, source: dagger.Directory) -&gt; bool:\n    \"\"\"Complete CI pipeline.\"\"\"\n    # Run all operations\n    lint_result = await self.lint_all(source)\n    validate_result = await self.validate_all(source)\n    security_result = await self.security_scan_all(source)\n\n    return all([lint_result, validate_result, security_result])\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#performance-optimization","title":"Performance Optimization","text":""},{"location":"developer-guide/dagger-pipeline/#build-optimization","title":"Build Optimization","text":"<ul> <li>Multi-stage container builds</li> <li>Minimal base images</li> <li>Efficient layer ordering</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#execution-optimization","title":"Execution Optimization","text":"<ul> <li>Smart dependency management</li> <li>Resource pooling</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#cache-optimization","title":"Cache Optimization","text":"<ul> <li>Aggressive caching strategies</li> <li>Cache warming techniques</li> <li>Cache invalidation optimization</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"developer-guide/dagger-pipeline/#verbose-mode","title":"Verbose Mode","text":"<pre><code>if verbose:\n    container = container.with_env_variable(\"DAGGER_LOG_LEVEL\", \"debug\")\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#container-inspection","title":"Container Inspection","text":"<pre><code># Debug container state\ndebug_container = (\n    container\n    .with_exec([\"ls\", \"-la\"])\n    .with_exec([\"env\"])\n)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#log-collection","title":"Log Collection","text":"<pre><code># Collect logs from failed operations\nlogs = await container.stderr()\nlogger.error(f\"Operation failed: {logs}\")\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#extension-patterns","title":"Extension Patterns","text":""},{"location":"developer-guide/dagger-pipeline/#adding-new-operations","title":"Adding New Operations","text":"<ol> <li>Define Function:</li> </ol> <pre><code>@dagger.function\nasync def new_operation(self, source: dagger.Directory) -&gt; str:\n    \"\"\"New pipeline operation.\"\"\"\n</code></pre> <ol> <li>Add CLI Command:</li> </ol> <pre><code>@click.command()\nasync def new_command():\n    \"\"\"CLI command for new operation.\"\"\"\n</code></pre> <ol> <li>Integrate with CI:</li> </ol> <pre><code># Add to ci_pipeline function\nnew_result = await self.new_operation(source)\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#custom-containers","title":"Custom Containers","text":"<pre><code>def custom_container(self) -&gt; dagger.Container:\n    \"\"\"Custom container for specific needs.\"\"\"\n    return (\n        dag.container()\n        .from_(\"custom/base:latest\")\n        .with_exec([\"custom-tool\", \"--version\"])\n    )\n</code></pre>"},{"location":"developer-guide/dagger-pipeline/#best-practices","title":"Best Practices","text":""},{"location":"developer-guide/dagger-pipeline/#container-design","title":"Container Design","text":"<ul> <li>Use minimal base images</li> <li>Install only required tools</li> <li>Leverage multi-stage builds</li> <li>Implement proper caching</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#function-design","title":"Function Design","text":"<ul> <li>Keep functions focused and small</li> <li>Use proper error handling</li> <li>Implement comprehensive logging</li> <li>Design for testability</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#performance","title":"Performance","text":"<ul> <li>Implement proper caching</li> <li>Optimize container layers</li> <li>Monitor resource usage</li> </ul>"},{"location":"developer-guide/dagger-pipeline/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Contributing</li> <li>Explore Architecture</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Learn how to configure CSS Kustomize for your environment and needs.</p>"},{"location":"getting-started/configuration/#overview","title":"Overview","text":"<p>CSS Kustomize uses several configuration files and environment variables to customize behavior.</p>"},{"location":"getting-started/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"getting-started/configuration/#poetry-configuration-pyprojecttoml","title":"Poetry Configuration (<code>pyproject.toml</code>)","text":"<p>The main project configuration is in <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry]\nname = \"css-kustomize\"\nversion = \"0.1.0\"\ndescription = \"Kubernetes manifests for Community Solid Server\"\n\n[tool.poetry.scripts]\ndagger-pipeline = \"dagger_pipeline.main:cli\"\n</code></pre>"},{"location":"getting-started/configuration/#yaml-linting-yamllintyml","title":"YAML Linting (<code>.yamllint.yml</code>)","text":"<p>Configure YAML linting rules:</p> <pre><code>extends: default\nrules:\n  line-length:\n    max: 120\n  truthy:\n    allowed-values: ['true', 'false', 'on', 'off']\n</code></pre>"},{"location":"getting-started/configuration/#dagger-configuration-daggerjson","title":"Dagger Configuration (<code>dagger.json</code>)","text":"<p>Dagger engine configuration:</p> <pre><code>{\n  \"name\": \"css-kustomize\",\n  \"sdk\": \"python\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"getting-started/configuration/#dagger-settings","title":"Dagger Settings","text":"<ul> <li><code>DAGGER_LOG_LEVEL</code>: Set logging level (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>)</li> <li><code>DAGGER_CACHE_VOLUME</code>: Custom cache volume name</li> </ul>"},{"location":"getting-started/configuration/#cli-behavior","title":"CLI Behavior","text":"<ul> <li><code>NO_COLOR</code>: Disable colored output</li> <li><code>FORCE_COLOR</code>: Force colored output in non-TTY environments</li> </ul>"},{"location":"getting-started/configuration/#customization","title":"Customization","text":""},{"location":"getting-started/configuration/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create overlay directory in <code>overlays/</code></li> <li>Add <code>kustomization.yaml</code></li> <li>Update CLI to include new overlay</li> </ol>"},{"location":"getting-started/configuration/#modifying-base-resources","title":"Modifying Base Resources","text":"<p>Edit files in the <code>base/</code> directory to change default configurations.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Explore CLI Commands</li> <li>Learn about Kustomize Overlays</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you set up CSS Kustomize on your local development environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing CSS Kustomize, ensure you have the following tools installed:</p>"},{"location":"getting-started/installation/#required-tools","title":"Required Tools","text":"<ul> <li>Python 3.11+: The project requires Python 3.11 or later</li> <li>Poetry: For dependency management and virtual environments</li> <li>Docker: Required for Dagger containerized execution</li> <li>kubectl: For Kubernetes manifest validation and deployment</li> <li>Git: For version control</li> </ul>"},{"location":"getting-started/installation/#optional-tools","title":"Optional Tools","text":"<ul> <li>Kustomize: While not strictly required (Dagger containers include it), having it locally can be helpful</li> <li>yq: For YAML processing and debugging</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-poetry-recommended","title":"Method 1: Poetry (Recommended)","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install Poetry (if not already installed):</li> </ol> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code># Install all dependencies\npoetry install\n\n# Or install only specific groups\npoetry install --only=main,lint\npoetry install --only=docs  # For documentation development\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>poetry run dagger-pipeline --help\n</code></pre>"},{"location":"getting-started/installation/#method-2-development-installation","title":"Method 2: Development Installation","text":"<p>For active development on the CSS Kustomize project:</p> <ol> <li>Clone and enter the repository:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\n</code></pre> <ol> <li>Install in development mode:</li> </ol> <pre><code>poetry install --with=lint,docs\n</code></pre> <ol> <li>Set up pre-commit hooks:</li> </ol> <pre><code>poetry run pre-commit install\n</code></pre> <ol> <li>Run the test suite:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"getting-started/installation/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code># Update package list\nsudo apt update\n\n# Install Python 3.11\nsudo apt install python3.11 python3.11-venv python3-pip\n\n# Install Docker\nsudo apt install docker.io\nsudo usermod -aG docker $USER\nnewgrp docker\n\n# Install kubectl\ncurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install Homebrew (if not already installed)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install required tools\nbrew install python@3.11 docker kubectl poetry\n\n# Start Docker Desktop\nopen /Applications/Docker.app\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Install Python 3.11 from python.org</li> <li>Install Docker Desktop from docker.com</li> <li>Install kubectl using official instructions</li> <li>Install Poetry:    <pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -\n</code></pre></li> </ol>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>After installation, verify everything is working correctly:</p>"},{"location":"getting-started/installation/#1-check-python-version","title":"1. Check Python Version","text":"<pre><code>python --version\n# Should output: Python 3.11.x or later\n</code></pre>"},{"location":"getting-started/installation/#2-check-poetry","title":"2. Check Poetry","text":"<pre><code>poetry --version\n# Should output: Poetry (version 1.x.x)\n</code></pre>"},{"location":"getting-started/installation/#3-check-docker","title":"3. Check Docker","text":"<pre><code>docker --version\n# Should output: Docker version x.x.x\n</code></pre>"},{"location":"getting-started/installation/#4-check-kubectl","title":"4. Check kubectl","text":"<pre><code>kubectl version --client\n# Should output client version information\n</code></pre>"},{"location":"getting-started/installation/#5-test-css-kustomize","title":"5. Test CSS Kustomize","text":"<pre><code>cd css-kustomize\npoetry run dagger-pipeline --help\n# Should display the CLI help\n</code></pre>"},{"location":"getting-started/installation/#6-run-quick-test","title":"6. Run Quick Test","text":"<pre><code># Run a quick linting test\npoetry run dagger-pipeline lint\n\n# Generate a test manifest\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/test-manifest.yaml\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#poetry-not-found","title":"Poetry Not Found","text":"<p>If <code>poetry</code> command is not found after installation:</p> <pre><code># Add Poetry to PATH (Linux/macOS)\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# Or for zsh\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n</code></pre>"},{"location":"getting-started/installation/#docker-permission-denied","title":"Docker Permission Denied","text":"<p>If you get permission denied errors with Docker:</p> <pre><code># Linux: Add user to docker group\nsudo usermod -aG docker $USER\nnewgrp docker\n\n# Test Docker access\ndocker run hello-world\n</code></pre>"},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you have multiple Python versions:</p> <pre><code># Use Poetry with specific Python version\npoetry env use python3.11\n\n# Verify the environment\npoetry env info\n</code></pre>"},{"location":"getting-started/installation/#dagger-connection-issues","title":"Dagger Connection Issues","text":"<p>If Dagger fails to connect:</p> <pre><code># Ensure Docker is running\ndocker ps\n\n# Check Docker daemon\nsudo systemctl status docker  # Linux\nbrew services list | grep docker  # macOS\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check the logs: Run commands with <code>--verbose</code> flag for detailed output</li> <li>Search existing issues: Check GitHub Issues</li> <li>Create a new issue: Include your OS, Python version, and error messages</li> <li>Join discussions: Use GitHub Discussions</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete:</p> <ol> <li>Read the Quick Start Guide to get familiar with basic operations</li> <li>Review Configuration to customize the setup for your needs</li> <li>Explore CLI Commands to understand available operations</li> </ol>"},{"location":"getting-started/installation/#development-environment","title":"Development Environment","text":"<p>For contributors and advanced users, see the Contributing Guide for additional setup steps including:</p> <ul> <li>Development dependencies</li> <li>Testing frameworks</li> <li>Documentation building</li> <li>Code quality tools</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with CSS Kustomize in just a few minutes.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Poetry</li> <li>Docker</li> <li>kubectl</li> </ul> <p>See the Installation Guide for detailed setup instructions.</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<ol> <li>Clone and setup:</li> </ol> <pre><code>git clone https://github.com/taybiz/css-kustomize.git\ncd css-kustomize\npoetry install\n</code></pre> <ol> <li>Run the CI pipeline:</li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre> <ol> <li>Generate manifests:</li> </ol> <pre><code>poetry run dagger-pipeline generate manifests/\n</code></pre> <ol> <li>Deploy to Kubernetes:</li> </ol> <pre><code>kubectl apply -f manifests/with-pvc.yaml\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the CLI Commands guide</li> <li>Explore Kustomize Overlays</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>dagger_pipeline<ul> <li>main</li> <li>pipeline</li> </ul> </li> </ul>"},{"location":"reference/dagger_pipeline/","title":"dagger_pipeline","text":""},{"location":"reference/dagger_pipeline/#dagger_pipeline","title":"<code>dagger_pipeline</code>","text":"<p>Dagger pipeline for CSS Kustomize project automation.</p> <p>This package provides comprehensive automation tools for Kubernetes manifest management using Kustomize, with containerized execution via Dagger for consistent and reproducible builds across different environments.</p>"},{"location":"reference/dagger_pipeline/#dagger_pipeline--key-features","title":"Key Features","text":"<ul> <li>YAML Linting: Comprehensive YAML syntax and style validation</li> <li>Python Code Quality: Automated linting and formatting with ruff</li> <li>Markdown Validation: Format checking and consistency enforcement</li> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Security Scanning: Kubernetes manifest security analysis</li> <li>Version Management: Automated version updates across overlays</li> </ul>"},{"location":"reference/dagger_pipeline/#dagger_pipeline--usage","title":"Usage","text":"<p>The package provides both a CLI interface and programmatic API:</p> <pre><code>from dagger_pipeline import Pipeline\n\n# Create pipeline instance\npipeline = Pipeline(verbose=True)\n\n# Run comprehensive linting\nawait pipeline.run_all_linting()\n\n# Generate manifests\nawait pipeline.generate_all_overlays(\"manifests\")\n</code></pre> <p>For CLI usage, see the <code>main</code> module documentation.</p>"},{"location":"reference/dagger_pipeline/main/","title":"main","text":""},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main","title":"<code>dagger_pipeline.main</code>","text":"<p>Main CLI entry point for Dagger pipeline automation.</p> <p>This module provides the command-line interface for the CSS Kustomize Dagger pipeline, offering comprehensive automation for linting, validation, manifest generation, and deployment workflows. The CLI is built using Click and provides rich console output for better user experience.</p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--pipeline-capabilities","title":"Pipeline Capabilities","text":"<ul> <li>YAML Linting: Comprehensive syntax and style validation with yamllint</li> <li>Python Code Quality: Automated checks and formatting with ruff</li> <li>Markdown Validation: Format checking and consistency enforcement</li> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Version Management: Automated version updates across overlays</li> </ul>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--usage-examples","title":"Usage Examples","text":"<p>Run the complete CI pipeline: <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre></p> <p>Generate manifests for all overlays: <pre><code>poetry run dagger-pipeline generate\n</code></pre></p> <p>Update version across all overlays: <pre><code>poetry run dagger-pipeline version update 1.2.3\n</code></pre></p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main--cli-structure","title":"CLI Structure","text":"<p>The CLI is organized into command groups: - <code>lint</code>: Code quality and validation commands - <code>generate</code>: Manifest generation commands - <code>ci</code>: Complete CI pipeline execution - <code>version</code>: Version management commands - <code>setup</code>: Development environment setup</p>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.build","title":"<code>build(verbose)</code>","text":"<p>Build documentation locally for testing.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef build(verbose: bool):\n    \"\"\"Build documentation locally for testing.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udfd7\ufe0f CSS Kustomize Documentation Build\", style=\"bold blue\"))\n\n    async def run_docs_build():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.build_docs()\n            console.print(\"\ud83c\udf89 Documentation built successfully!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation build failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_build())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.ci","title":"<code>ci(output_dir, verbose)</code>","text":"<p>Run complete CI pipeline (lint, validate, generate).</p> <p>This is the main CI command that executes the full pipeline workflow. It performs all quality checks, and generates manifests.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory where generated manifests will be saved.        Defaults to 'manifests'.</p> required <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during execution.</p> required <p>The CI pipeline includes: 1. Comprehensive linting (YAML, Python, Markdown) 2. Kustomize configuration validation 3. Security scanning of configurations 4. Manifest generation for all overlays 5. Security scanning of generated manifests</p> <p>This command is designed to be run in CI/CD environments to ensure code quality and deployment readiness.</p> <p>Examples:</p> <p>Run complete CI pipeline:     $ poetry run dagger-pipeline ci</p> <p>Run with verbose output:     $ poetry run dagger-pipeline ci --verbose</p> <p>Generate to custom directory:     $ poetry run dagger-pipeline ci --output-dir ./build</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\n    \"--output-dir\", default=\"manifests\", help=\"Output directory for generated manifests\"\n)\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef ci(output_dir: str, verbose: bool):\n    \"\"\"Run complete CI pipeline (lint, validate, generate).\n\n    This is the main CI command that executes the full pipeline workflow.\n    It performs all quality checks, and generates manifests.\n\n    Args:\n        output_dir: Directory where generated manifests will be saved.\n                   Defaults to 'manifests'.\n        verbose: If True, enable detailed output during execution.\n\n    The CI pipeline includes:\n    1. Comprehensive linting (YAML, Python, Markdown)\n    2. Kustomize configuration validation\n    3. Security scanning of configurations\n    4. Manifest generation for all overlays\n    5. Security scanning of generated manifests\n\n    This command is designed to be run in CI/CD environments to ensure\n    code quality and deployment readiness.\n\n    Examples:\n        Run complete CI pipeline:\n            $ poetry run dagger-pipeline ci\n\n        Run with verbose output:\n            $ poetry run dagger-pipeline ci --verbose\n\n        Generate to custom directory:\n            $ poetry run dagger-pipeline ci --output-dir ./build\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83d\ude80 CSS Kustomize CI Pipeline\", style=\"bold blue\"))\n\n    async def run_ci():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            # Run all linting checks\n            await pipeline.run_all_linting()\n            console.print(\"\u2705 Linting completed\", style=\"green\")\n\n            # Generate all overlays\n            await pipeline.generate_all_overlays(output_dir)\n            console.print(\"\u2705 Manifest generation completed\", style=\"green\")\n\n            console.print(\"\ud83c\udf89 Complete CI pipeline passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c CI pipeline failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_ci())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.cli","title":"<code>cli()</code>","text":"<p>CSS Kustomize Dagger Pipeline - Comprehensive automation for linting, validation, and deployment.</p> <p>This CLI provides a comprehensive suite of tools for managing Kubernetes manifests using Kustomize, with automated linting, validation, and deployment capabilities powered by Dagger for containerized execution.</p> <p>The pipeline ensures code quality, and consistent deployment practices across different environments and overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@click.group()\n@click.version_option()\ndef cli():\n    \"\"\"CSS Kustomize Dagger Pipeline - Comprehensive automation for linting, validation, and deployment.\n\n    This CLI provides a comprehensive suite of tools for managing Kubernetes manifests\n    using Kustomize, with automated linting, validation, and deployment capabilities\n    powered by Dagger for containerized execution.\n\n    The pipeline ensures code quality, and consistent deployment\n    practices across different environments and overlays.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.delete_version","title":"<code>delete_version(version, verbose)</code>","text":"<p>Delete a specific documentation version.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.argument(\"version\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef delete_version(version: str, verbose: bool):\n    \"\"\"Delete a specific documentation version.\"\"\"\n\n    console.print(\n        Panel.fit(\"\ud83d\uddd1\ufe0f CSS Kustomize Documentation Version Deletion\", style=\"bold blue\")\n    )\n\n    async def run_delete_version():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.delete_doc_version(version)\n\n        except Exception as e:\n            console.print(f\"\u274c Failed to delete version: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_delete_version())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.deploy","title":"<code>deploy(version, alias, set_default, title, verbose)</code>","text":"<p>Deploy documentation with version management using mike.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--version\", help=\"Version to deploy (defaults to project version)\")\n@click.option(\"--alias\", default=\"latest\", help=\"Version alias (default: latest)\")\n@click.option(\"--set-default\", is_flag=True, help=\"Set this version as default\")\n@click.option(\"--title\", help=\"Version title for display (defaults to version)\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef deploy(\n    version: str | None, alias: str, set_default: bool, title: str | None, verbose: bool\n):\n    \"\"\"Deploy documentation with version management using mike.\"\"\"\n\n    console.print(\n        Panel.fit(\"\ud83d\udcda CSS Kustomize Documentation Deployment\", style=\"bold blue\")\n    )\n\n    async def run_docs_deploy():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.deploy_docs(version, alias, set_default, title)\n            console.print(\"\ud83c\udf89 Documentation deployed successfully!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation deployment failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_deploy())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.docs","title":"<code>docs()</code>","text":"<p>Documentation building and deployment commands.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.group()\ndef docs():\n    \"\"\"Documentation building and deployment commands.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.generate","title":"<code>generate(overlay, output_dir, verbose)</code>","text":"<p>Generate Kustomize manifests for overlays.</p> <p>This command uses Kustomize to build and generate Kubernetes manifests from the configured overlays. It can generate manifests for a specific overlay or all available overlays.</p> <p>Parameters:</p> Name Type Description Default <code>overlay</code> <code>str | None</code> <p>Name of specific overlay to generate (e.g., 'with-pvc', 'with-pvc').     If None, generates manifests for all overlays.</p> required <code>output_dir</code> <code>str</code> <p>Directory where generated manifests will be saved.        Defaults to 'manifests'.</p> required <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during generation.</p> required <p>The generated manifests include all Kubernetes resources defined in the base configuration and modified by the overlay-specific patches and configurations.</p> <p>Examples:</p> <p>Generate all overlays:     $ poetry run dagger-pipeline generate</p> <p>Generate specific overlay:     $ poetry run dagger-pipeline generate --overlay with-pvc</p> <p>Generate to custom directory:     $ poetry run dagger-pipeline generate --output-dir ./output</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--overlay\", help=\"Specific overlay to generate (e.g., with-pvc)\")\n@click.option(\n    \"--output-dir\", default=\"manifests\", help=\"Output directory for generated manifests\"\n)\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef generate(overlay: str | None, output_dir: str, verbose: bool):\n    \"\"\"Generate Kustomize manifests for overlays.\n\n    This command uses Kustomize to build and generate Kubernetes manifests\n    from the configured overlays. It can generate manifests for a specific\n    overlay or all available overlays.\n\n    Args:\n        overlay: Name of specific overlay to generate (e.g., 'with-pvc', 'with-pvc').\n                If None, generates manifests for all overlays.\n        output_dir: Directory where generated manifests will be saved.\n                   Defaults to 'manifests'.\n        verbose: If True, enable detailed output during generation.\n\n    The generated manifests include all Kubernetes resources defined in the\n    base configuration and modified by the overlay-specific patches and\n    configurations.\n\n    Examples:\n        Generate all overlays:\n            $ poetry run dagger-pipeline generate\n\n        Generate specific overlay:\n            $ poetry run dagger-pipeline generate --overlay with-pvc\n\n        Generate to custom directory:\n            $ poetry run dagger-pipeline generate --output-dir ./output\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udfd7\ufe0f CSS Kustomize Generation Pipeline\", style=\"bold blue\"))\n\n    async def run_generate():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if overlay:\n                await pipeline.generate_overlay(overlay, output_dir)\n            else:\n                await pipeline.generate_all_overlays(output_dir)\n\n            console.print(\"\ud83c\udf89 Manifest generation completed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Generation failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_generate())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.lint","title":"<code>lint(verbose)</code>","text":"<p>Run comprehensive linting and validation checks.</p> <p>This command performs various code quality and configuration validation checks on the project. By default, it runs all available linting checks, but can be configured to run specific checks only.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, enable detailed output during execution</p> required <p>The linting includes: - YAML syntax and style validation - Python code quality checks (syntax, style, imports) - Python code formatting validation - Markdown formatting validation - Kustomize configuration validation - Security scanning of Kubernetes manifests</p> <p>Examples:</p> <p>Run all linting checks:     $ poetry run dagger-pipeline lint</p> <p>Run with verbose output:     $ poetry run dagger-pipeline lint --verbose</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef lint(\n    verbose: bool,\n):\n    \"\"\"Run comprehensive linting and validation checks.\n\n    This command performs various code quality and configuration validation checks\n    on the project. By default, it runs all available linting checks, but can be\n    configured to run specific checks only.\n\n    Args:\n        verbose: If True, enable detailed output during execution\n\n    The linting includes:\n    - YAML syntax and style validation\n    - Python code quality checks (syntax, style, imports)\n    - Python code formatting validation\n    - Markdown formatting validation\n    - Kustomize configuration validation\n    - Security scanning of Kubernetes manifests\n\n    Examples:\n        Run all linting checks:\n            $ poetry run dagger-pipeline lint\n\n        Run with verbose output:\n            $ poetry run dagger-pipeline lint --verbose\n    \"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udd0d CSS Kustomize Linting Pipeline\", style=\"bold blue\"))\n\n    async def run_lint():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.run_all_linting()\n\n            console.print(\"\ud83c\udf89 All linting checks passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Linting failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_lint())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.list_versions","title":"<code>list_versions(verbose)</code>","text":"<p>List all deployed documentation versions.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef list_versions(verbose: bool):\n    \"\"\"List all deployed documentation versions.\"\"\"\n\n    console.print(\n        Panel.fit(\"\ud83d\udccb CSS Kustomize Documentation Versions\", style=\"bold blue\")\n    )\n\n    async def run_list_versions():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.list_doc_versions()\n\n        except Exception as e:\n            console.print(f\"\u274c Failed to list versions: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_list_versions())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.report","title":"<code>report(verbose)</code>","text":"<p>Generate version report showing current versions across overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef report(verbose: bool):\n    \"\"\"Generate version report showing current versions across overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udcca CSS Kustomize Version Report\", style=\"bold blue\"))\n\n    async def run_version_report():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.generate_version_report()\n\n        except Exception as e:\n            console.print(f\"\u274c Version report failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_report())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.serve","title":"<code>serve(port, verbose)</code>","text":"<p>Serve documentation locally for development.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@docs.command()\n@click.option(\"--port\", default=8000, help=\"Port to serve documentation on\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef serve(port: int, verbose: bool):\n    \"\"\"Serve documentation locally for development.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udf10 CSS Kustomize Documentation Server\", style=\"bold blue\"))\n\n    async def run_docs_serve():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.serve_docs(port)\n\n        except Exception as e:\n            console.print(f\"\u274c Documentation server failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_docs_serve())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.setup","title":"<code>setup(verbose)</code>","text":"<p>Set up development environment and install dependencies.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef setup(verbose: bool):\n    \"\"\"Set up development environment and install dependencies.\"\"\"\n\n    console.print(Panel.fit(\"\u2699\ufe0f CSS Kustomize Setup\", style=\"bold blue\"))\n\n    async def run_setup():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.setup_environment()\n            console.print(\"\ud83c\udf89 Environment setup completed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Setup failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_setup())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.update","title":"<code>update(new_version, overlay, dry_run, verbose)</code>","text":"<p>Update image tags and version labels across overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.argument(\"new_version\")\n@click.option(\n    \"--overlay\", help=\"Update specific overlay only (e.g., with-base, with-pvc)\"\n)\n@click.option(\n    \"--dry-run\", is_flag=True, help=\"Show what would be changed without making changes\"\n)\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef update(new_version: str, overlay: str | None, dry_run: bool, verbose: bool):\n    \"\"\"Update image tags and version labels across overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83c\udff7\ufe0f CSS Kustomize Version Update\", style=\"bold blue\"))\n\n    async def run_version_update():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            if overlay:\n                await pipeline.update_overlay_version(overlay, new_version, dry_run)\n            else:\n                await pipeline.update_all_versions(new_version, dry_run)\n\n            if dry_run:\n                console.print(\n                    \"\ud83d\udd0d Dry run completed. No changes were made.\", style=\"bold yellow\"\n                )\n            else:\n                console.print(\n                    f\"\ud83c\udf89 Version updated to {new_version}!\", style=\"bold green\"\n                )\n\n        except Exception as e:\n            console.print(f\"\u274c Version update failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_update())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.validate","title":"<code>validate(verbose)</code>","text":"<p>Validate version consistency across all overlays.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@version.command()\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Enable verbose output\")\ndef validate(verbose: bool):\n    \"\"\"Validate version consistency across all overlays.\"\"\"\n\n    console.print(Panel.fit(\"\ud83d\udd0d CSS Kustomize Version Validation\", style=\"bold blue\"))\n\n    async def run_version_validate():\n        pipeline = Pipeline(verbose=verbose)\n\n        try:\n            await pipeline.validate_version_consistency()\n            console.print(\"\ud83c\udf89 Version validation passed!\", style=\"bold green\")\n\n        except Exception as e:\n            console.print(f\"\u274c Version validation failed: {e}\", style=\"bold red\")\n            sys.exit(1)\n\n    asyncio.run(run_version_validate())\n</code></pre>"},{"location":"reference/dagger_pipeline/main/#dagger_pipeline.main.version","title":"<code>version()</code>","text":"<p>Version management commands for image tags and labels.</p> Source code in <code>dagger_pipeline/main.py</code> <pre><code>@cli.group()\ndef version():\n    \"\"\"Version management commands for image tags and labels.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/","title":"pipeline","text":""},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline","title":"<code>dagger_pipeline.pipeline</code>","text":"<p>Core Dagger pipeline implementation for CSS Kustomize automation.</p> <p>This module contains the Pipeline class which implements all the core functionality for the CSS Kustomize Dagger automation pipeline. It provides methods for linting, validation, manifest generation, and version management.</p> <p>The pipeline uses Dagger for containerized execution, ensuring consistent and reproducible builds across different environments. All operations are performed in isolated containers with the necessary tools and dependencies.</p>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--key-features","title":"Key Features","text":"<ul> <li>Kustomize Integration: Configuration validation and manifest generation</li> <li>Version Management: Automated version updates across overlays</li> <li>Rich Console Output: Progress indicators and detailed feedback</li> </ul>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--usage-example","title":"Usage Example","text":"<p>Basic usage of the Pipeline class:</p> <pre><code>pipeline = Pipeline(verbose=True)\nawait pipeline.run_all_linting()\nawait pipeline.generate_all_overlays(\"manifests\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline--container-architecture","title":"Container Architecture","text":"<p>The pipeline uses specialized containers for different operations: - Python Container: Poetry-based environment for Python and Markdown linting - Kustomize Container: Alpine-based environment with Kustomize CLI - YAML Container: Alpine-based environment with yq for YAML processing</p>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>Main pipeline class for CSS Kustomize automation.</p> <p>This class orchestrates all pipeline operations including linting, validation, and manifest generation. It uses Dagger for containerized execution to ensure consistent and reproducible builds.</p> <p>Attributes:</p> Name Type Description <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output during operations.</p> <code>project_root</code> <code>Path</code> <p>Path to the project root directory.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>class Pipeline:\n    \"\"\"Main pipeline class for CSS Kustomize automation.\n\n    This class orchestrates all pipeline operations including linting, validation,\n    and manifest generation. It uses Dagger for containerized\n    execution to ensure consistent and reproducible builds.\n\n    Attributes:\n        verbose (bool): Whether to enable verbose output during operations.\n        project_root (Path): Path to the project root directory.\n    \"\"\"\n\n    def __init__(self, verbose: bool = False):\n        \"\"\"Initialize the Pipeline instance.\n\n        Args:\n            verbose: If True, enables detailed output during pipeline execution.\n                    This includes container build logs, command outputs, and\n                    detailed progress information.\n        \"\"\"\n        self.verbose = verbose\n        self.project_root = Path.cwd()\n\n    def _get_client(self) -&gt; dagger.Connection:\n        \"\"\"Get Dagger client connection.\n\n        Creates and configures a Dagger client connection for containerized execution.\n        If verbose mode is enabled, configures the client to output detailed logs.\n\n        Returns:\n            dagger.Connection: Configured Dagger client connection.\n        \"\"\"\n        config = dagger.Config()\n        if self.verbose:\n            config = dagger.Config(log_output=console.file)\n        return dagger.Connection(config)\n\n    async def _get_python_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get Python container with Poetry and dependencies installed.\n\n        Creates a containerized Python environment with Poetry package manager\n        and installs the project's linting dependencies. This container is used\n        for all Python-related operations including linting, formatting, and\n        markdown validation.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Python container with Poetry and lint dependencies.\n\n        The container includes:\n        - Python 3.11 slim base image\n        - System packages: curl, git\n        - Poetry package manager\n        - Project source code mounted at /src\n        - Lint dependencies installed via Poetry\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"python:3.11-slim\")\n            .with_exec([\"apt-get\", \"update\"])\n            .with_exec([\"apt-get\", \"install\", \"-y\", \"curl\", \"git\"])\n            .with_exec([\"pip\", \"install\", \"poetry\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n            .with_exec([\"poetry\", \"config\", \"virtualenvs.create\", \"false\"])\n            .with_exec([\"poetry\", \"install\", \"--only=lint\"])\n        )\n\n    async def _get_kustomize_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get container with Kustomize installed.\n\n        Creates a containerized environment with Kustomize CLI tool for building\n        and validating Kubernetes manifests. This container is used for all\n        Kustomize-related operations including validation and manifest generation.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Alpine container with Kustomize installed.\n\n        The container includes:\n        - Alpine Linux base image\n        - System packages: curl, bash\n        - Latest Kustomize CLI tool\n        - Project source code mounted at /src\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"alpine:latest\")\n            .with_exec([\"apk\", \"add\", \"--no-cache\", \"curl\", \"bash\"])\n            .with_exec(\n                [\n                    \"sh\",\n                    \"-c\",\n                    \"curl -s https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh | bash\",  # noqa: E501\n                ]\n            )\n            .with_exec([\"mv\", \"kustomize\", \"/usr/local/bin/\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n        )\n\n    async def lint_yaml(self) -&gt; None:\n        \"\"\"Run YAML linting using yamllint.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running YAML linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            result = await container.with_exec(\n                [\"poetry\", \"run\", \"yamllint\", \".\"]\n            ).stdout()\n\n            if self.verbose:\n                console.print(result)\n\n            console.print(\"\u2705 YAML linting passed\", style=\"green\")\n\n    async def lint_python(self) -&gt; None:\n        \"\"\"Run Python linting and formatting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running Python linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            # Run ruff check\n            await container.with_exec([\"poetry\", \"run\", \"ruff\", \"check\", \".\"]).stdout()\n\n            # Run ruff format check\n            await container.with_exec(\n                [\"poetry\", \"run\", \"ruff\", \"format\", \"--check\", \".\"]\n            ).stdout()\n\n            console.print(\"\u2705 Python linting passed\", style=\"green\")\n\n    async def lint_markdown(self) -&gt; None:\n        \"\"\"Run Markdown linting and formatting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running Markdown linting...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            # Check if there are any markdown files to lint\n            try:\n                # Find markdown files\n                md_files_result = await container.with_exec(\n                    [\n                        \"find\",\n                        \".\",\n                        \"-name\",\n                        \"*.md\",\n                        \"-type\",\n                        \"f\",\n                        \"!\",\n                        \"-path\",\n                        \"./.venv/*\",\n                        \"!\",\n                        \"-path\",\n                        \"./node_modules/*\",\n                    ]\n                ).stdout()\n\n                md_files = [\n                    f.strip() for f in md_files_result.strip().split(\"\\n\") if f.strip()\n                ]\n\n                if not md_files:\n                    console.print(\"\ud83d\udcdd No markdown files found to lint\", style=\"yellow\")\n                    return\n\n                if self.verbose:\n                    console.print(f\"Found {len(md_files)} markdown files to check\")\n\n                # Run mdformat check (dry-run to validate formatting)\n                await container.with_exec(\n                    [\"poetry\", \"run\", \"mdformat\", \"--check\"] + md_files\n                ).stdout()\n\n                console.print(\"\u2705 Markdown linting passed\", style=\"green\")\n\n            except Exception as e:\n                console.print(\n                    f\"\u274c Markdown formatting issues found: {str(e)}\", style=\"red\"\n                )\n                raise Exception(\n                    \"Markdown files need formatting. Run 'poetry run mdformat .' to fix.\"\n                ) from e\n\n    async def validate_kustomize(self) -&gt; None:\n        \"\"\"Validate Kustomize configurations.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Validating Kustomize configurations...\")\n\n        async with self._get_client() as client:\n            container = await self._get_kustomize_container(client)\n\n            # Validate base configuration\n            await container.with_exec([\"kustomize\", \"build\", \"base/\"]).stdout()\n\n            # Validate overlays\n            overlays_dir = self.project_root / \"overlays\"\n            if overlays_dir.exists():\n                for overlay_path in overlays_dir.iterdir():\n                    if overlay_path.is_dir():\n                        overlay_name = overlay_path.name\n                        if self.verbose:\n                            console.print(f\"Validating overlay: {overlay_name}\")\n\n                        await container.with_exec(\n                            [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n                        ).stdout()\n\n            console.print(\"\u2705 Kustomize validation passed\", style=\"green\")\n\n    async def generate_overlay(self, overlay_name: str, output_dir: str) -&gt; None:\n        \"\"\"Generate manifest for a specific overlay.\"\"\"\n        if self.verbose:\n            console.print(f\"\ud83c\udfd7\ufe0f Generating overlay: {overlay_name}\")\n\n        overlay_path = self.project_root / \"overlays\" / overlay_name\n        if not overlay_path.exists():\n            raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n        async with self._get_client() as client:\n            container = await self._get_kustomize_container(client)\n\n            # Generate manifest\n            manifest_content = await container.with_exec(\n                [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n            ).stdout()\n\n            # Write to output directory\n            output_path = Path(output_dir)\n            output_path.mkdir(exist_ok=True)\n\n            manifest_file = output_path / f\"{overlay_name}.yaml\"\n            manifest_file.write_text(manifest_content)\n\n            if self.verbose:\n                console.print(f\"Generated manifest: {manifest_file}\")\n\n    async def generate_all_overlays(self, output_dir: str) -&gt; None:\n        \"\"\"Generate manifests for all overlays.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83c\udfd7\ufe0f Generating all overlays...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                await self.generate_overlay(overlay_path.name, output_dir)\n\n        console.print(\"\u2705 All overlays generated\", style=\"green\")\n\n    async def run_all_linting(self) -&gt; None:\n        \"\"\"Run all linting checks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running comprehensive linting...\")\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            task1 = progress.add_task(\"YAML linting...\", total=None)\n            await self.lint_yaml()\n            progress.update(task1, completed=True)\n\n            task2 = progress.add_task(\"Python linting...\", total=None)\n            await self.lint_python()\n            progress.update(task2, completed=True)\n\n            task3 = progress.add_task(\"Markdown linting...\", total=None)\n            await self.lint_markdown()\n            progress.update(task3, completed=True)\n\n            task4 = progress.add_task(\"Kustomize validation...\", total=None)\n            await self.validate_kustomize()\n            progress.update(task4, completed=True)\n\n        console.print(\"\u2705 All linting checks completed\", style=\"green\")\n\n    async def setup_environment(self) -&gt; None:\n        \"\"\"Set up development environment.\"\"\"\n        if self.verbose:\n            console.print(\"\u2699\ufe0f Setting up development environment...\")\n\n        async with self._get_client() as client:\n            # Install Python dependencies\n            container = await self._get_python_container(client)\n\n            # Install pre-commit hooks\n            await container.with_exec(\n                [\"poetry\", \"run\", \"pre-commit\", \"install\"]\n            ).stdout()\n\n            console.print(\"\u2705 Development environment setup completed\", style=\"green\")\n\n    async def run_pre_commit(self) -&gt; None:\n        \"\"\"Run pre-commit hooks.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Running pre-commit hooks...\")\n\n        async with self._get_client() as client:\n            container = await self._get_python_container(client)\n\n            await container.with_exec(\n                [\"poetry\", \"run\", \"pre-commit\", \"run\", \"--all-files\"]\n            ).stdout()\n\n            console.print(\"\u2705 Pre-commit hooks passed\", style=\"green\")\n\n    async def _get_yaml_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get container with yq for YAML processing.\"\"\"\n        return (\n            client.container()\n            .from_(\"alpine:latest\")\n            .with_exec([\"apk\", \"add\", \"--no-cache\", \"curl\", \"bash\"])\n            .with_exec(\n                [\n                    \"sh\",\n                    \"-c\",\n                    \"curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq &amp;&amp; chmod +x /usr/local/bin/yq\",\n                ]\n            )\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n        )\n\n    def _validate_version_format(self, version: str) -&gt; bool:\n        \"\"\"Validate semantic version format.\"\"\"\n\n        pattern = r\"^[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9.-]+)?$\"\n        return bool(re.match(pattern, version))\n\n    async def update_overlay_version(\n        self, overlay_name: str, version: str, dry_run: bool = False\n    ) -&gt; None:\n        \"\"\"Update version for a specific overlay.\"\"\"\n        if not self._validate_version_format(version):\n            raise Exception(\n                f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\"\n            )\n\n        overlay_path = self.project_root / \"overlays\" / overlay_name\n        if not overlay_path.exists():\n            raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n        kustomization_file = overlay_path / \"kustomization.yaml\"\n        if not kustomization_file.exists():\n            raise Exception(f\"Kustomization file not found: {kustomization_file}\")\n\n        if self.verbose:\n            console.print(f\"\ud83c\udff7\ufe0f Processing overlay: {overlay_name}\")\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n\n            # Read current values for dry run\n            if dry_run:\n                current_tag_result = await container.with_exec(\n                    [\n                        \"yq\",\n                        '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                current_tag = (\n                    current_tag_result.strip()\n                    if current_tag_result.strip() != \"null\"\n                    else \"not set\"\n                )\n\n                current_version_result = await container.with_exec(\n                    [\n                        \"yq\",\n                        '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                current_version = (\n                    current_version_result.strip()\n                    if current_version_result.strip() != \"null\"\n                    else \"not set\"\n                )\n\n                console.print(\n                    f\"  [DRY RUN] Would update image tag from '{current_tag}' to '{version}'\"\n                )\n                console.print(\n                    f\"  [DRY RUN] Would update version label from '{current_version}' to '{version}'\"\n                )\n                return\n\n            # Update image tag\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'.images[] |= select(.name == \"docker.io/solidproject/community-server\").newTag = \"{version}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            # Update version label\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'.labels[0].pairs.\"app.kubernetes.io/version\" = \"{version}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            # Update version patch if it exists\n            patch_check = await container.with_exec(\n                [\n                    \"yq\",\n                    '.patches[] | select(.target.kind == \"Deployment\") | .patch',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n\n            if \"app.kubernetes.io~1version\" in patch_check:\n                await container.with_exec(\n                    [\n                        \"yq\",\n                        \"-i\",\n                        f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) |= sub(\"value: \\\\\"[^\\\\\"]*\\\\\"\"; \"value: \\\\\"{version}\\\\\"\"; \"g\")',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                console.print(f\"  \u2705 Updated deployment version patch to: {version}\")\n            else:\n                # Add version patch if it doesn't exist\n                patch_content = f'      - op: add\\\\n        path: /spec/template/metadata/labels/app.kubernetes.io~1version\\\\n        value: \\\\\"{version}\\\\\"'\n                await container.with_exec(\n                    [\n                        \"yq\",\n                        \"-i\",\n                        f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) += \"\\\\n{patch_content}\"',\n                        f\"overlays/{overlay_name}/kustomization.yaml\",\n                    ]\n                ).stdout()\n                console.print(f\"  \u2705 Added deployment version patch: {version}\")\n\n            # Copy updated file back to host\n            updated_content = await container.file(\n                f\"overlays/{overlay_name}/kustomization.yaml\"\n            ).contents()\n            kustomization_file.write_text(updated_content)\n\n            console.print(f\"  \u2705 Updated image tag to: {version}\")\n            console.print(f\"  \u2705 Updated version label to: {version}\")\n\n    async def update_all_versions(self, version: str, dry_run: bool = False) -&gt; None:\n        \"\"\"Update version for all overlays.\"\"\"\n        if not self._validate_version_format(version):\n            raise Exception(\n                f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\"\n            )\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n        if not overlay_names:\n            console.print(\"No overlays found to update\", style=\"yellow\")\n            return\n\n        for overlay_name in overlay_names:\n            await self.update_overlay_version(overlay_name, version, dry_run)\n\n        if not dry_run:\n            console.print(\n                f\"\u2705 Updated {len(overlay_names)} overlays to version: {version}\"\n            )\n\n    async def validate_version_consistency(self) -&gt; None:\n        \"\"\"Validate version consistency across all overlays.\n\n        This validates that:\n        - Image tags are present and valid (CSS application version)\n        - Version labels are present and valid (project version from pyproject.toml)\n        - Both are consistently applied across all overlays\n\n        Note: Image tags and version labels are intentionally independent -\n        image tags represent the CSS application version while version labels\n        represent the project/tooling version.\n        \"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udd0d Validating version consistency...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        # Get expected project version from pyproject.toml\n        expected_project_version = await self._get_project_version()\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n            issues = []\n\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                    # Get image tag\n                    try:\n                        image_tag_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        image_tag = (\n                            image_tag_result.strip()\n                            if image_tag_result.strip() != \"null\"\n                            else None\n                        )\n                    except:\n                        image_tag = None\n\n                    # Get version label\n                    try:\n                        version_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        version_label = (\n                            version_label_result.strip()\n                            if version_label_result.strip() != \"null\"\n                            else None\n                        )\n                    except:\n                        version_label = None\n\n                    # Validate image tag presence\n                    if not image_tag:\n                        issues.append(f\"{overlay_name}: missing image tag\")\n                    elif not self._validate_version_format(image_tag):\n                        issues.append(\n                            f\"{overlay_name}: invalid image tag format '{image_tag}'\"\n                        )\n\n                    # Validate version label presence and consistency with project version\n                    if not version_label:\n                        issues.append(f\"{overlay_name}: missing version label\")\n                    elif version_label != expected_project_version:\n                        issues.append(\n                            f\"{overlay_name}: version label '{version_label}' != project version '{expected_project_version}'\"\n                        )\n\n            if issues:\n                console.print(\"\u274c Version consistency issues found:\", style=\"red\")\n                for issue in issues:\n                    console.print(f\"  \u2022 {issue}\", style=\"red\")\n                raise Exception(f\"Found {len(issues)} version consistency issues\")\n\n            console.print(\"\u2705 Version consistency validation passed\", style=\"green\")\n\n    async def generate_version_report(self) -&gt; None:\n        \"\"\"Generate a report of current versions across all overlays.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udcca Generating version report...\")\n\n        overlays_dir = self.project_root / \"overlays\"\n        if not overlays_dir.exists():\n            console.print(\"No overlays directory found\", style=\"yellow\")\n            return\n\n        async with self._get_client() as client:\n            container = await self._get_yaml_container(client)\n\n            console.print(\"\\n\ud83d\udccb Version Report\", style=\"bold blue\")\n            console.print(\"=\" * 50)\n\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                    # Get image tag\n                    try:\n                        image_tag_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        image_tag = (\n                            image_tag_result.strip()\n                            if image_tag_result.strip() != \"null\"\n                            else \"not set\"\n                        )\n                    except:\n                        image_tag = \"not set\"\n\n                    # Get version label\n                    try:\n                        version_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        version_label = (\n                            version_label_result.strip()\n                            if version_label_result.strip() != \"null\"\n                            else \"not set\"\n                        )\n                    except:\n                        version_label = \"not set\"\n\n                    # Get instance label for context\n                    try:\n                        instance_label_result = await container.with_exec(\n                            [\n                                \"yq\",\n                                '.labels[0].pairs.\"app.kubernetes.io/instance\"',\n                                kustomization_file,\n                            ]\n                        ).stdout()\n                        instance_label = (\n                            instance_label_result.strip()\n                            if instance_label_result.strip() != \"null\"\n                            else \"not set\"\n                        )\n                    except:\n                        instance_label = \"not set\"\n\n                    # Display overlay info\n                    console.print(f\"\\n\ud83c\udff7\ufe0f Overlay: {overlay_name}\", style=\"bold\")\n                    console.print(f\"   Instance: {instance_label}\")\n                    console.print(f\"   Image Tag: {image_tag}\")\n                    console.print(f\"   Version Label: {version_label}\")\n\n                    # Check completeness (both should be present but independent)\n                    if image_tag != \"not set\" and version_label != \"not set\":\n                        console.print(\"   Status: \u2705 Complete\", style=\"green\")\n                    else:\n                        missing = []\n                        if image_tag == \"not set\":\n                            missing.append(\"image tag\")\n                        if version_label == \"not set\":\n                            missing.append(\"version label\")\n                        console.print(\n                            f\"   Status: \u26a0\ufe0f Missing {', '.join(missing)}\", style=\"yellow\"\n                        )\n\n            console.print(\"\\n\" + \"=\" * 50)\n            console.print(\"\ud83d\udcca Report completed\", style=\"bold blue\")\n\n    async def _get_docs_container(self, client: dagger.Client) -&gt; dagger.Container:\n        \"\"\"Get Python container with documentation dependencies installed.\n\n        Creates a containerized Python environment with Poetry package manager\n        and installs the project's documentation dependencies including MkDocs,\n        mike, and related tools.\n\n        Args:\n            client: Dagger client instance for container operations.\n\n        Returns:\n            dagger.Container: Configured Python container with docs dependencies.\n        \"\"\"\n        return (\n            client.container()\n            .from_(\"python:3.11-slim\")\n            .with_exec([\"apt-get\", \"update\"])\n            .with_exec([\"apt-get\", \"install\", \"-y\", \"curl\", \"git\"])\n            .with_exec([\"pip\", \"install\", \"poetry\"])\n            .with_directory(\"/src\", client.host().directory(\".\"))\n            .with_workdir(\"/src\")\n            .with_exec([\"poetry\", \"config\", \"virtualenvs.create\", \"false\"])\n            .with_exec([\"poetry\", \"install\", \"--with=docs\"])\n        )\n\n    async def _get_project_version(self) -&gt; str:\n        \"\"\"Get the current project version from pyproject.toml.\"\"\"\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n            version_result = await container.with_exec(\n                [\"poetry\", \"version\", \"--short\"]\n            ).stdout()\n            return version_result.strip()\n\n    async def build_docs(self) -&gt; None:\n        \"\"\"Build documentation locally using MkDocs.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83c\udfd7\ufe0f Building documentation...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            # Build documentation\n            await container.with_exec(\n                [\"poetry\", \"run\", \"mkdocs\", \"build\", \"--strict\"]\n            ).stdout()\n\n            # Copy built site back to host\n            site_dir = self.project_root / \"site\"\n            site_dir.mkdir(exist_ok=True)\n\n            # Export the built site\n            built_site = container.directory(\"site\")\n            await built_site.export(str(site_dir))\n\n            console.print(\"\u2705 Documentation built successfully\", style=\"green\")\n            console.print(f\"\ud83d\udcc1 Built site available at: {site_dir}\")\n\n    async def serve_docs(self, port: int = 8000) -&gt; None:\n        \"\"\"Serve documentation locally for development.\"\"\"\n        if self.verbose:\n            console.print(f\"\ud83c\udf10 Starting documentation server on port {port}...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            console.print(\n                f\"\ud83d\udcda Documentation server starting at http://localhost:{port}\"\n            )\n            console.print(\"Press Ctrl+C to stop the server\")\n\n            # Serve documentation (this will run until interrupted)\n            await container.with_exec(\n                [\"poetry\", \"run\", \"mkdocs\", \"serve\", \"--dev-addr\", f\"0.0.0.0:{port}\"]\n            ).stdout()\n\n    async def deploy_docs(\n        self,\n        version: str | None = None,\n        alias: str = \"latest\",\n        set_default: bool = False,\n        title: str | None = None,\n    ) -&gt; None:\n        \"\"\"Deploy documentation with version management using mike.\n\n        Args:\n            version: Version to deploy. If None, uses project version from pyproject.toml\n            alias: Version alias (default: \"latest\")\n            set_default: Whether to set this version as the default\n            title: Version title for display. If None, uses version as title\n        \"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udcda Deploying documentation with mike...\")\n\n        # Get version if not provided\n        if version is None:\n            version = await self._get_project_version()\n            if self.verbose:\n                console.print(f\"Using project version: {version}\")\n\n        # Use version as title if not provided\n        if title is None:\n            title = version\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            # Configure git for mike\n            container = container.with_exec(\n                [\"git\", \"config\", \"user.name\", \"dagger-pipeline\"]\n            ).with_exec([\"git\", \"config\", \"user.email\", \"pipeline@css-kustomize.local\"])\n\n            # Deploy with mike using explicit title\n            deploy_cmd = [\n                \"poetry\",\n                \"run\",\n                \"mike\",\n                \"deploy\",\n                \"--update-aliases\",\n                \"--title\",\n                title,\n                version,\n                alias,\n            ]\n\n            if self.verbose:\n                console.print(\n                    f\"Deploying version {version} (title: {title}) with alias {alias}\"\n                )\n\n            await container.with_exec(deploy_cmd).stdout()\n\n            # Set as default if requested\n            if set_default:\n                if self.verbose:\n                    console.print(f\"Setting {alias} as default version\")\n\n                await container.with_exec(\n                    [\"poetry\", \"run\", \"mike\", \"set-default\", alias]\n                ).stdout()\n\n            console.print(\n                f\"\u2705 Documentation deployed: {version} ({alias})\", style=\"green\"\n            )\n\n    async def list_doc_versions(self) -&gt; None:\n        \"\"\"List all deployed documentation versions.\"\"\"\n        if self.verbose:\n            console.print(\"\ud83d\udccb Listing documentation versions...\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            try:\n                versions_result = await container.with_exec(\n                    [\"poetry\", \"run\", \"mike\", \"list\"]\n                ).stdout()\n\n                console.print(\n                    \"\\n\ud83d\udcda Deployed Documentation Versions:\", style=\"bold blue\"\n                )\n                console.print(\"=\" * 40)\n                console.print(versions_result)\n                console.print(\"=\" * 40)\n\n            except Exception as e:\n                console.print(\n                    \"No versions deployed yet or git repository not initialized\",\n                    style=\"yellow\",\n                )\n                if self.verbose:\n                    console.print(f\"Error: {e}\", style=\"red\")\n\n    async def delete_doc_version(self, version: str) -&gt; None:\n        \"\"\"Delete a specific documentation version.\n\n        Args:\n            version: Version to delete\n        \"\"\"\n        if self.verbose:\n            console.print(f\"\ud83d\uddd1\ufe0f Deleting documentation version: {version}\")\n\n        async with self._get_client() as client:\n            container = await self._get_docs_container(client)\n\n            await container.with_exec(\n                [\"poetry\", \"run\", \"mike\", \"delete\", version]\n            ).stdout()\n\n            console.print(f\"\u2705 Deleted documentation version: {version}\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>Initialize the Pipeline instance.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, enables detailed output during pipeline execution.     This includes container build logs, command outputs, and     detailed progress information.</p> <code>False</code> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>def __init__(self, verbose: bool = False):\n    \"\"\"Initialize the Pipeline instance.\n\n    Args:\n        verbose: If True, enables detailed output during pipeline execution.\n                This includes container build logs, command outputs, and\n                detailed progress information.\n    \"\"\"\n    self.verbose = verbose\n    self.project_root = Path.cwd()\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.build_docs","title":"<code>build_docs()</code>  <code>async</code>","text":"<p>Build documentation locally using MkDocs.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def build_docs(self) -&gt; None:\n    \"\"\"Build documentation locally using MkDocs.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83c\udfd7\ufe0f Building documentation...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        # Build documentation\n        await container.with_exec(\n            [\"poetry\", \"run\", \"mkdocs\", \"build\", \"--strict\"]\n        ).stdout()\n\n        # Copy built site back to host\n        site_dir = self.project_root / \"site\"\n        site_dir.mkdir(exist_ok=True)\n\n        # Export the built site\n        built_site = container.directory(\"site\")\n        await built_site.export(str(site_dir))\n\n        console.print(\"\u2705 Documentation built successfully\", style=\"green\")\n        console.print(f\"\ud83d\udcc1 Built site available at: {site_dir}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.delete_doc_version","title":"<code>delete_doc_version(version)</code>  <code>async</code>","text":"<p>Delete a specific documentation version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Version to delete</p> required Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def delete_doc_version(self, version: str) -&gt; None:\n    \"\"\"Delete a specific documentation version.\n\n    Args:\n        version: Version to delete\n    \"\"\"\n    if self.verbose:\n        console.print(f\"\ud83d\uddd1\ufe0f Deleting documentation version: {version}\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        await container.with_exec(\n            [\"poetry\", \"run\", \"mike\", \"delete\", version]\n        ).stdout()\n\n        console.print(f\"\u2705 Deleted documentation version: {version}\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.deploy_docs","title":"<code>deploy_docs(version=None, alias='latest', set_default=False, title=None)</code>  <code>async</code>","text":"<p>Deploy documentation with version management using mike.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>Version to deploy. If None, uses project version from pyproject.toml</p> <code>None</code> <code>alias</code> <code>str</code> <p>Version alias (default: \"latest\")</p> <code>'latest'</code> <code>set_default</code> <code>bool</code> <p>Whether to set this version as the default</p> <code>False</code> <code>title</code> <code>str | None</code> <p>Version title for display. If None, uses version as title</p> <code>None</code> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def deploy_docs(\n    self,\n    version: str | None = None,\n    alias: str = \"latest\",\n    set_default: bool = False,\n    title: str | None = None,\n) -&gt; None:\n    \"\"\"Deploy documentation with version management using mike.\n\n    Args:\n        version: Version to deploy. If None, uses project version from pyproject.toml\n        alias: Version alias (default: \"latest\")\n        set_default: Whether to set this version as the default\n        title: Version title for display. If None, uses version as title\n    \"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udcda Deploying documentation with mike...\")\n\n    # Get version if not provided\n    if version is None:\n        version = await self._get_project_version()\n        if self.verbose:\n            console.print(f\"Using project version: {version}\")\n\n    # Use version as title if not provided\n    if title is None:\n        title = version\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        # Configure git for mike\n        container = container.with_exec(\n            [\"git\", \"config\", \"user.name\", \"dagger-pipeline\"]\n        ).with_exec([\"git\", \"config\", \"user.email\", \"pipeline@css-kustomize.local\"])\n\n        # Deploy with mike using explicit title\n        deploy_cmd = [\n            \"poetry\",\n            \"run\",\n            \"mike\",\n            \"deploy\",\n            \"--update-aliases\",\n            \"--title\",\n            title,\n            version,\n            alias,\n        ]\n\n        if self.verbose:\n            console.print(\n                f\"Deploying version {version} (title: {title}) with alias {alias}\"\n            )\n\n        await container.with_exec(deploy_cmd).stdout()\n\n        # Set as default if requested\n        if set_default:\n            if self.verbose:\n                console.print(f\"Setting {alias} as default version\")\n\n            await container.with_exec(\n                [\"poetry\", \"run\", \"mike\", \"set-default\", alias]\n            ).stdout()\n\n        console.print(\n            f\"\u2705 Documentation deployed: {version} ({alias})\", style=\"green\"\n        )\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_all_overlays","title":"<code>generate_all_overlays(output_dir)</code>  <code>async</code>","text":"<p>Generate manifests for all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_all_overlays(self, output_dir: str) -&gt; None:\n    \"\"\"Generate manifests for all overlays.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83c\udfd7\ufe0f Generating all overlays...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    for overlay_path in overlays_dir.iterdir():\n        if overlay_path.is_dir():\n            await self.generate_overlay(overlay_path.name, output_dir)\n\n    console.print(\"\u2705 All overlays generated\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_overlay","title":"<code>generate_overlay(overlay_name, output_dir)</code>  <code>async</code>","text":"<p>Generate manifest for a specific overlay.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_overlay(self, overlay_name: str, output_dir: str) -&gt; None:\n    \"\"\"Generate manifest for a specific overlay.\"\"\"\n    if self.verbose:\n        console.print(f\"\ud83c\udfd7\ufe0f Generating overlay: {overlay_name}\")\n\n    overlay_path = self.project_root / \"overlays\" / overlay_name\n    if not overlay_path.exists():\n        raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n    async with self._get_client() as client:\n        container = await self._get_kustomize_container(client)\n\n        # Generate manifest\n        manifest_content = await container.with_exec(\n            [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n        ).stdout()\n\n        # Write to output directory\n        output_path = Path(output_dir)\n        output_path.mkdir(exist_ok=True)\n\n        manifest_file = output_path / f\"{overlay_name}.yaml\"\n        manifest_file.write_text(manifest_content)\n\n        if self.verbose:\n            console.print(f\"Generated manifest: {manifest_file}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.generate_version_report","title":"<code>generate_version_report()</code>  <code>async</code>","text":"<p>Generate a report of current versions across all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def generate_version_report(self) -&gt; None:\n    \"\"\"Generate a report of current versions across all overlays.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udcca Generating version report...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n\n        console.print(\"\\n\ud83d\udccb Version Report\", style=\"bold blue\")\n        console.print(\"=\" * 50)\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                overlay_name = overlay_path.name\n                kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                # Get image tag\n                try:\n                    image_tag_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    image_tag = (\n                        image_tag_result.strip()\n                        if image_tag_result.strip() != \"null\"\n                        else \"not set\"\n                    )\n                except:\n                    image_tag = \"not set\"\n\n                # Get version label\n                try:\n                    version_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    version_label = (\n                        version_label_result.strip()\n                        if version_label_result.strip() != \"null\"\n                        else \"not set\"\n                    )\n                except:\n                    version_label = \"not set\"\n\n                # Get instance label for context\n                try:\n                    instance_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/instance\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    instance_label = (\n                        instance_label_result.strip()\n                        if instance_label_result.strip() != \"null\"\n                        else \"not set\"\n                    )\n                except:\n                    instance_label = \"not set\"\n\n                # Display overlay info\n                console.print(f\"\\n\ud83c\udff7\ufe0f Overlay: {overlay_name}\", style=\"bold\")\n                console.print(f\"   Instance: {instance_label}\")\n                console.print(f\"   Image Tag: {image_tag}\")\n                console.print(f\"   Version Label: {version_label}\")\n\n                # Check completeness (both should be present but independent)\n                if image_tag != \"not set\" and version_label != \"not set\":\n                    console.print(\"   Status: \u2705 Complete\", style=\"green\")\n                else:\n                    missing = []\n                    if image_tag == \"not set\":\n                        missing.append(\"image tag\")\n                    if version_label == \"not set\":\n                        missing.append(\"version label\")\n                    console.print(\n                        f\"   Status: \u26a0\ufe0f Missing {', '.join(missing)}\", style=\"yellow\"\n                    )\n\n        console.print(\"\\n\" + \"=\" * 50)\n        console.print(\"\ud83d\udcca Report completed\", style=\"bold blue\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_markdown","title":"<code>lint_markdown()</code>  <code>async</code>","text":"<p>Run Markdown linting and formatting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_markdown(self) -&gt; None:\n    \"\"\"Run Markdown linting and formatting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running Markdown linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        # Check if there are any markdown files to lint\n        try:\n            # Find markdown files\n            md_files_result = await container.with_exec(\n                [\n                    \"find\",\n                    \".\",\n                    \"-name\",\n                    \"*.md\",\n                    \"-type\",\n                    \"f\",\n                    \"!\",\n                    \"-path\",\n                    \"./.venv/*\",\n                    \"!\",\n                    \"-path\",\n                    \"./node_modules/*\",\n                ]\n            ).stdout()\n\n            md_files = [\n                f.strip() for f in md_files_result.strip().split(\"\\n\") if f.strip()\n            ]\n\n            if not md_files:\n                console.print(\"\ud83d\udcdd No markdown files found to lint\", style=\"yellow\")\n                return\n\n            if self.verbose:\n                console.print(f\"Found {len(md_files)} markdown files to check\")\n\n            # Run mdformat check (dry-run to validate formatting)\n            await container.with_exec(\n                [\"poetry\", \"run\", \"mdformat\", \"--check\"] + md_files\n            ).stdout()\n\n            console.print(\"\u2705 Markdown linting passed\", style=\"green\")\n\n        except Exception as e:\n            console.print(\n                f\"\u274c Markdown formatting issues found: {str(e)}\", style=\"red\"\n            )\n            raise Exception(\n                \"Markdown files need formatting. Run 'poetry run mdformat .' to fix.\"\n            ) from e\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_python","title":"<code>lint_python()</code>  <code>async</code>","text":"<p>Run Python linting and formatting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_python(self) -&gt; None:\n    \"\"\"Run Python linting and formatting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running Python linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        # Run ruff check\n        await container.with_exec([\"poetry\", \"run\", \"ruff\", \"check\", \".\"]).stdout()\n\n        # Run ruff format check\n        await container.with_exec(\n            [\"poetry\", \"run\", \"ruff\", \"format\", \"--check\", \".\"]\n        ).stdout()\n\n        console.print(\"\u2705 Python linting passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.lint_yaml","title":"<code>lint_yaml()</code>  <code>async</code>","text":"<p>Run YAML linting using yamllint.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def lint_yaml(self) -&gt; None:\n    \"\"\"Run YAML linting using yamllint.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running YAML linting...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        result = await container.with_exec(\n            [\"poetry\", \"run\", \"yamllint\", \".\"]\n        ).stdout()\n\n        if self.verbose:\n            console.print(result)\n\n        console.print(\"\u2705 YAML linting passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.list_doc_versions","title":"<code>list_doc_versions()</code>  <code>async</code>","text":"<p>List all deployed documentation versions.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def list_doc_versions(self) -&gt; None:\n    \"\"\"List all deployed documentation versions.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udccb Listing documentation versions...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        try:\n            versions_result = await container.with_exec(\n                [\"poetry\", \"run\", \"mike\", \"list\"]\n            ).stdout()\n\n            console.print(\n                \"\\n\ud83d\udcda Deployed Documentation Versions:\", style=\"bold blue\"\n            )\n            console.print(\"=\" * 40)\n            console.print(versions_result)\n            console.print(\"=\" * 40)\n\n        except Exception as e:\n            console.print(\n                \"No versions deployed yet or git repository not initialized\",\n                style=\"yellow\",\n            )\n            if self.verbose:\n                console.print(f\"Error: {e}\", style=\"red\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.run_all_linting","title":"<code>run_all_linting()</code>  <code>async</code>","text":"<p>Run all linting checks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def run_all_linting(self) -&gt; None:\n    \"\"\"Run all linting checks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running comprehensive linting...\")\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        console=console,\n    ) as progress:\n        task1 = progress.add_task(\"YAML linting...\", total=None)\n        await self.lint_yaml()\n        progress.update(task1, completed=True)\n\n        task2 = progress.add_task(\"Python linting...\", total=None)\n        await self.lint_python()\n        progress.update(task2, completed=True)\n\n        task3 = progress.add_task(\"Markdown linting...\", total=None)\n        await self.lint_markdown()\n        progress.update(task3, completed=True)\n\n        task4 = progress.add_task(\"Kustomize validation...\", total=None)\n        await self.validate_kustomize()\n        progress.update(task4, completed=True)\n\n    console.print(\"\u2705 All linting checks completed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.run_pre_commit","title":"<code>run_pre_commit()</code>  <code>async</code>","text":"<p>Run pre-commit hooks.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def run_pre_commit(self) -&gt; None:\n    \"\"\"Run pre-commit hooks.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Running pre-commit hooks...\")\n\n    async with self._get_client() as client:\n        container = await self._get_python_container(client)\n\n        await container.with_exec(\n            [\"poetry\", \"run\", \"pre-commit\", \"run\", \"--all-files\"]\n        ).stdout()\n\n        console.print(\"\u2705 Pre-commit hooks passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.serve_docs","title":"<code>serve_docs(port=8000)</code>  <code>async</code>","text":"<p>Serve documentation locally for development.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def serve_docs(self, port: int = 8000) -&gt; None:\n    \"\"\"Serve documentation locally for development.\"\"\"\n    if self.verbose:\n        console.print(f\"\ud83c\udf10 Starting documentation server on port {port}...\")\n\n    async with self._get_client() as client:\n        container = await self._get_docs_container(client)\n\n        console.print(\n            f\"\ud83d\udcda Documentation server starting at http://localhost:{port}\"\n        )\n        console.print(\"Press Ctrl+C to stop the server\")\n\n        # Serve documentation (this will run until interrupted)\n        await container.with_exec(\n            [\"poetry\", \"run\", \"mkdocs\", \"serve\", \"--dev-addr\", f\"0.0.0.0:{port}\"]\n        ).stdout()\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.setup_environment","title":"<code>setup_environment()</code>  <code>async</code>","text":"<p>Set up development environment.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def setup_environment(self) -&gt; None:\n    \"\"\"Set up development environment.\"\"\"\n    if self.verbose:\n        console.print(\"\u2699\ufe0f Setting up development environment...\")\n\n    async with self._get_client() as client:\n        # Install Python dependencies\n        container = await self._get_python_container(client)\n\n        # Install pre-commit hooks\n        await container.with_exec(\n            [\"poetry\", \"run\", \"pre-commit\", \"install\"]\n        ).stdout()\n\n        console.print(\"\u2705 Development environment setup completed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.update_all_versions","title":"<code>update_all_versions(version, dry_run=False)</code>  <code>async</code>","text":"<p>Update version for all overlays.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def update_all_versions(self, version: str, dry_run: bool = False) -&gt; None:\n    \"\"\"Update version for all overlays.\"\"\"\n    if not self._validate_version_format(version):\n        raise Exception(\n            f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\"\n        )\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    overlay_names = [d.name for d in overlays_dir.iterdir() if d.is_dir()]\n\n    if not overlay_names:\n        console.print(\"No overlays found to update\", style=\"yellow\")\n        return\n\n    for overlay_name in overlay_names:\n        await self.update_overlay_version(overlay_name, version, dry_run)\n\n    if not dry_run:\n        console.print(\n            f\"\u2705 Updated {len(overlay_names)} overlays to version: {version}\"\n        )\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.update_overlay_version","title":"<code>update_overlay_version(overlay_name, version, dry_run=False)</code>  <code>async</code>","text":"<p>Update version for a specific overlay.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def update_overlay_version(\n    self, overlay_name: str, version: str, dry_run: bool = False\n) -&gt; None:\n    \"\"\"Update version for a specific overlay.\"\"\"\n    if not self._validate_version_format(version):\n        raise Exception(\n            f\"Invalid version format: {version}. Expected X.Y.Z or X.Y.Z-prerelease\"\n        )\n\n    overlay_path = self.project_root / \"overlays\" / overlay_name\n    if not overlay_path.exists():\n        raise Exception(f\"Overlay {overlay_name} does not exist\")\n\n    kustomization_file = overlay_path / \"kustomization.yaml\"\n    if not kustomization_file.exists():\n        raise Exception(f\"Kustomization file not found: {kustomization_file}\")\n\n    if self.verbose:\n        console.print(f\"\ud83c\udff7\ufe0f Processing overlay: {overlay_name}\")\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n\n        # Read current values for dry run\n        if dry_run:\n            current_tag_result = await container.with_exec(\n                [\n                    \"yq\",\n                    '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            current_tag = (\n                current_tag_result.strip()\n                if current_tag_result.strip() != \"null\"\n                else \"not set\"\n            )\n\n            current_version_result = await container.with_exec(\n                [\n                    \"yq\",\n                    '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            current_version = (\n                current_version_result.strip()\n                if current_version_result.strip() != \"null\"\n                else \"not set\"\n            )\n\n            console.print(\n                f\"  [DRY RUN] Would update image tag from '{current_tag}' to '{version}'\"\n            )\n            console.print(\n                f\"  [DRY RUN] Would update version label from '{current_version}' to '{version}'\"\n            )\n            return\n\n        # Update image tag\n        await container.with_exec(\n            [\n                \"yq\",\n                \"-i\",\n                f'.images[] |= select(.name == \"docker.io/solidproject/community-server\").newTag = \"{version}\"',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        # Update version label\n        await container.with_exec(\n            [\n                \"yq\",\n                \"-i\",\n                f'.labels[0].pairs.\"app.kubernetes.io/version\" = \"{version}\"',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        # Update version patch if it exists\n        patch_check = await container.with_exec(\n            [\n                \"yq\",\n                '.patches[] | select(.target.kind == \"Deployment\") | .patch',\n                f\"overlays/{overlay_name}/kustomization.yaml\",\n            ]\n        ).stdout()\n\n        if \"app.kubernetes.io~1version\" in patch_check:\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) |= sub(\"value: \\\\\"[^\\\\\"]*\\\\\"\"; \"value: \\\\\"{version}\\\\\"\"; \"g\")',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            console.print(f\"  \u2705 Updated deployment version patch to: {version}\")\n        else:\n            # Add version patch if it doesn't exist\n            patch_content = f'      - op: add\\\\n        path: /spec/template/metadata/labels/app.kubernetes.io~1version\\\\n        value: \\\\\"{version}\\\\\"'\n            await container.with_exec(\n                [\n                    \"yq\",\n                    \"-i\",\n                    f'(.patches[] | select(.target.kind == \"Deployment\") | .patch) += \"\\\\n{patch_content}\"',\n                    f\"overlays/{overlay_name}/kustomization.yaml\",\n                ]\n            ).stdout()\n            console.print(f\"  \u2705 Added deployment version patch: {version}\")\n\n        # Copy updated file back to host\n        updated_content = await container.file(\n            f\"overlays/{overlay_name}/kustomization.yaml\"\n        ).contents()\n        kustomization_file.write_text(updated_content)\n\n        console.print(f\"  \u2705 Updated image tag to: {version}\")\n        console.print(f\"  \u2705 Updated version label to: {version}\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.validate_kustomize","title":"<code>validate_kustomize()</code>  <code>async</code>","text":"<p>Validate Kustomize configurations.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def validate_kustomize(self) -&gt; None:\n    \"\"\"Validate Kustomize configurations.\"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Validating Kustomize configurations...\")\n\n    async with self._get_client() as client:\n        container = await self._get_kustomize_container(client)\n\n        # Validate base configuration\n        await container.with_exec([\"kustomize\", \"build\", \"base/\"]).stdout()\n\n        # Validate overlays\n        overlays_dir = self.project_root / \"overlays\"\n        if overlays_dir.exists():\n            for overlay_path in overlays_dir.iterdir():\n                if overlay_path.is_dir():\n                    overlay_name = overlay_path.name\n                    if self.verbose:\n                        console.print(f\"Validating overlay: {overlay_name}\")\n\n                    await container.with_exec(\n                        [\"kustomize\", \"build\", f\"overlays/{overlay_name}/\"]\n                    ).stdout()\n\n        console.print(\"\u2705 Kustomize validation passed\", style=\"green\")\n</code></pre>"},{"location":"reference/dagger_pipeline/pipeline/#dagger_pipeline.pipeline.Pipeline.validate_version_consistency","title":"<code>validate_version_consistency()</code>  <code>async</code>","text":"<p>Validate version consistency across all overlays.</p> <p>This validates that: - Image tags are present and valid (CSS application version) - Version labels are present and valid (project version from pyproject.toml) - Both are consistently applied across all overlays</p> <p>Note: Image tags and version labels are intentionally independent - image tags represent the CSS application version while version labels represent the project/tooling version.</p> Source code in <code>dagger_pipeline/pipeline.py</code> <pre><code>async def validate_version_consistency(self) -&gt; None:\n    \"\"\"Validate version consistency across all overlays.\n\n    This validates that:\n    - Image tags are present and valid (CSS application version)\n    - Version labels are present and valid (project version from pyproject.toml)\n    - Both are consistently applied across all overlays\n\n    Note: Image tags and version labels are intentionally independent -\n    image tags represent the CSS application version while version labels\n    represent the project/tooling version.\n    \"\"\"\n    if self.verbose:\n        console.print(\"\ud83d\udd0d Validating version consistency...\")\n\n    overlays_dir = self.project_root / \"overlays\"\n    if not overlays_dir.exists():\n        console.print(\"No overlays directory found\", style=\"yellow\")\n        return\n\n    # Get expected project version from pyproject.toml\n    expected_project_version = await self._get_project_version()\n\n    async with self._get_client() as client:\n        container = await self._get_yaml_container(client)\n        issues = []\n\n        for overlay_path in overlays_dir.iterdir():\n            if overlay_path.is_dir():\n                overlay_name = overlay_path.name\n                kustomization_file = f\"overlays/{overlay_name}/kustomization.yaml\"\n\n                # Get image tag\n                try:\n                    image_tag_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.images[] | select(.name == \"docker.io/solidproject/community-server\") | .newTag',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    image_tag = (\n                        image_tag_result.strip()\n                        if image_tag_result.strip() != \"null\"\n                        else None\n                    )\n                except:\n                    image_tag = None\n\n                # Get version label\n                try:\n                    version_label_result = await container.with_exec(\n                        [\n                            \"yq\",\n                            '.labels[0].pairs.\"app.kubernetes.io/version\"',\n                            kustomization_file,\n                        ]\n                    ).stdout()\n                    version_label = (\n                        version_label_result.strip()\n                        if version_label_result.strip() != \"null\"\n                        else None\n                    )\n                except:\n                    version_label = None\n\n                # Validate image tag presence\n                if not image_tag:\n                    issues.append(f\"{overlay_name}: missing image tag\")\n                elif not self._validate_version_format(image_tag):\n                    issues.append(\n                        f\"{overlay_name}: invalid image tag format '{image_tag}'\"\n                    )\n\n                # Validate version label presence and consistency with project version\n                if not version_label:\n                    issues.append(f\"{overlay_name}: missing version label\")\n                elif version_label != expected_project_version:\n                    issues.append(\n                        f\"{overlay_name}: version label '{version_label}' != project version '{expected_project_version}'\"\n                    )\n\n        if issues:\n            console.print(\"\u274c Version consistency issues found:\", style=\"red\")\n            for issue in issues:\n                console.print(f\"  \u2022 {issue}\", style=\"red\")\n            raise Exception(f\"Found {len(issues)} version consistency issues\")\n\n        console.print(\"\u2705 Version consistency validation passed\", style=\"green\")\n</code></pre>"},{"location":"user-guide/cli-commands/","title":"CLI Commands","text":"<p>The CSS Kustomize project provides a comprehensive command-line interface through the <code>dagger-pipeline</code> command. This page documents all available commands, their options, and usage examples.</p>"},{"location":"user-guide/cli-commands/#overview","title":"Overview","text":"<p>The CLI is built using Click and provides rich output with colors, progress indicators, and detailed error messages. All commands support a <code>--verbose</code> flag for detailed debugging output.</p> <pre><code>poetry run dagger-pipeline --help\n</code></pre>"},{"location":"user-guide/cli-commands/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--verbose</code> / <code>-v</code>: Enable verbose output with detailed logging</li> <li><code>--help</code>: Show help message and exit</li> </ul>"},{"location":"user-guide/cli-commands/#commands-reference","title":"Commands Reference","text":""},{"location":"user-guide/cli-commands/#lint-code-quality-checks","title":"<code>lint</code> - Code Quality Checks","text":"<p>Run various linting and formatting checks on the codebase.</p> <pre><code>poetry run dagger-pipeline lint\n</code></pre>"},{"location":"user-guide/cli-commands/#examples","title":"Examples","text":"<pre><code># Run all linting checks\npoetry run dagger-pipeline lint\n\n# Run with verbose output\npoetry run dagger-pipeline lint --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#validate-kustomize-validation","title":"<code>validate</code> - Kustomize Validation","text":"<p>Validate Kustomize configurations for all overlays.</p> <pre><code>poetry run dagger-pipeline validate [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_1","title":"Examples","text":"<pre><code># Validate all overlays\npoetry run dagger-pipeline validate\n\n# Validate with verbose output\npoetry run dagger-pipeline validate --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#generate-generate-manifests","title":"<code>generate</code> - Generate Manifests","text":"<p>Generate Kubernetes manifests for all overlays.</p> <pre><code>poetry run dagger-pipeline generate [OPTIONS] OUTPUT_DIR\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments","title":"Arguments","text":"<ul> <li><code>OUTPUT_DIR</code>: Directory where generated manifests will be saved</li> </ul>"},{"location":"user-guide/cli-commands/#examples_2","title":"Examples","text":"<pre><code># Generate all manifests\npoetry run dagger-pipeline generate manifests/\n\n# Generate to custom directory\npoetry run dagger-pipeline generate /tmp/k8s-manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#generate-overlay-generate-single-overlay","title":"<code>generate-overlay</code> - Generate Single Overlay","text":"<p>Generate manifest for a specific overlay.</p> <pre><code>poetry run dagger-pipeline generate-overlay [OPTIONS] OVERLAY_NAME OUTPUT_PATH\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_1","title":"Arguments","text":"<ul> <li><code>OVERLAY_NAME</code>: Name of the overlay to generate (e.g., <code>with-pvc</code>, <code>without-pvc</code>)</li> <li><code>OUTPUT_PATH</code>: Path where the generated manifest will be saved</li> </ul>"},{"location":"user-guide/cli-commands/#examples_3","title":"Examples","text":"<pre><code># Generate specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc manifests/with-pvc.yaml\n\n# Generate local development overlay\npoetry run dagger-pipeline generate-overlay without-pvc /tmp/local.yaml\n</code></pre>"},{"location":"user-guide/cli-commands/#security-scan-security-scanning","title":"<code>security-scan</code> - Security Scanning","text":"<p>Run security checks on Kustomize configurations.</p> <pre><code>poetry run dagger-pipeline security-scan [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_4","title":"Examples","text":"<pre><code># Scan all overlays for security issues\npoetry run dagger-pipeline security-scan\n\n# Scan with verbose output\npoetry run dagger-pipeline security-scan --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#security-scan-generated-scan-generated-manifests","title":"<code>security-scan-generated</code> - Scan Generated Manifests","text":"<p>Run security checks on previously generated manifest files.</p> <pre><code>poetry run dagger-pipeline security-scan-generated [OPTIONS] MANIFESTS_DIR\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_2","title":"Arguments","text":"<ul> <li><code>MANIFESTS_DIR</code>: Directory containing generated manifest files</li> </ul>"},{"location":"user-guide/cli-commands/#examples_5","title":"Examples","text":"<pre><code># Scan generated manifests\npoetry run dagger-pipeline security-scan-generated manifests/\n\n# Scan with verbose output\npoetry run dagger-pipeline security-scan-generated --verbose manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#version-update-update-version","title":"<code>version update</code> - Update Version","text":"<p>Update the version across all overlays (image tags and labels).</p> <pre><code>poetry run dagger-pipeline version update [OPTIONS] VERSION\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_3","title":"Arguments","text":"<ul> <li><code>VERSION</code>: Semantic version to update to (e.g., <code>6.0.3</code>, <code>6.1.0-beta.1</code>)</li> </ul>"},{"location":"user-guide/cli-commands/#options","title":"Options","text":"<ul> <li><code>--dry-run</code>: Show what would be changed without making actual changes</li> </ul>"},{"location":"user-guide/cli-commands/#examples_6","title":"Examples","text":"<pre><code># Update to new version\npoetry run dagger-pipeline version update 6.0.3\n\n# Preview changes without applying\npoetry run dagger-pipeline version update --dry-run 6.1.0\n\n# Update with verbose output\npoetry run dagger-pipeline version update --verbose 6.0.3\n</code></pre>"},{"location":"user-guide/cli-commands/#update-overlay-version-update-single-overlay","title":"<code>update-overlay-version</code> - Update Single Overlay","text":"<p>Update version for a specific overlay only.</p> <pre><code>poetry run dagger-pipeline update-overlay-version [OPTIONS] OVERLAY_NAME VERSION\n</code></pre>"},{"location":"user-guide/cli-commands/#arguments_4","title":"Arguments","text":"<ul> <li><code>OVERLAY_NAME</code>: Name of the overlay to update</li> <li><code>VERSION</code>: Semantic version to update to</li> </ul>"},{"location":"user-guide/cli-commands/#options_1","title":"Options","text":"<ul> <li><code>--dry-run</code>: Show what would be changed without making actual changes</li> </ul>"},{"location":"user-guide/cli-commands/#examples_7","title":"Examples","text":"<pre><code># Update specific overlay\npoetry run dagger-pipeline update-overlay-version with-pvc 6.0.3\n\n# Preview changes\npoetry run dagger-pipeline update-overlay-version --dry-run without-pvc 6.1.0\n</code></pre>"},{"location":"user-guide/cli-commands/#version-report-version-report","title":"<code>version-report</code> - Version Report","text":"<p>Generate a report showing current versions across all overlays.</p> <pre><code>poetry run dagger-pipeline version-report [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_8","title":"Examples","text":"<pre><code># Show version report\npoetry run dagger-pipeline version-report\n\n# Show with verbose details\npoetry run dagger-pipeline version-report --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#validate-versions-validate-version-consistency","title":"<code>validate-versions</code> - Validate Version Consistency","text":"<p>Check that image tags match version labels across all overlays.</p> <pre><code>poetry run dagger-pipeline validate-versions [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_9","title":"Examples","text":"<pre><code># Validate version consistency\npoetry run dagger-pipeline validate-versions\n\n# Validate with verbose output\npoetry run dagger-pipeline validate-versions --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#ci-complete-ci-pipeline","title":"<code>ci</code> - Complete CI Pipeline","text":"<p>Run the complete CI/CD pipeline including all linting, validation, generation, and security scanning.</p> <pre><code>poetry run dagger-pipeline ci [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_10","title":"Examples","text":"<pre><code># Run complete CI pipeline\npoetry run dagger-pipeline ci\n\n# Run with verbose output\npoetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#setup-env-setup-development-environment","title":"<code>setup-env</code> - Setup Development Environment","text":"<p>Set up the development environment with pre-commit hooks and dependencies.</p> <pre><code>poetry run dagger-pipeline setup-env [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_11","title":"Examples","text":"<pre><code># Setup development environment\npoetry run dagger-pipeline setup-env\n\n# Setup with verbose output\npoetry run dagger-pipeline setup-env --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#pre-commit-run-pre-commit-hooks","title":"<code>pre-commit</code> - Run Pre-commit Hooks","text":"<p>Execute pre-commit hooks on all files.</p> <pre><code>poetry run dagger-pipeline pre-commit [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-commands/#examples_12","title":"Examples","text":"<pre><code># Run pre-commit hooks\npoetry run dagger-pipeline pre-commit\n\n# Run with verbose output\npoetry run dagger-pipeline pre-commit --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/cli-commands/#development-workflow","title":"Development Workflow","text":"<pre><code># Quick checks during development\npoetry run dagger-pipeline lint --yaml --python\n\n# Validate changes\npoetry run dagger-pipeline validate\n\n# Generate and test manifests\npoetry run dagger-pipeline generate manifests/\npoetry run dagger-pipeline security-scan-generated manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#release-workflow","title":"Release Workflow","text":"<pre><code># Update version across all overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Validate version consistency\npoetry run dagger-pipeline validate-versions\n\n# Run complete CI pipeline\npoetry run dagger-pipeline ci --verbose\n\n# Generate final manifests\npoetry run dagger-pipeline generate manifests/\n</code></pre>"},{"location":"user-guide/cli-commands/#debugging-workflow","title":"Debugging Workflow","text":"<pre><code># Run with maximum verbosity\npoetry run dagger-pipeline ci --verbose\n\n# Check specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc /tmp/debug.yaml\n\n# Validate single aspect\npoetry run dagger-pipeline lint --python-only --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#exit-codes","title":"Exit Codes","text":"<p>The CLI uses standard exit codes:</p> <ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error (linting failures, validation errors, etc.)</li> <li><code>2</code>: Command line usage error</li> </ul>"},{"location":"user-guide/cli-commands/#environment-variables","title":"Environment Variables","text":"<p>The CLI respects these environment variables:</p> <ul> <li><code>DAGGER_LOG_LEVEL</code>: Set Dagger logging level (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>)</li> <li><code>NO_COLOR</code>: Disable colored output when set to any value</li> <li><code>FORCE_COLOR</code>: Force colored output even in non-TTY environments</li> </ul>"},{"location":"user-guide/cli-commands/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/cli-commands/#selective-operations","title":"Selective Operations","text":"<p>Run only what you need during development:</p> <pre><code># Only YAML linting\npoetry run dagger-pipeline lint\n\n# Only specific overlay\npoetry run dagger-pipeline generate-overlay without-pvc manifests/local.yaml\n</code></pre>"},{"location":"user-guide/cli-commands/#verbose-output-for-debugging","title":"Verbose Output for Debugging","text":"<p>Use verbose mode to understand what's happening:</p> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/cli-commands/#integration-with-other-tools","title":"Integration with Other Tools","text":""},{"location":"user-guide/cli-commands/#pre-commit-integration","title":"Pre-commit Integration","text":"<pre><code># Install pre-commit hooks\npoetry run dagger-pipeline setup-env\n\n# Run hooks manually\npoetry run dagger-pipeline pre-commit\n</code></pre>"},{"location":"user-guide/cli-commands/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># In CI/CD pipelines\npoetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/documentation-versioning/","title":"Documentation Versioning","text":"<p>This guide explains how to manage versioned documentation for the CSS Kustomize project using MkDocs and mike.</p>"},{"location":"user-guide/documentation-versioning/#overview","title":"Overview","text":"<p>The CSS Kustomize project uses mike for versioned documentation deployment. This allows you to:</p> <ul> <li>Deploy multiple versions of documentation simultaneously</li> <li>Maintain documentation for different releases</li> <li>Set default versions and aliases</li> <li>Provide users with version-specific documentation</li> </ul>"},{"location":"user-guide/documentation-versioning/#version-management","title":"Version Management","text":""},{"location":"user-guide/documentation-versioning/#automatic-versioning","title":"Automatic Versioning","text":"<p>The documentation version is automatically derived from the project version in <code>pyproject.toml</code>. When you deploy documentation, it will use the current project version unless explicitly specified.</p>"},{"location":"user-guide/documentation-versioning/#manual-version-deployment","title":"Manual Version Deployment","text":"<p>You can deploy documentation for a specific version:</p> <pre><code># Deploy current project version\npoetry run dagger-pipeline docs deploy\n\n# Deploy specific version with alias\npoetry run dagger-pipeline docs deploy --version 1.2.3 --alias stable\n\n# Deploy and set as default\npoetry run dagger-pipeline docs deploy --version 1.2.3 --set-default\n</code></pre>"},{"location":"user-guide/documentation-versioning/#available-commands","title":"Available Commands","text":""},{"location":"user-guide/documentation-versioning/#build-documentation","title":"Build Documentation","text":"<p>Build documentation locally for testing:</p> <pre><code>poetry run dagger-pipeline docs build\n</code></pre> <p>This creates a <code>site/</code> directory with the built documentation.</p>"},{"location":"user-guide/documentation-versioning/#serve-documentation","title":"Serve Documentation","text":"<p>Serve documentation locally for development:</p> <pre><code># Serve on default port 8000\npoetry run dagger-pipeline docs serve\n\n# Serve on custom port\npoetry run dagger-pipeline docs serve --port 3000\n</code></pre>"},{"location":"user-guide/documentation-versioning/#deploy-documentation","title":"Deploy Documentation","text":"<p>Deploy versioned documentation to GitHub Pages:</p> <pre><code># Deploy with project version and 'latest' alias\npoetry run dagger-pipeline docs deploy\n\n# Deploy specific version\npoetry run dagger-pipeline docs deploy --version 2.0.0\n\n# Deploy with custom alias\npoetry run dagger-pipeline docs deploy --version 2.0.0 --alias stable\n\n# Deploy and set as default version\npoetry run dagger-pipeline docs deploy --version 2.0.0 --set-default\n</code></pre>"},{"location":"user-guide/documentation-versioning/#list-versions","title":"List Versions","text":"<p>List all deployed documentation versions:</p> <pre><code>poetry run dagger-pipeline docs list-versions\n</code></pre>"},{"location":"user-guide/documentation-versioning/#delete-version","title":"Delete Version","text":"<p>Delete a specific documentation version:</p> <pre><code>poetry run dagger-pipeline docs delete-version 1.0.0\n</code></pre>"},{"location":"user-guide/documentation-versioning/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>The project's CI/CD pipeline automatically deploys documentation when changes are pushed to the main branch. The workflow:</p> <ol> <li>Gets the current project version from <code>pyproject.toml</code></li> <li>Deploys documentation with that version and the <code>latest</code> alias</li> <li>Sets <code>latest</code> as the default version</li> </ol>"},{"location":"user-guide/documentation-versioning/#version-display","title":"Version Display","text":"<p>The documentation site includes:</p> <ul> <li>Version selector: Users can switch between different versions</li> <li>Version badge: Shows the current version being viewed</li> <li>Latest indicator: Clearly marks the latest/default version</li> </ul>"},{"location":"user-guide/documentation-versioning/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/documentation-versioning/#version-naming","title":"Version Naming","text":"<ul> <li>Use semantic versioning (e.g., <code>1.2.3</code>)</li> <li>Use meaningful aliases like <code>latest</code>, <code>stable</code>, <code>dev</code></li> <li>Avoid overwriting existing versions unless necessary</li> </ul>"},{"location":"user-guide/documentation-versioning/#deployment-strategy","title":"Deployment Strategy","text":"<ul> <li>Deploy documentation for each release</li> <li>Keep the <code>latest</code> alias pointing to the most recent stable release</li> <li>Use descriptive commit messages when deploying documentation</li> </ul>"},{"location":"user-guide/documentation-versioning/#maintenance","title":"Maintenance","text":"<ul> <li>Regularly review and clean up old versions</li> <li>Ensure documentation stays in sync with code changes</li> <li>Test documentation builds before deployment</li> </ul>"},{"location":"user-guide/documentation-versioning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/documentation-versioning/#common-issues","title":"Common Issues","text":"<p>Git configuration errors: Ensure git is properly configured in your environment.</p> <p>Version conflicts: Use <code>list-versions</code> to check existing versions before deployment.</p> <p>Build failures: Run <code>docs build</code> locally to test before deployment.</p>"},{"location":"user-guide/documentation-versioning/#getting-help","title":"Getting Help","text":"<p>For issues with documentation versioning:</p> <ol> <li>Check the build logs with <code>--verbose</code> flag</li> <li>Verify your git configuration</li> <li>Ensure all dependencies are installed with <code>poetry install --with=docs</code></li> </ol>"},{"location":"user-guide/documentation-versioning/#examples","title":"Examples","text":""},{"location":"user-guide/documentation-versioning/#release-workflow","title":"Release Workflow","text":"<p>When releasing version 2.1.0:</p> <pre><code># Update project version\npoetry version 2.1.0\n\n# Deploy documentation\npoetry run dagger-pipeline docs deploy --version 2.1.0 --alias latest --set-default\n\n# Verify deployment\npoetry run dagger-pipeline docs list-versions\n</code></pre>"},{"location":"user-guide/documentation-versioning/#development-workflow","title":"Development Workflow","text":"<p>For development documentation:</p> <pre><code># Serve locally during development\npoetry run dagger-pipeline docs serve\n\n# Build and test\npoetry run dagger-pipeline docs build\n\n# Deploy development version\npoetry run dagger-pipeline docs deploy --version dev --alias development\n</code></pre>"},{"location":"user-guide/kustomize-overlays/","title":"Kustomize Overlays","text":"<p>Learn how to work with Kustomize overlays in the CSS Kustomize project.</p>"},{"location":"user-guide/kustomize-overlays/#overview","title":"Overview","text":"<p>This project uses Kustomize overlays to manage environment-specific configurations for the Community Solid Server.</p>"},{"location":"user-guide/kustomize-overlays/#available-overlays","title":"Available Overlays","text":""},{"location":"user-guide/kustomize-overlays/#with-pvc","title":"<code>with-pvc</code>","text":"<ul> <li>Purpose: Production-like deployment</li> <li>Release Name: <code>css-with-pvc</code></li> <li>Storage: PersistentVolumeClaim</li> <li>Use Case: Production deployments requiring persistence</li> </ul>"},{"location":"user-guide/kustomize-overlays/#without-pvc","title":"<code>without-pvc</code>","text":"<ul> <li>Purpose: Stateless deployment</li> <li>Release Name: <code>css-without-pvc</code></li> <li>Storage: None</li> <li>Use Case: Stateless production deployments</li> </ul>"},{"location":"user-guide/kustomize-overlays/#working-with-overlays","title":"Working with Overlays","text":""},{"location":"user-guide/kustomize-overlays/#building-manifests","title":"Building Manifests","text":"<pre><code># Build specific overlay\nkubectl kustomize overlays/with-pvc\n\n# Generate to file\nkubectl kustomize overlays/with-pvc &gt; manifests/with-pvc.yaml\n</code></pre>"},{"location":"user-guide/kustomize-overlays/#using-the-cli","title":"Using the CLI","text":"<pre><code># Generate all overlays\npoetry run dagger-pipeline generate manifests/\n\n# Generate specific overlay\npoetry run dagger-pipeline generate-overlay with-pvc manifests/with-pvc.yaml\n</code></pre>"},{"location":"user-guide/kustomize-overlays/#customization","title":"Customization","text":""},{"location":"user-guide/kustomize-overlays/#adding-new-overlays","title":"Adding New Overlays","text":"<ol> <li>Create new directory in <code>overlays/</code></li> <li>Add <code>kustomization.yaml</code></li> <li>Configure patches and resources</li> <li>Update CLI to include new overlay</li> </ol>"},{"location":"user-guide/kustomize-overlays/#modifying-existing-overlays","title":"Modifying Existing Overlays","text":"<p>Edit the <code>kustomization.yaml</code> files to customize:</p> <ul> <li>Resource patches</li> <li>ConfigMap generators</li> <li>Label transformers</li> <li>Name prefixes/suffixes</li> </ul>"},{"location":"user-guide/kustomize-overlays/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Version Management</li> <li>Check CLI Commands</li> </ul>"},{"location":"user-guide/version-management/","title":"Version Management","text":"<p>Learn how to manage versions across CSS Kustomize overlays and deployments.</p>"},{"location":"user-guide/version-management/#overview","title":"Overview","text":"<p>CSS Kustomize provides comprehensive version management capabilities to ensure consistency across all overlays and deployments.</p>"},{"location":"user-guide/version-management/#version-strategy","title":"Version Strategy","text":""},{"location":"user-guide/version-management/#semantic-versioning","title":"Semantic Versioning","text":"<p>The project follows semantic versioning (SemVer) for Community Solid Server versions:</p> <ul> <li><code>MAJOR.MINOR.PATCH</code> (e.g., <code>6.0.3</code>)</li> <li>Pre-release versions: <code>6.1.0-beta.1</code></li> </ul>"},{"location":"user-guide/version-management/#version-consistency","title":"Version Consistency","text":"<p>All overlays maintain consistent versions across:</p> <ul> <li>Container image tags</li> <li>Kubernetes labels (<code>app.kubernetes.io/version</code>)</li> <li>Documentation references</li> </ul>"},{"location":"user-guide/version-management/#cli-commands","title":"CLI Commands","text":""},{"location":"user-guide/version-management/#update-all-overlays","title":"Update All Overlays","text":"<pre><code># Update version across all overlays\npoetry run dagger-pipeline version update 6.0.3\n\n# Preview changes without applying\npoetry run dagger-pipeline version update --dry-run 6.1.0\n</code></pre>"},{"location":"user-guide/version-management/#update-single-overlay","title":"Update Single Overlay","text":"<pre><code># Update specific overlay only\npoetry run dagger-pipeline update-overlay-version with-pvc 6.0.3\n\n# Preview changes for single overlay\npoetry run dagger-pipeline update-overlay-version --dry-run without-pvc 6.1.0\n</code></pre>"},{"location":"user-guide/version-management/#version-reporting","title":"Version Reporting","text":"<pre><code># Show current versions across all overlays\npoetry run dagger-pipeline version-report\n\n# Validate version consistency\npoetry run dagger-pipeline validate-versions\n</code></pre>"},{"location":"user-guide/version-management/#version-locations","title":"Version Locations","text":""},{"location":"user-guide/version-management/#image-tags","title":"Image Tags","text":"<p>Container image versions are specified in overlay patches:</p> <pre><code># overlays/with-pvc/kustomization.yaml\nimages:\n  - name: solidproject/community-server\n    newTag: \"6.0.3\"\n</code></pre>"},{"location":"user-guide/version-management/#kubernetes-labels","title":"Kubernetes Labels","text":"<p>Version labels are applied automatically:</p> <pre><code>labels:\n  - includeSelectors: false\n    pairs:\n      app.kubernetes.io/version: \"6.0.3\"\n</code></pre>"},{"location":"user-guide/version-management/#documentation","title":"Documentation","text":"<p>Version references in documentation are updated automatically during version updates.</p>"},{"location":"user-guide/version-management/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/version-management/#before-updating","title":"Before Updating","text":"<ol> <li>Check current versions:</li> </ol> <pre><code>poetry run dagger-pipeline version-report\n</code></pre> <ol> <li>Validate consistency:</li> </ol> <pre><code>poetry run dagger-pipeline validate-versions\n</code></pre>"},{"location":"user-guide/version-management/#during-updates","title":"During Updates","text":"<ol> <li>Use dry-run first:</li> </ol> <pre><code>poetry run dagger-pipeline version update --dry-run 6.0.3\n</code></pre> <ol> <li> <p>Update incrementally for major changes</p> </li> <li> <p>Test after updates:</p> </li> </ol> <pre><code>poetry run dagger-pipeline ci --verbose\n</code></pre>"},{"location":"user-guide/version-management/#after-updates","title":"After Updates","text":"<ol> <li>Validate changes:</li> </ol> <pre><code>poetry run dagger-pipeline validate-versions\n</code></pre> <ol> <li>Generate manifests:</li> </ol> <pre><code>poetry run dagger-pipeline generate manifests/\n</code></pre> <ol> <li>Test deployments in development environment</li> </ol>"},{"location":"user-guide/version-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/version-management/#version-mismatches","title":"Version Mismatches","text":"<p>If versions are inconsistent:</p> <pre><code># Check what's wrong\npoetry run dagger-pipeline validate-versions --verbose\n\n# Fix automatically\npoetry run dagger-pipeline version update $(current-version)\n</code></pre>"},{"location":"user-guide/version-management/#rollback-changes","title":"Rollback Changes","text":"<p>To rollback version changes:</p> <pre><code># Use git to revert\ngit checkout -- overlays/\n\n# Or update to previous version\npoetry run dagger-pipeline version update 6.0.2\n</code></pre>"},{"location":"user-guide/version-management/#integration","title":"Integration","text":""},{"location":"user-guide/version-management/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>Include version validation in CI:</p> <pre><code># In CI pipeline\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci\n</code></pre>"},{"location":"user-guide/version-management/#release-workflows","title":"Release Workflows","text":"<p>Typical release workflow:</p> <pre><code># 1. Update version\npoetry run dagger-pipeline update-version 6.0.3\n\n# 2. Validate and test\npoetry run dagger-pipeline validate-versions\npoetry run dagger-pipeline ci --verbose\n\n# 3. Generate final manifests\npoetry run dagger-pipeline generate manifests/\n\n# 4. Commit and tag\ngit add .\ngit commit -m \"Release 6.0.3\"\ngit tag v6.0.3\n</code></pre>"}]}